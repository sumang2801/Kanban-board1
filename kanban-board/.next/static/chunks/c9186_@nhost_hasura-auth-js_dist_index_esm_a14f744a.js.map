{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@nhost+hasura-auth-js@2.12.0/node_modules/@nhost/hasura-auth-js/dist/index.esm.js","sources":["file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/constants.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/errors.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/machines/authentication/context.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/node_modules/.pnpm/%40simplewebauthn%2Bbrowser%409.0.1/node_modules/%40simplewebauthn/browser/dist/bundle/index.js","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/local-storage.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/utils/client-helpers.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/utils/environment.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/utils/fetch.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/utils/url.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/utils/validators.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/machines/authentication/machine.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/machines/change-email.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/machines/change-password.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/machines/enable-mfa.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/machines/reset-password.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/machines/send-verification-email.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/internal-client.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/addSecurityKey.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/changeEmail.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/changePassword.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/mfa.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/resetPassword.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/sendVerificationEmail.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInAnonymous.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInEmailPassword.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInEmailPasswordless.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInEmailSecurityKey.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/elevateEmailSecurityKey.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInMfaTotp.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInPAT.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInSmsPasswordless.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInSmsPasswordlessOtp.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signOut.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signUpEmailPassword.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signUpEmailSecurityKey.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInEmailOTP.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInIdToken.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/linkIdToken.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/signInSecurityKey.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/promises/createPAT.ts","file:///home/suman/Kanban-board1-2/kanban-board/node_modules/.pnpm/%40nhost%2Bhasura-auth-js%402.12.0/node_modules/%40nhost/hasura-auth-js/src/hasura-auth-client.ts"],"sourcesContent":["export const NHOST_REFRESH_TOKEN_KEY = 'nhostRefreshToken'\nexport const NHOST_REFRESH_TOKEN_ID_KEY = 'nhostRefreshTokenId'\nexport const NHOST_JWT_EXPIRES_AT_KEY = 'nhostRefreshTokenExpiresAt'\n\nexport const MIN_PASSWORD_LENGTH = 3\n\n/**\n * Minimum time in seconds between now and the JWT expiration time before the JWT is refreshed\n * For instance, if set to 60, the client will refresh the JWT one minute before it expires\n */\nexport const TOKEN_REFRESH_MARGIN_SECONDS = 60\n\nexport const REFRESH_TOKEN_MAX_ATTEMPTS = 5\n","import { AuthErrorPayload } from './types'\n\nexport const NETWORK_ERROR_CODE = 0\nexport const OTHER_ERROR_CODE = 1\nexport const VALIDATION_ERROR_CODE = 10\nexport const STATE_ERROR_CODE = 20\n\n/**\n * @internal\n * Adds a standard error payload to any JS Error, or convert a standard error payload into a JS Error.\n * Allows xstate to use `throw` instead of `Promise.reject` to propagate errors.\n * See https://github.com/statelyai/xstate/issues/3037\n */\nexport class CodifiedError extends Error {\n  error: AuthErrorPayload\n  constructor(original: Error | AuthErrorPayload) {\n    super(original.message)\n\n    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor)\n\n    if (original instanceof Error) {\n      this.name = original.name\n      this.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      }\n    } else {\n      this.name = original.error\n      this.error = original\n    }\n  }\n}\n\nexport type ValidationAuthErrorPayload = AuthErrorPayload & { status: typeof VALIDATION_ERROR_CODE }\n\n// TODO share with hasura-auth\nexport const INVALID_EMAIL_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-email',\n  message: 'Email is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TYPE_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-type',\n  message: 'MFA type is invalid'\n}\n\nexport const INVALID_MFA_CODE_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-code',\n  message: 'MFA code is invalid'\n}\n\nexport const INVALID_PASSWORD_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-password',\n  message: 'Password is incorrectly formatted'\n}\n\nexport const INVALID_PHONE_NUMBER_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-phone-number',\n  message: 'Phone number is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TICKET_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-ticket',\n  message: 'MFA ticket is invalid'\n}\n\nexport const NO_MFA_TICKET_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-mfa-ticket',\n  message: 'No MFA ticket has been provided'\n}\n\nexport const NO_REFRESH_TOKEN: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-refresh-token',\n  message: 'No refresh token has been provided'\n}\n\nexport const TOKEN_REFRESHER_RUNNING_ERROR: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'refresher-already-running',\n  message:\n    'The token refresher is already running. You must wait until is has finished before submitting a new token.'\n}\n\nexport const USER_ALREADY_SIGNED_IN: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'already-signed-in',\n  message: 'User is already signed in'\n}\n\nexport const USER_UNAUTHENTICATED: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unauthenticated-user',\n  message: 'User is not authenticated'\n}\n\nexport const USER_NOT_ANONYMOUS: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'user-not-anonymous',\n  message: 'User is not anonymous'\n}\n\nexport const EMAIL_NEEDS_VERIFICATION: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unverified-user',\n  message: 'Email needs verification'\n}\n\nexport const INVALID_REFRESH_TOKEN: AuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-refresh-token',\n  message: 'Invalid or expired refresh token'\n}\n\nexport const INVALID_SIGN_IN_METHOD: AuthErrorPayload = {\n  status: OTHER_ERROR_CODE,\n  error: 'invalid-sign-in-method',\n  message: 'Invalid sign-in method'\n}\n","import { AuthErrorPayload, User } from '../../types'\n\nexport type StateErrorTypes = 'registration' | 'authentication' | 'signout'\n\nexport type AuthContext = {\n  user: User | null\n  mfa: {\n    ticket: string\n  } | null\n  accessToken: {\n    value: string | null\n    expiresAt: Date | null\n    expiresInSeconds: number | null\n  }\n  refreshTimer: {\n    startedAt: Date | null\n    attempts: number\n    lastAttempt: Date | null\n  }\n  refreshToken: {\n    value: string | null\n    isPAT?: boolean\n  }\n  /** Number of times the user tried to get an access token from a refresh token but got a network error */\n  importTokenAttempts: number\n  errors: Partial<Record<StateErrorTypes, AuthErrorPayload>>\n}\n\nexport const INITIAL_MACHINE_CONTEXT: AuthContext = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null,\n    expiresInSeconds: 15\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  importTokenAttempts: 0,\n  errors: {}\n}\n","/* [@simplewebauthn/browser@9.0.1] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return (window?.PublicKeyCredential !== undefined &&\n        typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        super(message, { cause });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nclass BaseWebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nconst WebAuthnAbortService = new BaseWebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nfunction browserSupportsWebAuthnAutofill() {\n    const globalPublicKeyCredential = window\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential.isConditionalMediationAvailable === undefined) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return globalPublicKeyCredential.isConditionalMediationAvailable();\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (requestOptionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = requestOptionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll('input[autocomplete$=\\'webauthn\\']');\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { WebAuthnAbortService, WebAuthnError, base64URLStringToBuffer, browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, bufferToBase64URLString, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","import Cookies from 'js-cookie'\n\nimport { ClientStorage, ClientStorageType, StorageGetter, StorageSetter } from './types'\n\nconst isBrowser = typeof window !== 'undefined'\n\nconst inMemoryLocalStorage: Map<string, string | null> = new Map()\n\nconst defaultClientStorageGetter: StorageGetter = (key) => {\n  if (isBrowser && typeof localStorage !== 'undefined') return localStorage.getItem(key)\n  else return inMemoryLocalStorage.get(key) ?? null\n}\n\nconst defaultClientStorageSetter: StorageSetter = (key, value) => {\n  if (isBrowser && typeof localStorage !== 'undefined') {\n    if (value) {\n      localStorage.setItem(key, value)\n    } else {\n      localStorage.removeItem(key)\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value)\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key)\n    }\n  }\n}\n\nexport const localStorageGetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageGetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageGetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key) => {\n      if (isBrowser) {\n        return Cookies.get(key) ?? null\n      } else {\n        return null\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clientStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key) => clientStorage.getItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key) => clientStorage.get?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return (key) => clientStorage.getItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing either \"getItem\" and \"removeItem\" properties or \"getItemAsync\" property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n\nexport const localStorageSetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageSetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageSetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key, value) => {\n      if (isBrowser) {\n        if (value) {\n          // TODO: Set expires based on the actual refresh token expire time\n          // For now, we're using 30 days so the cookie is not removed when the browser is closed because if `expiers` is omitted, the cookie becomes a session cookie.\n          Cookies.set(key, value, { expires: 30, sameSite: 'lax', httpOnly: false })\n        } else {\n          Cookies.remove(key)\n        }\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clienStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key, value) =>\n      value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key, value) =>\n      value ? clientStorage.set?.({ key, value }) : clientStorage.remove?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return async (key, value) =>\n      value ? clientStorage.setItemAsync?.(key, value) : clientStorage.deleteItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (!clientStorage.removeItem) {\n      throw Error(\n        `clientStorageType is set to 'custom' but clientStorage is missing a removeItem property`\n      )\n    }\n    if (clientStorage.setItem) {\n      return (key, value) =>\n        value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    if (clientStorage.setItemAsync) {\n      return async (key, value) =>\n        value ? clientStorage.setItemAsync?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n","import { AuthContext } from '../machines'\nimport { SessionActionHandlerResult } from '../promises'\nimport { NhostSession, SignUpResponse } from '../types'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (!context || !context.accessToken.value || !context.accessToken.expiresAt || !context.user) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  refreshToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: refreshToken, user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n","export const isBrowser = () =>\n  typeof window !== 'undefined' && typeof window.location !== 'undefined'\n","import fetchPonyfill from 'fetch-ponyfill'\nimport { NETWORK_ERROR_CODE } from '../errors'\nimport { NullableErrorResponse } from '../types'\n\ndeclare const EdgeRuntime: any\n\ninterface FetchResponse<T> extends NullableErrorResponse {\n  data: T\n}\n\nlet fetch = globalThis.fetch\n\nif (typeof EdgeRuntime !== 'string') {\n  fetch = fetchPonyfill().fetch\n}\n\nconst fetchWrapper = async <T>(\n  url: string,\n  method: 'GET' | 'POST',\n  {\n    token,\n    body,\n    extraHeaders\n  }: { token?: string | null; body?: any; extraHeaders?: HeadersInit } = {}\n): Promise<FetchResponse<T>> => {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n    Accept: '*/*'\n  }\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`\n  }\n\n  const mergedHeaders = { ...headers, ...extraHeaders }\n\n  const options: RequestInit = {\n    method,\n    headers: mergedHeaders\n  }\n  if (body) {\n    options.body = JSON.stringify(body)\n  }\n  try {\n    const result = await fetch(url, options)\n    if (!result.ok) {\n      const error = await result.json()\n      return Promise.reject<FetchResponse<T>>({ error })\n    }\n    try {\n      const data = await result.json()\n      return { data, error: null }\n    } catch {\n      console.warn(`Unexpected response: can't parse the response of the server at ${url}`)\n      return { data: 'OK' as any, error: null }\n    }\n  } catch (e) {\n    const error = {\n      message: 'Network Error',\n      status: NETWORK_ERROR_CODE,\n      error: 'network'\n    }\n    return Promise.reject<FetchResponse<T>>({ error })\n  }\n}\n\nexport const postFetch = async <T>(\n  url: string,\n  body: any,\n  token?: string | null,\n  extraHeaders?: HeadersInit\n): Promise<FetchResponse<T>> => fetchWrapper<T>(url, 'POST', { token, body, extraHeaders })\n\nexport const getFetch = <T>(url: string, token?: string | null): Promise<FetchResponse<T>> =>\n  fetchWrapper<T>(url, 'GET', { token })\n","import { RedirectOption } from '../types'\n\nexport const encodeQueryParameters = (baseUrl: string, parameters?: Record<string, unknown>) => {\n  const encodedParameters =\n    parameters &&\n    Object.entries(parameters)\n      .map(([key, value]) => {\n        const stringValue = Array.isArray(value)\n          ? value.join(',')\n          : typeof value === 'object'\n          ? JSON.stringify(value)\n          : (value as string)\n        return `${key}=${encodeURIComponent(stringValue)}`\n      })\n      .join('&')\n  if (encodedParameters) return `${baseUrl}?${encodedParameters}`\n  else return baseUrl\n}\n\n/**\n * Transform options that include a redirectTo property so the\n * redirect url is absolute, given a base clientUrl.\n * If no client url is given, any relative redirectUrl is removed while\n * the other options are sent as-is.\n * @param clientUrl base client url\n * @param options\n * @returns\n */\nexport const rewriteRedirectTo = <T extends RedirectOption>(\n  clientUrl?: string,\n  options?: T\n): (Omit<T, 'redirectTo'> & { redirectTo?: string }) | undefined => {\n  if (!options?.redirectTo) {\n    return options\n  }\n  const { redirectTo, ...otherOptions } = options\n  // * If the clientUrl is not defined, we can't rewrite the redirectTo\n  if (!clientUrl) {\n    // * If redirectTo is a relative path, we therefore pull it out of the options\n    if (redirectTo.startsWith('/')) {\n      return otherOptions\n    } else {\n      return options\n    }\n  }\n  const baseClientUrl = new URL(clientUrl)\n  const clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search))\n  const url = new URL(redirectTo.startsWith('/') ? baseClientUrl.origin + redirectTo : redirectTo)\n  const additionalParams = new URLSearchParams(url.search)\n  let combinedParams = Object.fromEntries(additionalParams)\n\n  if (redirectTo.startsWith('/')) {\n    combinedParams = { ...clientParams, ...combinedParams }\n  }\n  let pathName = baseClientUrl.pathname\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1)\n  }\n  return {\n    ...otherOptions,\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  }\n}\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) {\n    if (typeof window === 'undefined') {\n      return\n    }\n    url = window.location?.href || ''\n  }\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\nexport function removeParameterFromWindow(name: string) {\n  if (typeof window === 'undefined') {\n    return\n  }\n  const location = window?.location\n  if (!location) {\n    return\n  }\n  if (location) {\n    const search = new URLSearchParams(location.search)\n    const hash = new URLSearchParams(location.hash?.slice(1))\n    search.delete(name)\n    hash.delete(name)\n    let url = window.location.pathname\n    if (Array.from(search).length) url += `?${search.toString()}`\n    if (Array.from(hash).length) url += `#${hash.toString()}`\n    window.history.pushState({}, '', url)\n  }\n}\n","import { MIN_PASSWORD_LENGTH } from '../constants'\n\nexport const isValidEmail = (email?: string | null) =>\n  !!email &&\n  typeof email === 'string' &&\n  !!String(email)\n    .toLowerCase()\n    .match(\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    )\n\nexport const isValidPassword = (password?: string | null) =>\n  !!password && typeof password === 'string' && password.length >= MIN_PASSWORD_LENGTH\n\n// TODO improve validation\nexport const isValidPhoneNumber = (phoneNumber?: string | null) =>\n  !!phoneNumber && typeof phoneNumber === 'string'\n\nexport const isValidTicket = (ticket?: string | null) =>\n  ticket &&\n  typeof ticket === 'string' &&\n  ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)\n","import { startAuthentication, startRegistration } from '@simplewebauthn/browser'\nimport type {\n  AuthenticationCredentialJSON,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\nimport { assign, createMachine, InterpreterFrom, send } from 'xstate'\nimport {\n  NHOST_JWT_EXPIRES_AT_KEY,\n  NHOST_REFRESH_TOKEN_ID_KEY,\n  NHOST_REFRESH_TOKEN_KEY,\n  REFRESH_TOKEN_MAX_ATTEMPTS,\n  TOKEN_REFRESH_MARGIN_SECONDS\n} from '../../constants'\nimport {\n  CodifiedError,\n  INVALID_EMAIL_ERROR,\n  INVALID_MFA_TICKET_ERROR,\n  INVALID_PASSWORD_ERROR,\n  INVALID_PHONE_NUMBER_ERROR,\n  NETWORK_ERROR_CODE,\n  NO_MFA_TICKET_ERROR,\n  VALIDATION_ERROR_CODE\n} from '../../errors'\nimport { localStorageGetter, localStorageSetter } from '../../local-storage'\nimport {\n  AuthErrorPayload,\n  AuthOptions,\n  DeanonymizeResponse,\n  NhostSession,\n  NhostSessionResponse,\n  PasswordlessEmailResponse,\n  PasswordlessSmsOtpResponse,\n  PasswordlessSmsResponse,\n  RefreshSessionResponse,\n  SignInAnonymousResponse,\n  SignInEmailOTPResponse,\n  SignInMfaTotpResponse,\n  SignInPATResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpResponse,\n  VerifyEmailOTPResponse\n} from '../../types'\nimport {\n  getParameterByName,\n  isValidEmail,\n  isValidPassword,\n  isValidPhoneNumber,\n  isValidTicket,\n  postFetch,\n  removeParameterFromWindow,\n  rewriteRedirectTo\n} from '../../utils'\nimport { AuthContext, INITIAL_MACHINE_CONTEXT } from './context'\nimport { AuthEvents } from './events'\n\nexport interface AuthMachineOptions extends AuthOptions {\n  backendUrl: string\n  clientUrl: string\n}\n\nexport type AuthMachine = ReturnType<typeof createAuthMachine>\nexport type AuthInterpreter = InterpreterFrom<AuthMachine>\n\ntype AuthServices = {\n  signInPassword: { data: SignInResponse }\n  passwordlessSms: { data: PasswordlessSmsResponse | DeanonymizeResponse }\n  passwordlessSmsOtp: { data: PasswordlessSmsOtpResponse }\n  signInEmailOTP: { data: SignInEmailOTPResponse }\n  verifyEmailOTP: { data: VerifyEmailOTPResponse }\n  passwordlessEmail: { data: PasswordlessEmailResponse | DeanonymizeResponse }\n  signInAnonymous: { data: SignInAnonymousResponse }\n  signInPAT: { data: SignInPATResponse }\n  signInIdToken: { data: SignInResponse }\n  signInMfaTotp: { data: SignInMfaTotpResponse }\n  signInSecurityKeyEmail: { data: SignInResponse }\n  signInSecurityKey: { data: SignInResponse }\n  refreshToken: { data: NhostSessionResponse }\n  signout: { data: SignOutResponse }\n  signUpEmailPassword: { data: SignUpResponse }\n  signUpSecurityKey: { data: SignUpResponse }\n  importRefreshToken: { data: NhostSessionResponse }\n}\n\nexport const createAuthMachine = ({\n  backendUrl,\n  clientUrl,\n  broadcastKey,\n  clientStorageType = 'web',\n  clientStorage,\n  refreshIntervalTime,\n  autoRefreshToken = true,\n  autoSignIn = true\n}: AuthMachineOptions) => {\n  const storageGetter = localStorageGetter(clientStorageType, clientStorage)\n  const storageSetter = localStorageSetter(clientStorageType, clientStorage)\n  const postRequest = async <T = any, D = any>(\n    url: string,\n    data?: D,\n    token?: string | null,\n    headers?: Record<string, string>\n  ): Promise<T> => {\n    const result = await postFetch<T>(`${backendUrl}${url}`, data, token, headers)\n\n    return result.data\n  }\n\n  // Create a shared BroadcastChannel for broadcasting tokens and signout events\n  let sharedBroadcastChannel: BroadcastChannel | null = null\n  if (typeof window !== 'undefined' && broadcastKey) {\n    try {\n      sharedBroadcastChannel = new BroadcastChannel(broadcastKey)\n      // console.debug('[AUTH] Created shared BroadcastChannel with key:', broadcastKey)\n    } catch (error) {\n      // console.debug('[AUTH] BroadcastChannel is not available e.g. react-native')\n    }\n  }\n\n  return createMachine(\n    {\n      schema: {\n        context: {} as AuthContext,\n        events: {} as AuthEvents,\n        services: {} as AuthServices\n      },\n      tsTypes: {} as import('./machine.typegen').Typegen0,\n      context: INITIAL_MACHINE_CONTEXT,\n      predictableActionArguments: true,\n      id: 'nhost',\n      type: 'parallel',\n      states: {\n        authentication: {\n          initial: 'starting',\n          on: {\n            SESSION_UPDATE: [\n              {\n                cond: 'hasSession',\n                actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                target: '.signedIn'\n              }\n            ]\n          },\n          states: {\n            starting: {\n              tags: ['loading'],\n              always: { cond: 'isSignedIn', target: 'signedIn' },\n              invoke: {\n                id: 'importRefreshToken',\n                src: 'importRefreshToken',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: 'signedIn'\n                  },\n                  {\n                    target: 'signedOut'\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'shouldRetryImportToken',\n                    actions: 'incrementTokenImportAttempts',\n                    target: 'retryTokenImport'\n                  },\n                  { actions: ['saveAuthenticationError'], target: 'signedOut' }\n                ]\n              }\n            },\n            retryTokenImport: {\n              tags: ['loading'],\n              after: {\n                RETRY_IMPORT_TOKEN_DELAY: 'starting'\n              }\n            },\n            signedOut: {\n              initial: 'noErrors',\n              entry: 'reportSignedOut',\n              states: {\n                noErrors: {},\n                success: {},\n                needsSmsOtp: {},\n                needsMfa: {},\n                failed: {},\n                signingOut: {\n                  entry: ['clearContextExceptTokens'],\n                  exit: ['destroyAccessToken', 'destroyRefreshToken', 'reportTokenChanged'],\n                  invoke: {\n                    src: 'signout',\n                    id: 'signingOut',\n                    onDone: {\n                      target: 'success'\n                    },\n                    onError: {\n                      target: 'failed',\n                      actions: ['saveAuthenticationError']\n                    }\n                  }\n                }\n              },\n              on: {\n                SIGNIN_PASSWORD: 'authenticating.password',\n                SIGNIN_ANONYMOUS: 'authenticating.anonymous',\n                SIGNIN_SECURITY_KEY_EMAIL: 'authenticating.securityKeyEmail',\n                SIGNIN_SECURITY_KEY: 'authenticating.securityKey',\n                SIGNIN_MFA_TOTP: 'authenticating.mfa.totp',\n                SIGNIN_PAT: 'authenticating.pat',\n                SIGNIN_ID_TOKEN: 'authenticating.idToken'\n              }\n            },\n            authenticating: {\n              entry: 'resetErrors',\n              states: {\n                password: {\n                  invoke: {\n                    src: 'signInPassword',\n                    id: 'authenticateUserWithPassword',\n                    onDone: [\n                      {\n                        cond: 'hasMfaTicket',\n                        actions: ['saveMfaTicket'],\n                        target: '#nhost.authentication.signedOut.needsMfa'\n                      },\n                      {\n                        actions: ['saveSession', 'reportTokenChanged'],\n                        target: '#nhost.authentication.signedIn'\n                      }\n                    ],\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                },\n                pat: {\n                  invoke: {\n                    src: 'signInPAT',\n                    id: 'authenticateWithPAT',\n                    onDone: {\n                      actions: ['savePATSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                idToken: {\n                  invoke: {\n                    src: 'signInIdToken',\n                    id: 'authenticateWithIdToken',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                anonymous: {\n                  invoke: {\n                    src: 'signInAnonymous',\n                    id: 'authenticateAnonymously',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                mfa: {\n                  states: {\n                    totp: {\n                      invoke: {\n                        src: 'signInMfaTotp',\n                        id: 'signInMfaTotp',\n                        onDone: {\n                          actions: ['saveSession', 'reportTokenChanged'],\n                          target: '#nhost.authentication.signedIn'\n                        },\n                        onError: {\n                          actions: ['saveAuthenticationError'],\n                          target: '#nhost.authentication.signedOut.failed'\n                        }\n                      }\n                    }\n                  }\n                },\n                securityKeyEmail: {\n                  invoke: {\n                    src: 'signInSecurityKeyEmail',\n                    id: 'authenticateUserWithSecurityKey',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                },\n                securityKey: {\n                  invoke: {\n                    src: 'signInSecurityKey',\n                    id: 'authenticateUserWithSecurityKey',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                }\n              }\n            },\n            signedIn: {\n              type: 'parallel',\n              entry: ['reportSignedIn', 'cleanUrl', 'broadcastToken', 'resetErrors'],\n              on: {\n                SIGNOUT: 'signedOut.signingOut'\n              },\n              states: {\n                refreshTimer: {\n                  id: 'timer',\n                  initial: 'idle',\n                  states: {\n                    disabled: { type: 'final' },\n                    stopped: {\n                      always: {\n                        cond: 'noToken',\n                        target: 'idle'\n                      }\n                    },\n                    idle: {\n                      always: [\n                        { cond: 'isAutoRefreshDisabled', target: 'disabled' },\n                        { cond: 'isRefreshTokenPAT', target: 'disabled' },\n                        { cond: 'hasRefreshToken', target: 'running' }\n                      ]\n                    },\n                    running: {\n                      initial: 'pending',\n                      entry: 'resetTimer',\n                      states: {\n                        pending: {\n                          after: {\n                            '1000': {\n                              internal: false,\n                              target: 'pending'\n                            }\n                          },\n                          always: {\n                            cond: 'refreshTimerShouldRefresh',\n                            target: 'refreshing'\n                          }\n                        },\n                        refreshing: {\n                          invoke: {\n                            src: 'refreshToken',\n                            id: 'refreshToken',\n                            onDone: {\n                              actions: [\n                                'saveSession',\n                                'resetTimer',\n                                'reportTokenChanged',\n                                'broadcastToken'\n                              ],\n                              target: 'pending'\n                            },\n                            onError: [\n                              {\n                                cond: 'isUnauthorizedError',\n                                target: '#nhost.authentication.signedOut'\n                              },\n                              { actions: 'saveRefreshAttempt', target: 'pending' }\n                            ]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        token: {\n          initial: 'idle',\n          states: {\n            idle: {\n              on: {\n                TRY_TOKEN: 'running'\n              },\n              initial: 'noErrors',\n              states: { noErrors: {}, error: {} }\n            },\n            running: {\n              invoke: {\n                src: 'refreshToken',\n                id: 'authenticateWithToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged', 'broadcastToken'],\n                  target: ['#nhost.authentication.signedIn', 'idle.noErrors']\n                },\n                onError: [\n                  { cond: 'isSignedIn', target: 'idle.error' },\n                  {\n                    actions: 'saveAuthenticationError',\n                    target: ['#nhost.authentication.signedOut.failed', 'idle.error']\n                  }\n                ]\n              }\n            }\n          }\n        },\n        registration: {\n          initial: 'incomplete',\n          on: {\n            SIGNED_IN: [{ cond: 'isAnonymous', target: '.incomplete' }, '.complete']\n          },\n          states: {\n            incomplete: {\n              on: {\n                SIGNUP_EMAIL_PASSWORD: 'emailPassword',\n                SIGNUP_SECURITY_KEY: 'securityKey',\n                PASSWORDLESS_EMAIL: 'passwordlessEmail',\n                PASSWORDLESS_SMS: 'passwordlessSms',\n                PASSWORDLESS_SMS_OTP: 'passwordlessSmsOtp',\n                SIGNIN_EMAIL_OTP: 'signInEmailOTP',\n                VERIFY_EMAIL_OTP: 'verifyEmailOTP'\n              },\n              initial: 'noErrors',\n              states: {\n                noErrors: {},\n                needsEmailVerification: {},\n                needsOtp: {},\n                failed: {}\n              }\n            },\n            emailPassword: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpEmailPassword',\n                id: 'signUpEmailPassword',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            securityKey: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpSecurityKey',\n                id: 'signUpSecurityKey',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            passwordlessEmail: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessEmail',\n                id: 'passwordlessEmail',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSms: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSms',\n                id: 'passwordlessSms',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsOtp']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSmsOtp: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSmsOtp',\n                id: 'passwordlessSmsOtp',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: '#nhost.authentication.signedIn'\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            signInEmailOTP: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signInEmailOTP',\n                id: 'signInEmailOTP',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsOtp']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            verifyEmailOTP: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'verifyEmailOTP',\n                id: 'verifyEmailOTP',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: '#nhost.authentication.signedIn'\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            complete: {\n              on: {\n                SIGNED_OUT: 'incomplete'\n              }\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        reportSignedIn: send('SIGNED_IN'),\n        reportSignedOut: send('SIGNED_OUT'),\n        reportTokenChanged: send('TOKEN_CHANGED'),\n        incrementTokenImportAttempts: assign({\n          importTokenAttempts: ({ importTokenAttempts }) => importTokenAttempts + 1\n        }),\n        clearContext: assign(() => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT\n          }\n        }),\n        clearContextExceptTokens: assign(({ accessToken, refreshToken }) => {\n          return {\n            ...INITIAL_MACHINE_CONTEXT,\n            accessToken: accessToken,\n            refreshToken: refreshToken\n          }\n        }),\n\n        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine\n        saveSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh,\n                expiresInSeconds: accessTokenExpiresIn\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            const refreshTokenId = data.session?.refreshTokenId || null\n\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n\n            if (refreshTokenId) {\n              storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, refreshTokenId)\n            }\n\n            return { value: refreshToken }\n          }\n        }),\n\n        savePATSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh,\n                expiresInSeconds: accessTokenExpiresIn\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            const refreshTokenId = data.session?.refreshTokenId || null\n\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n\n            if (refreshTokenId) {\n              storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, refreshTokenId)\n            }\n\n            return { value: refreshToken, isPAT: true }\n          }\n        }),\n\n        saveMfaTicket: assign({\n          mfa: (_, e) => e.data?.mfa\n        }),\n\n        resetTimer: assign({\n          refreshTimer: (_) => ({\n            startedAt: new Date(),\n            attempts: 0,\n            lastAttempt: null\n          })\n        }),\n\n        saveRefreshAttempt: assign({\n          refreshTimer: (ctx, e) => ({\n            startedAt: ctx.refreshTimer.startedAt,\n            attempts: ctx.refreshTimer.attempts + 1,\n            lastAttempt: new Date()\n          })\n        }),\n\n        // * Authentication errors\n        saveAuthenticationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({\n            ...errors,\n            authentication: error\n          })\n        }),\n        resetErrors: assign({\n          errors: (_) => ({}),\n          importTokenAttempts: (_) => 0\n        }),\n        saveRegistrationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({ ...errors, registration: error })\n        }),\n        destroyRefreshToken: assign({\n          refreshToken: (_) => {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n            storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, null)\n            return { value: null }\n          }\n        }),\n\n        destroyAccessToken: assign({\n          accessToken: (_) => {\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            }\n          }\n        }),\n\n        // * Clean the browser url when `autoSignIn` is activated\n        cleanUrl: () => {\n          if (autoSignIn && getParameterByName('refreshToken')) {\n            // * Remove the refresh token from the URL\n            removeParameterFromWindow('refreshToken')\n            removeParameterFromWindow('type')\n          }\n        },\n\n        // * Broadcast the session to other tabs when `autoSignIn` is activated\n        broadcastToken: (context) => {\n          if (autoSignIn && broadcastKey && sharedBroadcastChannel) {\n            try {\n              // console.debug('[AUTH] Broadcasting new token to other tabs:', context.refreshToken.value ? context.refreshToken.value.substring(0, 6) + '...' : 'null')\n              sharedBroadcastChannel.postMessage({\n                type: 'broadcast_session',\n                payload: {\n                  token: context.refreshToken.value,\n                  accessToken: context.accessToken.value,\n                  user: context.user,\n                  expiresAt: context.accessToken.expiresAt\n                    ? context.accessToken.expiresAt.toISOString()\n                    : null,\n                  expiresInSeconds: context.accessToken.expiresInSeconds\n                }\n              })\n            } catch (error) {\n              // * BroadcastChannel is not available e.g. react-native\n            }\n          }\n        }\n      },\n\n      guards: {\n        isAnonymous: (ctx, e) => !!ctx.user?.isAnonymous,\n        isSignedIn: (ctx) => !!ctx.user && !!ctx.accessToken.value,\n        noToken: (ctx) => !ctx.refreshToken.value,\n        isRefreshTokenPAT: (ctx) => !!ctx.refreshToken?.isPAT,\n        hasRefreshToken: (ctx) => !!ctx.refreshToken.value,\n        isAutoRefreshDisabled: () => !autoRefreshToken,\n        refreshTimerShouldRefresh: (ctx) => {\n          const { expiresAt } = ctx.accessToken\n\n          if (!expiresAt) {\n            return false\n          }\n\n          if (ctx.refreshTimer.lastAttempt) {\n            // * If the refresh timer reached the maximum number of attempts, we should not try again\n            if (ctx.refreshTimer.attempts > REFRESH_TOKEN_MAX_ATTEMPTS) {\n              return false\n            }\n            const elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime()\n            // * Exponential backoff\n            return elapsed > Math.pow(2, ctx.refreshTimer.attempts - 1) * 5_000\n          }\n\n          // This happens when either the computer goes to sleep or when Chrome decides to suspend the tab\n          if (expiresAt.getTime() < Date.now()) {\n            return true\n          }\n\n          if (refreshIntervalTime) {\n            // * If a refreshIntervalTime has been passed on as an option, it will notify\n            // * the token should be refreshed when this interval is overdue\n            const elapsed = Date.now() - ctx.refreshTimer.startedAt!.getTime()\n            if (elapsed > refreshIntervalTime * 1_000) {\n              return true\n            }\n          }\n          // * In any case, it's time to refresh when there's less than\n          // * TOKEN_REFRESH_MARGIN_SECONDS seconds before the JWT expires\n          const accessTokenExpirationTime = ctx.accessToken.expiresInSeconds\n\n          if (!accessTokenExpirationTime) {\n            return false\n          }\n\n          const expiresInMilliseconds = expiresAt.getTime() - Date.now()\n\n          return (\n            expiresInMilliseconds <= (TOKEN_REFRESH_MARGIN_SECONDS * 1000) / 2 ||\n            (expiresInMilliseconds <= TOKEN_REFRESH_MARGIN_SECONDS * 1000 && Math.random() < 0.1)\n          )\n        },\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        /** Should retry to import the token on network error or any internal server error.\n         * Don't retry more than REFRESH_TOKEN_MAX_ATTEMPTS times.\n         */\n        shouldRetryImportToken: (ctx, e: any) =>\n          ctx.importTokenAttempts < REFRESH_TOKEN_MAX_ATTEMPTS &&\n          (e.data.error.status === NETWORK_ERROR_CODE || e.data.error.status >= 500),\n        // * Authentication errors\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        unverified: (_, { data: { error } }: any) =>\n          error.status === 401 &&\n          // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)\n          (error.message === 'Email is not verified' || error.error === 'unverified-user'),\n\n        // * Event guards\n        hasSession: (_, e) => !!e.data?.session,\n        hasMfaTicket: (_, e) => !!e.data?.mfa,\n        isUnauthorizedError: (_, { data: { error } }: any) => error.status === 401\n      },\n\n      services: {\n        signInPassword: (_, { email, password }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject({ error: INVALID_PASSWORD_ERROR })\n          }\n          return postRequest<SignInResponse>('/signin/email-password', {\n            email,\n            password\n          })\n        },\n        signInPAT: (_context, { pat }) => {\n          return postRequest<SignInPATResponse>('/signin/pat', {\n            personalAccessToken: pat\n          })\n        },\n        signInIdToken: (_context, { provider, idToken, nonce }) => {\n          return postRequest<SignInResponse>('/signin/idtoken', {\n            provider,\n            idToken,\n            ...(nonce && { nonce })\n          })\n        },\n        passwordlessSms: (context, { phoneNumber, options }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            // TODO implement in hasura-auth\n            // * See https://github.com/nhost/hasura-auth/blob/9c6d0f4ded4fc8fd1b8031926c02796c74a7eada/src/routes/user/deanonymize.ts\n            console.warn(\n              'Deanonymisation from a phone number is not yet implemented in hasura-auth'\n            )\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'sms',\n                phoneNumber,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest('/signin/passwordless/sms', {\n              phoneNumber,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        passwordlessSmsOtp: (_, { phoneNumber, otp }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          return postRequest('/signin/passwordless/sms/otp', {\n            phoneNumber,\n            otp\n          })\n        },\n        signInEmailOTP: (_, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n\n          return postRequest('/signin/otp/email', {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          })\n        },\n        verifyEmailOTP: (_, { email, otp }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n\n          return postRequest('/signin/otp/email/verify', {\n            email,\n            otp\n          })\n        },\n        passwordlessEmail: (context, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'email',\n                email,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest('/signin/passwordless/email', {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signInAnonymous: (_) => postRequest('/signin/anonymous'),\n        signInMfaTotp: (context, data) => {\n          const ticket: string | undefined = data.ticket || context.mfa?.ticket\n          if (!ticket) {\n            return Promise.reject({ error: NO_MFA_TICKET_ERROR })\n          }\n          if (!isValidTicket(ticket)) {\n            return Promise.reject({ error: INVALID_MFA_TICKET_ERROR })\n          }\n\n          return postRequest('/signin/mfa/totp', {\n            ticket,\n            otp: data.otp\n          })\n        },\n        signInSecurityKeyEmail: async (_, { email }) => {\n          if (!isValidEmail(email)) {\n            throw new CodifiedError(INVALID_EMAIL_ERROR)\n          }\n          const options = await postRequest<PublicKeyCredentialRequestOptionsJSON>(\n            '/signin/webauthn',\n            { email }\n          )\n          let credential: AuthenticationCredentialJSON\n          try {\n            credential = await startAuthentication(options)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignInResponse>('/signin/webauthn/verify', { email, credential })\n        },\n        refreshToken: async (ctx, event) => {\n          const refreshToken = event.type === 'TRY_TOKEN' ? event.token : ctx.refreshToken.value\n          // console.debug('[AUTH] Refreshing token with:', refreshToken ? refreshToken.substring(0, 6) + '...' : 'null')\n          const session: NhostSession = await postRequest<RefreshSessionResponse>('/token', {\n            refreshToken\n          })\n          // console.debug('[AUTH] Token refreshed successfully:', session.refreshToken ? session.refreshToken.substring(0, 6) + '...' : 'null')\n          return { session, error: null }\n        },\n        signInSecurityKey: async (): Promise<SignInResponse> => {\n          try {\n            const options: PublicKeyCredentialRequestOptionsJSON = await postRequest(\n              '/signin/webauthn',\n              {}\n            )\n\n            let credential: AuthenticationCredentialJSON\n            try {\n              credential = await startAuthentication(options)\n            } catch (e) {\n              throw new CodifiedError(e as Error)\n            }\n            return postRequest<SignInResponse>('/signin/webauthn/verify', { credential })\n          } catch (error) {\n            throw new CodifiedError(error as Error)\n          }\n        },\n        signout: async (ctx, e) => {\n          const signOutResponse = await postRequest(\n            '/signout',\n            {\n              refreshToken: ctx.refreshToken.value,\n              all: !!e.all\n            },\n            !!e.all ? ctx.accessToken.value : undefined\n          )\n\n          if (broadcastKey && sharedBroadcastChannel) {\n            try {\n              // ? broadcast the signout event to other tabs to remove the accessToken\n              sharedBroadcastChannel.postMessage({ type: 'signout' })\n            } catch (error) {\n              // * BroadcastChannel is not available e.g. react-native\n            }\n          }\n\n          return signOutResponse\n        },\n        signUpEmailPassword: async (context, { email, password, options, requestOptions }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_PASSWORD_ERROR })\n          }\n\n          if (context.user?.isAnonymous) {\n            return postRequest<SignUpResponse>(\n              '/user/deanonymize',\n              {\n                signInMethod: 'email-password',\n                email,\n                password,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value,\n              requestOptions?.headers\n            )\n          } else {\n            return postRequest<SignUpResponse>(\n              '/signup/email-password',\n              {\n                email,\n                password,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              null,\n              requestOptions?.headers\n            )\n          }\n        },\n        signUpSecurityKey: async (_, { email, options, requestOptions }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          // TODO anonymous users\n          const nickname = options?.nickname\n          /*\n           * The `/signup/webauthn` endpoint accepts any option from SignUpOptions,\n           * We therefore remove the nickname from the options object before sending it to the server,\n           * as options if of type `SignUpSecurityKeyOptions`, which extends `SignUpOptions` with the optional `nickname` property.\n           */\n          if (nickname) delete options.nickname\n          const webAuthnOptions = await postRequest<PublicKeyCredentialCreationOptionsJSON>(\n            '/signup/webauthn',\n            { email, options },\n            null,\n            requestOptions?.headers\n          )\n          let credential: RegistrationCredentialJSON\n          try {\n            credential = await startRegistration(webAuthnOptions)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignUpResponse>('/signup/webauthn/verify', {\n            credential,\n            options: {\n              redirectTo: options?.redirectTo,\n              nickname,\n              displayName: options?.displayName,\n              ...(options?.metadata && { metadata: options?.metadata })\n            }\n          })\n        },\n        importRefreshToken: async (ctx) => {\n          if (\n            ctx.user &&\n            ctx.refreshToken.value &&\n            ctx.accessToken.value &&\n            ctx.accessToken.expiresAt\n          ) {\n            // * Do not import refresh token if the session already exists (loaded through initial state)\n            // TODO this should eventually be handled upstream in the state machine\n            return {\n              session: {\n                accessToken: ctx.accessToken.value,\n                accessTokenExpiresIn: ctx.accessToken.expiresAt.getTime() - Date.now(),\n                refreshToken: ctx.refreshToken.value,\n                user: ctx.user\n              },\n              error: null\n            }\n          }\n          let error: AuthErrorPayload | null = null\n          if (autoSignIn) {\n            const urlToken = getParameterByName('refreshToken') || null\n            if (urlToken) {\n              try {\n                const session = await postRequest<NhostSession>('/token', {\n                  refreshToken: urlToken\n                })\n                return { session, error: null }\n              } catch (exception) {\n                error = (exception as { error: AuthErrorPayload }).error\n              }\n            } else {\n              const error = getParameterByName('error')\n              const errorDescription = getParameterByName('errorDescription')\n\n              if (error) {\n                if (errorDescription !== 'social user already exists') {\n                  return Promise.reject<NhostSessionResponse>({\n                    session: null,\n                    error: {\n                      status: VALIDATION_ERROR_CODE,\n                      error,\n                      message: errorDescription || error\n                    }\n                  })\n                }\n              }\n            }\n          }\n          const storageToken = await storageGetter(NHOST_REFRESH_TOKEN_KEY)\n          if (storageToken) {\n            try {\n              const session = await postRequest<NhostSession>('/token', {\n                refreshToken: storageToken\n              })\n              return { session, error: null }\n            } catch (exception) {\n              error = (exception as { error: AuthErrorPayload }).error\n            }\n          }\n          if (error) {\n            return Promise.reject<NhostSessionResponse>({ error, session: null })\n          }\n          return { error: null, session: null }\n        }\n      },\n      delays: {\n        RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts }) => {\n          // * Exponential backoff\n          return Math.pow(2, importTokenAttempts - 1) * 5_000\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ChangeEmailOptions, ChangeEmailResponse } from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type ChangeEmailContext = {\n  error: AuthErrorPayload | null\n}\n\nexport type ChangeEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ChangeEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ChangeEmailServices = {\n  request: { data: ChangeEmailResponse }\n}\n\nexport type ChangeEmailMachine = ReturnType<typeof createChangeEmailMachine>\n\nexport const createChangeEmailMachine = ({ backendUrl, clientUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangeEmailContext,\n        events: {} as ChangeEmailEvents,\n        services: {} as ChangeEmailServices\n      },\n      tsTypes: {} as import('./change-email.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changeEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        // TODO change email in the main machine (context.user.email)\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: async (_, { email, options }) => {\n          const res = await postFetch(\n            `${backendUrl}/user/email/change`,\n            { newEmail: email, options: rewriteRedirectTo(clientUrl, options) },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_PASSWORD_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ChangePasswordResponse } from '../types'\nimport { postFetch } from '../utils'\nimport { isValidPassword } from '../utils/validators'\n\nexport type ChangePasswordContext = {\n  error: AuthErrorPayload | null\n}\nexport type ChangePasswordEvents =\n  | {\n      type: 'REQUEST'\n      password?: string\n      ticket?: string\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ChangePasswordServices = {\n  requestChange: { data: ChangePasswordResponse }\n}\n\nexport type ChangePasswordMachine = ReturnType<typeof createChangePasswordMachine>\n\nexport const createChangePasswordMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangePasswordContext,\n        events: {} as ChangePasswordEvents,\n        services: {} as ChangePasswordServices\n      },\n      tsTypes: {} as import('./change-password.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidPassword',\n                actions: 'saveInvalidPasswordError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidPasswordError: assign({ error: (_) => INVALID_PASSWORD_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidPassword: (_, { password }) => !isValidPassword(password)\n      },\n      services: {\n        requestChange: (_, { password, ticket }) =>\n          postFetch<ChangePasswordResponse>(\n            `${backendUrl}/user/password`,\n            { newPassword: password, ticket: ticket },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_MFA_CODE_ERROR, INVALID_MFA_TYPE_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload } from '../types'\nimport { getFetch, postFetch } from '../utils'\n\nexport type EnableMfaContext = {\n  error: AuthErrorPayload | null\n  imageUrl: string | null\n  secret: string | null\n}\n\nexport type EnableMfaEvents =\n  | {\n      type: 'GENERATE'\n    }\n  | {\n      type: 'ACTIVATE'\n      code?: string\n      activeMfaType: 'totp'\n    }\n  | { type: 'DISABLE'; code: string }\n  | { type: 'GENERATED' }\n  | { type: 'GENERATED_ERROR'; error: AuthErrorPayload | null }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type EnableMfadMachine = ReturnType<typeof createEnableMfaMachine>\n\nexport const createEnableMfaMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as EnableMfaContext,\n        events: {} as EnableMfaEvents\n      },\n      tsTypes: {} as import('./enable-mfa.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'enableMfa',\n      initial: 'idle',\n      context: { error: null, imageUrl: null, secret: null },\n      states: {\n        idle: {\n          initial: 'initial',\n          on: {\n            GENERATE: 'generating',\n            DISABLE: 'disabling'\n          },\n          states: {\n            initial: {},\n            error: {},\n            disabled: {}\n          }\n        },\n        generating: {\n          invoke: {\n            src: 'generate',\n            id: 'generate',\n            onDone: { target: 'generated', actions: ['reportGeneratedSuccess', 'saveGeneration'] },\n            onError: { actions: ['saveError', 'reportGeneratedError'], target: 'idle.error' }\n          }\n        },\n        generated: {\n          initial: 'idle',\n          states: {\n            idle: {\n              initial: 'idle',\n              on: {\n                ACTIVATE: [\n                  {\n                    cond: 'invalidMfaType',\n                    actions: 'saveInvalidMfaTypeError',\n                    target: '.error'\n                  },\n                  {\n                    cond: 'invalidMfaCode',\n                    actions: 'saveInvalidMfaCodeError',\n                    target: '.error'\n                  },\n                  {\n                    target: 'activating'\n                  }\n                ],\n                DISABLE: '#enableMfa.disabling'\n              },\n              states: { idle: {}, error: {} }\n            },\n            activating: {\n              invoke: {\n                src: 'activate',\n                id: 'activate',\n                onDone: { target: 'activated', actions: 'reportSuccess' },\n                onError: { actions: ['saveError', 'reportError'], target: 'idle.error' }\n              }\n            },\n            activated: { type: 'final' }\n          }\n        },\n        disabling: {\n          invoke: {\n            src: 'disable',\n            id: 'disable',\n            onDone: { target: 'idle.disabled', actions: 'reportSuccess' },\n            onError: { actions: ['saveError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidMfaTypeError: assign({ error: (_) => INVALID_MFA_TYPE_ERROR }),\n        saveInvalidMfaCodeError: assign({ error: (_) => INVALID_MFA_CODE_ERROR }),\n        saveError: assign({\n          error: (_, { data: { error } }: any) => error\n        }),\n        saveGeneration: assign({\n          imageUrl: (_, { data: { imageUrl } }: any) => imageUrl,\n          secret: (_, { data: { totpSecret } }: any) => totpSecret\n        }),\n        reportError: send((ctx, event) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS'),\n        reportGeneratedSuccess: send('GENERATED'),\n        reportGeneratedError: send((ctx) => ({ type: 'GENERATED_ERROR', error: ctx.error }))\n      },\n      guards: {\n        invalidMfaCode: (_, { code }) => !code,\n        invalidMfaType: (_, { activeMfaType }) => !activeMfaType || activeMfaType !== 'totp'\n      },\n      services: {\n        generate: async (_) => {\n          const { data } = await getFetch(\n            `${backendUrl}/mfa/totp/generate`,\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n          return data\n        },\n        activate: (_, { code, activeMfaType }) =>\n          postFetch(\n            `${backendUrl}/user/mfa`,\n            { code, activeMfaType },\n            interpreter?.getSnapshot().context.accessToken.value\n          ),\n        disable: (_, { code }) =>\n          postFetch(\n            `${backendUrl}/user/mfa`,\n            { code, activeMfaType: '' },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ResetPasswordOptions, ResetPasswordResponse } from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type ResetPasswordContext = {\n  error: AuthErrorPayload | null\n}\nexport type ResetPasswordEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ResetPasswordOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ResetPasswordServices = {\n  requestChange: { data: ResetPasswordResponse }\n}\n\nexport type ResetPasswordMachine = ReturnType<typeof createResetPasswordMachine>\n\nexport const createResetPasswordMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ResetPasswordContext,\n        events: {} as ResetPasswordEvents,\n        services: {} as ResetPasswordServices\n      },\n      tsTypes: {} as import('./reset-password.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: (_, { email, options }) =>\n          postFetch<ResetPasswordResponse>(`${backendUrl}/user/password/reset`, {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          })\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport {\n  AuthErrorPayload,\n  SendVerificationEmailOptions,\n  SendVerificationEmailResponse\n} from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type SendVerificationEmailContext = {\n  error: AuthErrorPayload | null\n}\n\nexport type SendVerificationEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: SendVerificationEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type SendVerificationEmailServices = {\n  request: { data: SendVerificationEmailResponse }\n}\n\nexport type SendVerificationEmailMachine = ReturnType<typeof createSendVerificationEmailMachine>\nexport const createSendVerificationEmailMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as SendVerificationEmailContext,\n        events: {} as SendVerificationEmailEvents,\n        services: {} as SendVerificationEmailServices\n      },\n      tsTypes: {} as import('./send-verification-email.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'sendVerificationEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'request',\n            id: 'request',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        request: async (_, { email, options }) => {\n          const res = await postFetch<SendVerificationEmailResponse>(\n            `${backendUrl}/user/email/send-verification-email`,\n            { email, options: rewriteRedirectTo(clientUrl, options) }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { interpret } from 'xstate'\nimport {\n  AuthContext,\n  AuthInterpreter,\n  AuthMachine,\n  AuthMachineOptions,\n  createAuthMachine\n} from './machines'\nimport { NhostSession } from './types'\nimport { isBrowser } from './utils'\n\nexport type NhostClientOptions = AuthMachineOptions & {\n  /** @internal create and start xstate interpreter on creation. With React, it is started inside the Nhost provider */\n  start?: boolean\n}\n\n/**\n * @internal\n * This is a private API.\n */\nexport class AuthClient {\n  readonly backendUrl: string\n  readonly clientUrl: string\n  private _machine: AuthMachine\n  private _interpreter?: AuthInterpreter\n  private _started = false\n  private _channel?: BroadcastChannel\n  private _subscriptionsQueue: Set<(client: AuthClient) => void> = new Set()\n  private _subscriptions: Set<() => void> = new Set()\n\n  constructor({\n    clientStorageType = 'web',\n    autoSignIn = true,\n    autoRefreshToken = true,\n    start = true,\n    backendUrl,\n    clientUrl,\n    broadcastKey,\n    devTools,\n    ...defaultOptions\n  }: NhostClientOptions) {\n    this.backendUrl = backendUrl\n    this.clientUrl = clientUrl\n\n    this._machine = createAuthMachine({\n      ...defaultOptions,\n      backendUrl,\n      clientUrl,\n      broadcastKey,\n      clientStorageType,\n      autoSignIn,\n      autoRefreshToken\n    })\n\n    if (start) {\n      this.start({ devTools })\n    }\n\n    if (typeof window !== 'undefined' && broadcastKey) {\n      try {\n        this._channel = new BroadcastChannel(broadcastKey)\n\n        if (autoSignIn) {\n          this._channel?.addEventListener('message', (event) => {\n            const { type, payload } = event.data\n\n            if (type === 'broadcast_session') {\n              const context = this.interpreter?.getSnapshot().context\n              const existingToken = context?.refreshToken.value\n\n              // console.debug('[AUTH] Received broadcast session:', payload.token?.substring(0,6), existingToken?.substring(0,6))\n\n              // Only update if this is a new token or if we don't have a token yet\n              if (this.interpreter && payload.token && payload.token !== existingToken) {\n                // console.debug('[AUTH] Received broadcast with new token:', payload.token ? payload.token.substring(0, 6) + '...' : 'null',\n                //   'Previous token:', existingToken ? existingToken.substring(0, 6) + '...' : 'null')\n                // Send a SESSION_UPDATE event with the full session data instead of making a token call\n                this.interpreter.send('SESSION_UPDATE', {\n                  data: {\n                    session: {\n                      user: payload.user,\n                      accessToken: payload.accessToken,\n                      refreshToken: payload.token,\n                      accessTokenExpiresIn: payload.expiresInSeconds\n                    }\n                  }\n                })\n              }\n            }\n          })\n        }\n\n        this._channel.addEventListener('message', (event) => {\n          const { type } = event.data\n\n          if (type === 'signout') {\n            if (this.interpreter) {\n              this.interpreter.send('SIGNOUT')\n            }\n          }\n        })\n      } catch (error) {\n        // * BroadcastChannel is not available e.g. react-native\n      }\n    }\n  }\n\n  start({\n    devTools = false,\n    initialSession,\n    interpreter\n  }: { interpreter?: AuthInterpreter; initialSession?: NhostSession; devTools?: boolean } = {}) {\n    // Create a deep copy of the machine context to ensure that nested objects (such as accessToken and refreshToken) are not mutated in the original context.\n    const context: AuthContext = {\n      ...this.machine.context,\n      accessToken: {\n        ...this.machine.context.accessToken\n      },\n      refreshToken: {\n        ...this.machine.context.refreshToken\n      }\n    }\n\n    if (initialSession) {\n      context.user = initialSession.user\n      context.refreshToken.value = initialSession.refreshToken ?? null\n      context.accessToken.value = initialSession.accessToken ?? null\n      context.accessToken.expiresAt = new Date(\n        Date.now() + initialSession.accessTokenExpiresIn * 1_000\n      )\n    }\n    const machineWithInitialContext = this.machine.withContext(context)\n\n    if (!this._interpreter) {\n      this._interpreter = interpreter || interpret(machineWithInitialContext, { devTools })\n    }\n\n    // * Start the interpreter if not started already. Always restart the interpreter when on the server side\n    if (!this._started || typeof window === 'undefined') {\n      if (this._interpreter.initialized) {\n        this._interpreter.stop()\n        this._subscriptions.forEach((fn) => fn())\n      }\n      this._interpreter.start(machineWithInitialContext.initialState)\n      this._subscriptionsQueue.forEach((fn) => fn(this))\n    }\n\n    this._started = true\n  }\n\n  public get machine() {\n    return this._machine\n  }\n\n  get interpreter(): AuthInterpreter | undefined {\n    return this._interpreter\n  }\n\n  get started(): boolean {\n    return this._started\n  }\n\n  subscribe(fn: (client: AuthClient) => () => void): () => void {\n    if (this.started) {\n      // * The interpreter is already available: we can add the listener straight ahead\n      const subscription = fn(this)\n      this._subscriptions.add(subscription)\n      return subscription\n    } else {\n      // * The interpreter is not yet available: we add the listener to a queue that will be started when setting the interpreter\n      // * Note: in React, the Xstate interpreter does not start from the global state, but from the root component\n      this._subscriptionsQueue.add(fn)\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n}\n\n/** @deprecated Not in use anymore. Use `clientStorageType: 'cookie'` instead */\nexport class AuthCookieClient extends AuthClient {\n  constructor({\n    ...options\n  }: Omit<\n    NhostClientOptions,\n    'clientStorageGetter' | 'clientStorageSetter' | 'clientStorage' | 'clientStorageType'\n  >) {\n    super({\n      ...options,\n      autoSignIn: isBrowser() && options.autoSignIn,\n      autoRefreshToken: isBrowser() && options.autoRefreshToken,\n      clientStorageType: 'cookie'\n    })\n  }\n}\n\n/** @deprecated Alias for {@link AuthCookieClient} */\nexport const AuthClientSSR = AuthCookieClient\n","import { startRegistration } from '@simplewebauthn/browser'\nimport {\n  PublicKeyCredentialCreationOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\nimport { postFetch } from '..'\nimport { CodifiedError } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, SecurityKey } from '../types'\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface AddSecurityKeyHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  key?: SecurityKey\n}\n\nexport interface AddSecurityKeyState extends AddSecurityKeyHandlerResult, AuthActionLoadingState {}\n\nexport const addSecurityKeyPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  nickname?: string\n): Promise<AddSecurityKeyHandlerResult> => {\n  try {\n    const { data: options } = await postFetch<PublicKeyCredentialCreationOptionsJSON>(\n      `${backendUrl}/user/webauthn/add`,\n      {},\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n    let credential: RegistrationCredentialJSON\n    try {\n      credential = await startRegistration(options)\n    } catch (e) {\n      throw new CodifiedError(e as Error)\n    }\n    const { data: key } = await postFetch<SecurityKey>(\n      `${backendUrl}/user/webauthn/verify`,\n      { credential, nickname },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n    return { key, isError: false, error: null, isSuccess: true }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false }\n  }\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangeEmailMachine } from '../machines'\nimport { ChangeEmailOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, NeedsEmailVerificationState } from './types'\nexport interface ChangeEmailHandlerResult\n  extends AuthActionErrorState,\n    NeedsEmailVerificationState {}\n\nexport interface ChangeEmailState extends ChangeEmailHandlerResult, AuthActionLoadingState {}\n\nexport const changeEmailPromise = async (\n  interpreter: InterpreterFrom<ChangeEmailMachine>,\n  email: string,\n  options?: ChangeEmailOptions\n): Promise<ChangeEmailHandlerResult> =>\n  new Promise<ChangeEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((s) => {\n      if (s.matches({ idle: 'error' })) {\n        resolve({ error: s.context.error, isError: true, needsEmailVerification: false })\n      } else if (s.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, needsEmailVerification: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangePasswordMachine } from '../machines'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface ChangePasswordState extends ChangePasswordHandlerResult, AuthActionLoadingState {}\n\nexport interface ChangePasswordHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\n\nexport const changePasswordPromise = async (\n  interpreter: InterpreterFrom<ChangePasswordMachine>,\n  password: string,\n  ticket?: string\n): Promise<ChangePasswordHandlerResult> =>\n  new Promise<ChangePasswordHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      password,\n      ticket\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSuccess: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { EnableMfadMachine } from '../machines'\n\nimport { AuthActionErrorState } from './types'\n\nexport interface GenerateQrCodeHandlerResult extends AuthActionErrorState {\n  qrCodeDataUrl: string\n  isGenerated: boolean\n  totpSecret: string | null\n}\n\nexport interface GenerateQrCodeState extends GenerateQrCodeHandlerResult {\n  isGenerating: boolean\n}\n\nexport interface ActivateMfaHandlerResult extends AuthActionErrorState {\n  isActivated: boolean\n}\n\nexport interface DisableMfaHandlerResult extends AuthActionErrorState {\n  isDisabled: boolean\n}\n\nexport interface ActivateMfaState extends ActivateMfaHandlerResult {\n  isActivating: boolean\n}\n\nexport const generateQrCodePromise = (service: InterpreterFrom<EnableMfadMachine>) =>\n  new Promise<GenerateQrCodeHandlerResult>((resolve) => {\n    service.send('GENERATE')\n    service.onTransition((state) => {\n      if (state.matches('generated')) {\n        resolve({\n          error: null,\n          isError: false,\n          isGenerated: true,\n          qrCodeDataUrl: state.context.imageUrl || '',\n          totpSecret: state.context.secret\n        })\n      } else if (state.matches({ idle: 'error' })) {\n        resolve({\n          error: state.context.error || null,\n          isError: true,\n          isGenerated: false,\n          qrCodeDataUrl: '',\n          totpSecret: state.context.secret\n        })\n      }\n    })\n  })\n\nexport const activateMfaPromise = (service: InterpreterFrom<EnableMfadMachine>, code: string) =>\n  new Promise<ActivateMfaHandlerResult>((resolve) => {\n    service.send('ACTIVATE', {\n      activeMfaType: 'totp',\n      code\n    })\n    service.onTransition((state) => {\n      if (state.matches({ generated: 'activated' })) {\n        resolve({ error: null, isActivated: true, isError: false })\n      } else if (state.matches({ generated: { idle: 'error' } })) {\n        resolve({ error: state.context.error, isActivated: false, isError: true })\n      }\n    })\n  })\n\nexport const disableMfaPromise = (service: InterpreterFrom<EnableMfadMachine>, code: string) =>\n  new Promise<DisableMfaHandlerResult>((resolve) => {\n    service.send('DISABLE', { code })\n    service.onTransition((state) => {\n      if (state.matches({ idle: 'disabled' })) {\n        resolve({ error: null, isDisabled: true, isError: false })\n      } else if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isDisabled: false, isError: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ResetPasswordMachine } from '../machines'\nimport { ResetPasswordOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState } from './types'\n\nexport interface ResetPasswordHandlerResult extends AuthActionErrorState {\n  /** Returns `true` when an email to reset the password has been sent */\n  isSent: boolean\n}\n\nexport interface ResetPasswordState extends ResetPasswordHandlerResult, AuthActionLoadingState {}\n\nexport const resetPasswordPromise = async (\n  interpreter: InterpreterFrom<ResetPasswordMachine>,\n  email: string,\n  options?: ResetPasswordOptions\n): Promise<ResetPasswordHandlerResult> =>\n  new Promise((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { SendVerificationEmailMachine } from '../machines'\nimport { SendVerificationEmailOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState } from './types'\n\nexport interface SendVerificationEmailHandlerResult extends AuthActionErrorState {\n  /** Returns `true` when a new verification email has been sent */\n  isSent: boolean\n}\n\nexport interface SendVerificationEmailState\n  extends AuthActionLoadingState,\n    SendVerificationEmailHandlerResult {}\n\nexport const sendVerificationEmailPromise = (\n  interpreter: InterpreterFrom<SendVerificationEmailMachine>,\n  email: string,\n  options?: SendVerificationEmailOptions\n): Promise<SendVerificationEmailHandlerResult> =>\n  new Promise<SendVerificationEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInAnonymousHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInAnonymousState\n  extends SignInAnonymousHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInAnonymousPromise = (\n  interpreter: AuthInterpreter\n): Promise<SignInAnonymousHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_ANONYMOUS')\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          isSuccess: true,\n          isError: false,\n          error: null,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value\n        })\n      }\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          isSuccess: false,\n          isError: true,\n          error: state.context.errors.authentication || null,\n          user: null,\n          accessToken: null,\n          refreshToken: null\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {\n  needsMfaOtp: boolean\n  mfa: {\n    ticket: string\n  } | null\n}\n\nexport interface SignInEmailPasswordState\n  extends SignInEmailPasswordHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string\n) =>\n  new Promise<SignInEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_PASSWORD', {\n      email,\n      password\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'needsMfa' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: true,\n          mfa: state.context.mfa,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { PasswordlessOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\nexport interface SignInEmailPasswordlessHandlerResult\n  extends AuthActionErrorState,\n    AuthActionSuccessState {}\nexport interface SignInEmailPasswordlessState\n  extends SignInEmailPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInEmailPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_EMAIL', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInSecurityKeyPasswordlessHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignInSecurityKeyPasswordlessState\n  extends SignInSecurityKeyPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailSecurityKeyPromise = (interpreter: AuthInterpreter, email: string) =>\n  new Promise<SignInSecurityKeyPasswordlessHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send({ type: 'SIGNIN_SECURITY_KEY_EMAIL', email })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { PublicKeyCredentialRequestOptionsJSON } from '@simplewebauthn/typescript-types'\nimport {\n  AuthActionErrorState,\n  AuthActionSuccessState,\n  AuthClient,\n  AuthErrorPayload,\n  postFetch,\n  SignInResponse\n} from '..'\nimport { startAuthentication } from '@simplewebauthn/browser'\n\nexport interface ElevateWithSecurityKeyHandlerResult\n  extends AuthActionSuccessState,\n    AuthActionErrorState {\n  elevated: boolean\n}\n\nfunction createAuthErrorPayload(e: any) {\n  const error: AuthErrorPayload = {\n    error: e.message || 'Something went wrong!',\n    status: e.status || 1,\n    message: e.message || 'Something went wrong!'\n  }\n\n  return error\n}\n\nexport const elevateEmailSecurityKeyPromise = async (authClient: AuthClient, email: string) => {\n  const snapshot = authClient.interpreter?.getSnapshot()\n  const accessToken = snapshot?.context.accessToken.value\n\n  let data: PublicKeyCredentialRequestOptionsJSON\n  try {\n    const response = await postFetch<PublicKeyCredentialRequestOptionsJSON>(\n      `${authClient.backendUrl}/elevate/webauthn`,\n      {\n        email\n      },\n      accessToken\n    )\n    data = response.data\n  } catch (e: any) {\n    const error = createAuthErrorPayload(e)\n    return {\n      error,\n      isError: true,\n      isSuccess: false,\n      elevated: false\n    }\n  }\n\n  let credential\n  try {\n    credential = await startAuthentication(data)\n  } catch (e: any) {\n    const error = createAuthErrorPayload(e)\n    return {\n      error,\n      isError: true,\n      isSuccess: false,\n      elevated: false\n    }\n  }\n\n  try {\n    const {\n      data: { session },\n      error: signInError\n    } = await postFetch<SignInResponse>(\n      `${authClient.backendUrl}/elevate/webauthn/verify`,\n      {\n        email,\n        credential\n      },\n      accessToken\n    )\n\n    if (session && !signInError) {\n      authClient.interpreter?.send({\n        type: 'SESSION_UPDATE',\n        data: {\n          session\n        }\n      })\n\n      return {\n        error: null,\n        isError: false,\n        isSuccess: true,\n        elevated: true\n      }\n    }\n\n    return {\n      error: signInError!,\n      isError: true,\n      isSuccess: false,\n      elevated: false\n    }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n\n    return {\n      error,\n      isError: true,\n      isSuccess: false,\n      elevated: false\n    }\n  }\n}\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInMfaTotpHandlerResult extends SessionActionHandlerResult {}\n\nexport interface SignInMfaTotpState extends SignInMfaTotpHandlerResult, AuthActionLoadingState {}\n\nexport const signInMfaTotpPromise = (interpreter: AuthInterpreter, otp: string, ticket?: string) =>\n  new Promise<SignInMfaTotpHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_MFA_TOTP', {\n      otp,\n      ticket\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInPATHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInPATState extends SignInPATHandlerResult, AuthActionLoadingState {}\n\nexport const signInPATPromise = (\n  interpreter: AuthInterpreter,\n  pat: string\n): Promise<SignInPATHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_PAT', { pat })\n\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        return resolve({\n          accessToken: null,\n          refreshToken: null,\n          user: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false\n        })\n      }\n\n      if (state.matches({ authentication: 'signedIn' })) {\n        return resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          user: state.context.user,\n          error: null,\n          isError: false,\n          isSuccess: true\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { PasswordlessOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface SignInSmsPasswordlessState\n  extends SignInSmsPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport interface SignInSmsPasswordlessHandlerResult\n  extends AuthActionErrorState,\n    AuthActionSuccessState {\n  /**\n   * Returns true when the one-time password has been sent over by SMS, and the user needs to send it back to complete sign-in.\n   */\n  needsOtp: boolean\n}\n\nexport const signInSmsPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInSmsPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_SMS', { phoneNumber, options })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.needsOtp')) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsOtp: true\n        })\n      } else if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInSmsPasswordlessOtpHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInSmsPasswordlessOtpState\n  extends SignInSmsPasswordlessOtpHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInSmsPasswordlessOtpPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  otp: string\n) =>\n  new Promise<SignInSmsPasswordlessOtpHandlerResult>((resolve) => {\n    const { changed } = interpreter.send({ type: 'PASSWORDLESS_SMS_OTP', phoneNumber, otp })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value\n        })\n      } else if (state.matches({ registration: { incomplete: 'failed' } })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null,\n          refreshToken: null\n        })\n      }\n    })\n  })\n","import { USER_UNAUTHENTICATED } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface SignOutlessHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\nexport interface SignOutlessState extends SignOutlessHandlerResult, AuthActionLoadingState {}\n\nexport const signOutPromise = async (\n  interpreter: AuthInterpreter,\n  all?: boolean\n): Promise<SignOutlessHandlerResult> =>\n  new Promise<SignOutlessHandlerResult>((resolve) => {\n    const { event } = interpreter.send('SIGNOUT', { all })\n    if (event.type !== 'SIGNED_OUT') {\n      return resolve({ isSuccess: false, isError: true, error: USER_UNAUTHENTICATED })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'success' } })) {\n        resolve({ isSuccess: true, isError: false, error: null })\n      } else if (state.matches('authentication.signedOut.failed')) {\n        resolve({ isSuccess: false, isError: true, error: state.context.errors.signout || null })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { RequestOptions, SignUpOptions } from '../types'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpEmailPasswordState\n  extends SignUpEmailPasswordHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signUpEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string,\n  options?: SignUpOptions,\n  requestOptions?: RequestOptions\n): Promise<SignUpEmailPasswordHandlerResult> =>\n  new Promise<SignUpEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_EMAIL_PASSWORD', {\n      email,\n      password,\n      options,\n      requestOptions\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { RequestOptions, SignUpSecurityKeyOptions } from '../types'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpSecurityKeyHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpSecurityKeyState\n  extends SignUpSecurityKeyHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signUpEmailSecurityKeyPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: SignUpSecurityKeyOptions,\n  requestOptions?: RequestOptions\n): Promise<SignUpSecurityKeyHandlerResult> =>\n  new Promise<SignUpSecurityKeyHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_SECURITY_KEY', {\n      email,\n      options,\n      requestOptions\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { EmailOTPOptions } from '../types'\n\nimport {\n  AuthActionErrorState,\n  AuthActionLoadingState,\n  AuthActionSuccessState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInEmailOTPHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  /**\n   * Returns true when the one-time password has been sent via email, and the user needs to send it back to complete sign-in.\n   */\n  needsOtp: boolean\n}\n\nexport interface SignInEmailOTPState extends SignInEmailOTPHandlerResult, AuthActionLoadingState {}\n\nexport interface VerifyEmailOTPHandlerResult extends SessionActionHandlerResult {}\n\nexport const signInEmailOTPPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: EmailOTPOptions\n) =>\n  new Promise<SignInEmailOTPHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_EMAIL_OTP', { email, options })\n\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      })\n    }\n\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.needsOtp')) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsOtp: true\n        })\n      } else if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        })\n      }\n    })\n  })\n\nexport const verifyEmailOTPPromise = (interpreter: AuthInterpreter, email: string, otp: string) =>\n  new Promise<VerifyEmailOTPHandlerResult>((resolve) => {\n    const { changed } = interpreter.send({ type: 'VERIFY_EMAIL_OTP', email, otp })\n\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value\n        })\n      } else if (state.matches({ registration: { incomplete: 'failed' } })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null,\n          refreshToken: null\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { Provider } from '../types'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInIdTokenHandlerParams {\n  provider: Provider\n  idToken: string\n  nonce?: string\n}\n\nexport interface SignInIdTokenHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInIdTokenState extends SignInIdTokenHandlerResult, AuthActionLoadingState {}\n\nexport const signInIdTokenPromise = (\n  interpreter: AuthInterpreter,\n  { provider, idToken, nonce }: SignInIdTokenHandlerParams\n): Promise<SignInIdTokenHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_ID_TOKEN', {\n      provider,\n      idToken,\n      ...(nonce && { nonce })\n    })\n\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        return resolve({\n          accessToken: null,\n          refreshToken: null,\n          user: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false\n        })\n      }\n\n      if (state.matches({ authentication: 'signedIn' })) {\n        return resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          user: state.context.user,\n          error: null,\n          isError: false,\n          isSuccess: true\n        })\n      }\n    })\n  })\n","import { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, Provider } from '../types'\nimport { postFetch } from '../utils/fetch'\nimport { AuthActionErrorState, AuthActionSuccessState } from './types'\n\nexport interface LinkIdTokenHandlerParams {\n  provider: Provider\n  idToken: string\n  nonce?: string\n}\n\nexport interface LinkIdTokenHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\n\nexport const linkIdTokenPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  { provider, idToken, nonce }: LinkIdTokenHandlerParams\n): Promise<LinkIdTokenHandlerResult> => {\n  try {\n    await postFetch<string>(\n      `${backendUrl}/link/idtoken`,\n      { provider, idToken, ...(nonce && { nonce }) },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n\n    return {\n      isError: false,\n      error: null,\n      isSuccess: true\n    }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false }\n  }\n}\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInSecurityKeyHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignInSecurityKeyState\n  extends SignInSecurityKeyHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInSecurityKeyPromise = (interpreter: AuthInterpreter) =>\n  new Promise<SignInSecurityKeyHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send({ type: 'SIGNIN_SECURITY_KEY' })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, PersonalAccessTokenCreationResponse } from '../types'\nimport { postFetch } from '../utils/fetch'\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface CreatePATHandlerParams {\n  /**\n   * The expiration date of the personal access token.\n   */\n  expiresAt: Date\n  /**\n   * Optional metadata to attach to the personal access token.\n   */\n  metadata?: Record<string, string | number>\n}\n\nexport interface CreatePATHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  /**\n   * The data returned by the backend.\n   */\n  data?: {\n    /**\n     * The ID of the personal access token that was created.\n     */\n    id?: string | null\n    /**\n     * The personal access token that was created.\n     */\n    personalAccessToken?: string | null\n  } | null\n}\n\nexport interface CreatePATState extends CreatePATHandlerResult, AuthActionLoadingState {}\n\nexport const createPATPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  { expiresAt, metadata }: CreatePATHandlerParams\n): Promise<CreatePATHandlerResult> => {\n  try {\n    const { data } = await postFetch<PersonalAccessTokenCreationResponse>(\n      `${backendUrl}/pat`,\n      { expiresAt: expiresAt.toISOString(), metadata },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n\n    return {\n      data: data\n        ? {\n            id: data.id || null,\n            personalAccessToken: data.personalAccessToken || null\n          }\n        : null,\n      isError: false,\n      error: null,\n      isSuccess: true\n    }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false, data: null }\n  }\n}\n","import { jwtDecode } from 'jwt-decode'\nimport { interpret } from 'xstate'\nimport {\n  EMAIL_NEEDS_VERIFICATION,\n  INVALID_REFRESH_TOKEN,\n  INVALID_SIGN_IN_METHOD,\n  NO_REFRESH_TOKEN,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from './errors'\nimport { AuthClient } from './internal-client'\nimport {\n  AuthInterpreter,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine\n} from './machines'\nimport {\n  addSecurityKeyPromise,\n  changeEmailPromise,\n  changePasswordPromise,\n  elevateEmailSecurityKeyPromise,\n  resetPasswordPromise,\n  sendVerificationEmailPromise,\n  signInAnonymousPromise,\n  signInEmailOTPPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailPasswordPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  signInPATPromise,\n  signInSecurityKeyPromise,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise,\n  verifyEmailOTPPromise\n} from './promises'\nimport { createPATPromise } from './promises/createPAT'\nimport { linkIdTokenPromise } from './promises/linkIdToken'\nimport { signInIdTokenPromise } from './promises/signInIdToken'\nimport {\n  AuthChangedFunction,\n  AuthErrorPayload,\n  ChangeEmailParams,\n  ChangeEmailResponse,\n  ChangePasswordParams,\n  ChangePasswordResponse,\n  ConnectProviderParams,\n  ConnectProviderResponse,\n  DeanonymizeParams,\n  DeanonymizeResponse,\n  EmailOTPOptions,\n  JWTClaims,\n  JWTHasuraClaims,\n  LinkIdTokenParams,\n  NhostAuthConstructorParams,\n  NhostSession,\n  NhostSessionResponse,\n  OnTokenChangedFunction,\n  RequestOptions,\n  ResetPasswordParams,\n  ResetPasswordResponse,\n  SecurityKey,\n  SendVerificationEmailParams,\n  SendVerificationEmailResponse,\n  SignInIdTokenParams,\n  SignInParams,\n  SignInPATResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpParams,\n  SignUpResponse\n} from './types'\nimport {\n  encodeQueryParameters,\n  getAuthenticationResult,\n  getSession,\n  isBrowser,\n  rewriteRedirectTo\n} from './utils'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    broadcastKey,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    clientStorage,\n    clientStorageType,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      broadcastKey,\n      autoRefreshToken,\n      autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ### Sign up with an email and password\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign up with a security key\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams, requestOptions?: RequestOptions): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n\n    if ('securityKey' in params) {\n      const { email, options } = params\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options, requestOptions)\n      )\n    }\n    const { email, password, options } = params\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, password, options, requestOptions)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.connectProvider` to connect a social authentication provider to an existing user account\n   *\n   * @example\n   * ### Connect an authentication provider to an existing user account\n   * ```ts\n   * nhost.auth.connectProvider({\n   *   provider: 'github\n   *   options: {\n   *    redirectTo: window.location.href\n   *   }\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/connect-provider\n   */\n  async connectProvider(params: ConnectProviderParams): Promise<ConnectProviderResponse> {\n    const interpreter = await this.waitUntilReady()\n    const accessToken = interpreter.getSnapshot().context.accessToken.value\n\n    const { provider, options } = params\n\n    const providerUrl = encodeQueryParameters(\n      `${this._client.backendUrl}/signin/provider/${provider}`,\n      rewriteRedirectTo(this._client.clientUrl, {\n        ...options,\n        connect: accessToken\n      } as any)\n    )\n    if (isBrowser()) {\n      window.location.href = providerUrl\n    }\n\n    return { providerUrl }\n  }\n\n  /**\n   * Use `nhost.auth.signInIdToken` to sign in a user with the provider's account using an ID token\n   *\n   * @example\n   * ### Sign in a user with an id token\n   * ```ts\n   * nhost.auth.signInIdToken({\n   *   provider: 'google', // The provider name, e.g., 'google', 'apple', etc.\n   *   idToken: '...', // The ID token issued by the provider.\n   *   nonce: '...', // Optional: The nonce used during token generation.\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-idtoken\n   */\n  async signInIdToken(params: SignInIdTokenParams) {\n    const interpreter = await this.waitUntilReady()\n\n    const res = await signInIdTokenPromise(interpreter, params)\n\n    return { ...getAuthenticationResult(res), mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.linkIdToken` to link a user account with the provider's account using an ID token\n   *\n   * @example\n   * ### Link a user account with the provider's account using an id token\n   * ```ts\n   * nhost.auth.linkIdToken({\n   *   provider: 'google', // The provider name, e.g., 'google', 'apple', etc.\n   *   idToken: '...', // The ID token issued by the provider.\n   *   nonce: '...', // Optional: The nonce used during token generation.\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/link-idtoken\n   */\n  async linkIdToken(params: LinkIdTokenParams) {\n    return linkIdTokenPromise(this._client, params)\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @example\n   * ### Sign in anonymously\n   * ```ts\n   * // Sign in anonymously\n   * nhost.auth.signIn()\n   *\n   * // Later in the application, the user can complete their registration\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in with a security key\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params?: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n    // * Anonymous sign-in\n    if (!params) {\n      const anonymousResult = await signInAnonymousPromise(interpreter)\n      return { ...getAuthenticationResult(anonymousResult), mfa: null }\n    }\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    return { error: INVALID_SIGN_IN_METHOD, mfa: null, session: null }\n  }\n\n  /**\n   * Use `nhost.auth.signInPAT` to sign in with a personal access token (PAT).\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInPAT('34f74930-09c0-4af5-a8d5-28fad78e3415')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-pat\n   *\n   * @param personalAccessToken - The personal access token to sign in with\n   */\n  async signInPAT(personalAccessToken: string): Promise<SignInPATResponse> {\n    const interpreter = await this.waitUntilReady()\n    const res = await signInPATPromise(interpreter, personalAccessToken)\n\n    return getAuthenticationResult(res)\n  }\n\n  /**\n   * Use `nhost.auth.signInEmailOTP` to sign in with an email one-time password (OTP).\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInEmailOTP('user@example.com')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-email-otp\n   *\n   * @param email - The email address to send the OTP to\n   */\n  async signInEmailOTP(email: string, options?: EmailOTPOptions): Promise<SignInResponse> {\n    const interpreter = await this.waitUntilReady()\n\n    const { error } = await signInEmailOTPPromise(interpreter, email, options)\n\n    return {\n      error,\n      session: null,\n      mfa: null\n    }\n  }\n\n  /**\n   * Use `nhost.auth.verifyEmailOTP` to verify an email one-time password (OTP) and complete the sign-in process\n   *\n   * @example\n   * ```ts\n   * nhost.auth.verifyEmailOTP('user@example.com', '123456')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/verify-email-otp\n   *\n   * @param email - The email address to verify the OTP for\n   * @param otp - The one-time password sent to the email address\n   */\n  async verifyEmailOTP(email: string, otp: string): Promise<SignInResponse> {\n    const interpreter = await this.waitUntilReady()\n\n    const res = await verifyEmailOTPPromise(interpreter, email, otp)\n\n    return { ...getAuthenticationResult(res), mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.signInSecurityKey` to sign in a user with a security key using the WebAuthn API\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInSecurityKey()\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-security-key\n   */\n  async signInSecurityKey(): Promise<SignInResponse> {\n    const interpreter = await this.waitUntilReady()\n\n    const res = await signInSecurityKeyPromise(interpreter)\n\n    return { ...getAuthenticationResult(res), mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey` to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: AuthErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.elevateEmailSecurityKey` to get a temporary elevated auth permissions to run sensitive operations.\n   * @param email user email\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/elevate-email-security-key\n   */\n  async elevateEmailSecurityKey(email: string) {\n    if (!email) {\n      throw Error('A user email is required')\n    }\n\n    const res = await elevateEmailSecurityKeyPromise(this._client, email)\n\n    return { ...res, mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.createPAT` to create a personal access token for the user.\n   *\n   * @param expiresAt Expiration date for the token\n   * @param metadata Optional metadata to store with the token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/create-pat\n   */\n  async createPAT(expiresAt: Date, metadata?: Record<string, string | number>) {\n    return createPATPromise(this._client, { expiresAt, metadata })\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    return this._client.subscribe(() => {\n      const subscription = this._client.interpreter?.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n      return () => subscription?.stop()\n    })\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    return this._client.subscribe(() => {\n      const subscription = this._client.interpreter?.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n      return () => subscription?.stop()\n    })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * The promise won't resolve until the authentication status is known.\n   * Attention: when using auto-signin and a refresh token is present in the client storage, the promise won't resolve if the server can't be reached (e.g. offline) or if it returns an internal error.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * The `connectionAttempts` returns the number of times the client has tried to connect to the server with no success (offline, or the server retruned an internal error).\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n    connectionAttempts: number\n  } {\n    const connectionAttempts =\n      this.client.interpreter?.getSnapshot().context.importTokenAttempts || 0\n    if (!this.isReady()) {\n      return {\n        isAuthenticated: false,\n        isLoading: true,\n        connectionAttempts\n      }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false, connectionAttempts }\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.getSnapshot().context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwtDecode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHasuraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshSession();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshSession(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.getSnapshot().context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.getSnapshot()?.context)\n  }\n\n  /**\n   * Initialize the auth client with an existing session\n   *\n   * @example\n   * ### Initialize with an existing Nhost session\n   * ```ts\n   * await nhost.auth.initWithSession({ session: initialSession })\n   * ```\n   *\n   * @param session - The Nhost session object to initialize the client with\n   * @docs https://docs.nhost.io/reference/javascript/auth/init-with-session\n   */\n  async initWithSession({ session }: { session: NhostSession }): Promise<void> {\n    this.client.start({ initialSession: session })\n    await this.waitUntilReady()\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.getSnapshot()?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.getSnapshot().hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.getSnapshot()?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n"],"names":["NHOST_REFRESH_TOKEN_KEY","NHOST_REFRESH_TOKEN_ID_KEY","NHOST_JWT_EXPIRES_AT_KEY","MIN_PASSWORD_LENGTH","TOKEN_REFRESH_MARGIN_SECONDS","REFRESH_TOKEN_MAX_ATTEMPTS","NETWORK_ERROR_CODE","OTHER_ERROR_CODE","VALIDATION_ERROR_CODE","STATE_ERROR_CODE","CodifiedError","original","INVALID_EMAIL_ERROR","INVALID_MFA_TYPE_ERROR","INVALID_MFA_CODE_ERROR","INVALID_PASSWORD_ERROR","INVALID_PHONE_NUMBER_ERROR","INVALID_MFA_TICKET_ERROR","NO_MFA_TICKET_ERROR","NO_REFRESH_TOKEN","TOKEN_REFRESHER_RUNNING_ERROR","USER_ALREADY_SIGNED_IN","USER_UNAUTHENTICATED","USER_NOT_ANONYMOUS","EMAIL_NEEDS_VERIFICATION","INVALID_REFRESH_TOKEN","INVALID_SIGN_IN_METHOD","INITIAL_MACHINE_CONTEXT","utf8StringToBuffer","value","bufferToBase64URLString","buffer","bytes","str","charCode","base64URLStringToBuffer","base64URLString","base64","padLength","padded","binary","i","browserSupportsWebAuthn","toPublicKeyCredentialDescriptor","descriptor","id","isValidDomain","hostname","WebAuthnError","message","code","cause","name","identifyRegistrationError","error","options","publicKey","_a","_b","param","effectiveDomain","BaseWebAuthnAbortService","abortError","newController","WebAuthnAbortService","attachments","toAuthenticatorAttachment","attachment","startRegistration","creationOptionsJSON","credential","err","rawId","response","type","transports","responsePublicKeyAlgorithm","warnOnBrokenImplementation","responsePublicKey","_publicKey","responseAuthenticatorData","methodName","bufferToUTF8String","browserSupportsWebAuthnAutofill","globalPublicKeyCredential","resolve","identifyAuthenticationError","startAuthentication","requestOptionsJSON","useBrowserAutofill","allowCredentials","userHandle","isBrowser","inMemoryLocalStorage","defaultClientStorageGetter","key","defaultClientStorageSetter","localStorageGetter","clientStorageType","clientStorage","Cookies","localStorageSetter","getSession","context","getAuthenticationResult","accessToken","refreshToken","isError","user","fetch","fetchPonyfill","fetchWrapper","url","method","token","body","extraHeaders","headers","mergedHeaders","result","postFetch","getFetch","encodeQueryParameters","baseUrl","parameters","encodedParameters","stringValue","rewriteRedirectTo","clientUrl","redirectTo","otherOptions","baseClientUrl","clientParams","additionalParams","combinedParams","pathName","getParameterByName","regex","results","removeParameterFromWindow","location","search","hash","isValidEmail","email","isValidPassword","password","isValidPhoneNumber","phoneNumber","isValidTicket","ticket","createAuthMachine","backendUrl","broadcastKey","refreshIntervalTime","autoRefreshToken","autoSignIn","storageGetter","storageSetter","postRequest","data","sharedBroadcastChannel","createMachine","send","assign","importTokenAttempts","_","accessTokenExpiresIn","nextRefresh","refreshTokenId","e","ctx","errors","expiresAt","expiresInMilliseconds","_context","pat","provider","idToken","nonce","otp","event","signOutResponse","requestOptions","nickname","webAuthnOptions","urlToken","exception","errorDescription","storageToken","createChangeEmailMachine","interpreter","createChangePasswordMachine","createEnableMfaMachine","imageUrl","totpSecret","activeMfaType","createResetPasswordMachine","createSendVerificationEmailMachine","AuthClient","start","devTools","defaultOptions","payload","existingToken","initialSession","machineWithInitialContext","interpret","fn","subscription","AuthCookieClient","AuthClientSSR","addSecurityKeyPromise","changeEmailPromise","s","changePasswordPromise","state","generateQrCodePromise","service","activateMfaPromise","disableMfaPromise","resetPasswordPromise","sendVerificationEmailPromise","signInAnonymousPromise","changed","signInEmailPasswordPromise","signInEmailPasswordlessPromise","signInEmailSecurityKeyPromise","createAuthErrorPayload","elevateEmailSecurityKeyPromise","authClient","snapshot","session","signInError","signInMfaTotpPromise","signInPATPromise","signInSmsPasswordlessPromise","signInSmsPasswordlessOtpPromise","signOutPromise","all","signUpEmailPasswordPromise","signUpEmailSecurityKeyPromise","signInEmailOTPPromise","verifyEmailOTPPromise","signInIdTokenPromise","linkIdTokenPromise","signInSecurityKeyPromise","createPATPromise","metadata","HasuraAuthClient","params","providerUrl","res","anonymousResult","personalAccessToken","newPassword","newEmail","connectionAttempts","jwt","jwtDecode","_c","reject","timer"],"mappings":"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","debugId":null}}]
}