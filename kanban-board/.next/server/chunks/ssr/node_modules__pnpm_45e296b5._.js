module.exports = {

"[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        if ("TURBOPACK compile-time truthy", 1) {
            if ("TURBOPACK compile-time truthy", 1) {
                module.exports = __turbopack_context__.r("[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)");
            } else //TURBOPACK unreachable
            ;
        } else //TURBOPACK unreachable
        ;
    }
} //# sourceMappingURL=module.compiled.js.map
}}),
"[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxDevRuntime; //# sourceMappingURL=react-jsx-dev-runtime.js.map
}}),
"[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].React; //# sourceMappingURL=react.js.map
}}),
"[project]/node_modules/.pnpm/jwt-decode@4.0.0/node_modules/jwt-decode/build/cjs/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwtDecode = exports.InvalidTokenError = void 0;
class InvalidTokenError extends Error {
}
exports.InvalidTokenError = InvalidTokenError;
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p)=>{
        let code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
            code = "0" + code;
        }
        return "%" + code;
    }));
}
function base64UrlDecode(str) {
    let output = str.replace(/-/g, "+").replace(/_/g, "/");
    switch(output.length % 4){
        case 0:
            break;
        case 2:
            output += "==";
            break;
        case 3:
            output += "=";
            break;
        default:
            throw new Error("base64 string is not of the correct length");
    }
    try {
        return b64DecodeUnicode(output);
    } catch (err) {
        return atob(output);
    }
}
function jwtDecode(token, options) {
    if (typeof token !== "string") {
        throw new InvalidTokenError("Invalid token specified: must be a string");
    }
    options || (options = {});
    const pos = options.header === true ? 0 : 1;
    const part = token.split(".")[pos];
    if (typeof part !== "string") {
        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
    }
    let decoded;
    try {
        decoded = base64UrlDecode(part);
    } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
    }
    try {
        return JSON.parse(decoded);
    } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
    }
}
exports.jwtDecode = jwtDecode;
}}),
"[project]/node_modules/.pnpm/js-cookie@3.0.5/node_modules/js-cookie/dist/js.cookie.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/*! js-cookie v3.0.5 | MIT */ ;
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : "TURBOPACK unreachable";
})(("TURBOPACK member replacement", __turbopack_context__.e), function() {
    'use strict';
    /* eslint-disable no-var */ function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                target[key] = source[key];
            }
        }
        return target;
    }
    /* eslint-enable no-var */ /* eslint-disable no-var */ var defaultConverter = {
        read: function(value) {
            if (value[0] === '"') {
                value = value.slice(1, -1);
            }
            return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
        },
        write: function(value) {
            return encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
        }
    };
    /* eslint-enable no-var */ /* eslint-disable no-var */ function init(converter, defaultAttributes) {
        function set(name, value, attributes) {
            if (typeof document === 'undefined') {
                return;
            }
            attributes = assign({}, defaultAttributes, attributes);
            if (typeof attributes.expires === 'number') {
                attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
            }
            if (attributes.expires) {
                attributes.expires = attributes.expires.toUTCString();
            }
            name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
            var stringifiedAttributes = '';
            for(var attributeName in attributes){
                if (!attributes[attributeName]) {
                    continue;
                }
                stringifiedAttributes += '; ' + attributeName;
                if (attributes[attributeName] === true) {
                    continue;
                }
                // Considers RFC 6265 section 5.2:
                // ...
                // 3.  If the remaining unparsed-attributes contains a %x3B (";")
                //     character:
                // Consume the characters of the unparsed-attributes up to,
                // not including, the first %x3B (";") character.
                // ...
                stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
            }
            return document.cookie = name + '=' + converter.write(value, name) + stringifiedAttributes;
        }
        function get(name) {
            if (typeof document === 'undefined' || arguments.length && !name) {
                return;
            }
            // To prevent the for loop in the first place assign an empty array
            // in case there are no cookies at all.
            var cookies = document.cookie ? document.cookie.split('; ') : [];
            var jar = {};
            for(var i = 0; i < cookies.length; i++){
                var parts = cookies[i].split('=');
                var value = parts.slice(1).join('=');
                try {
                    var found = decodeURIComponent(parts[0]);
                    jar[found] = converter.read(value, found);
                    if (name === found) {
                        break;
                    }
                } catch (e) {}
            }
            return name ? jar[name] : jar;
        }
        return Object.create({
            set,
            get,
            remove: function(name, attributes) {
                set(name, '', assign({}, attributes, {
                    expires: -1
                }));
            },
            withAttributes: function(attributes) {
                return init(this.converter, assign({}, this.attributes, attributes));
            },
            withConverter: function(converter) {
                return init(assign({}, this.converter, converter), this.attributes);
            }
        }, {
            attributes: {
                value: Object.freeze(defaultAttributes)
            },
            converter: {
                value: Object.freeze(converter)
            }
        });
    }
    var api = init(defaultConverter, {
        path: '/'
    });
    /* eslint-enable no-var */ return api;
});
}}),
"[project]/node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var conversions = {};
module.exports = conversions;
function sign(x) {
    return x < 0 ? -1 : 1;
}
function evenRound(x) {
    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.
    if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
    } else {
        return Math.round(x);
    }
}
function createNumberConversion(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
        --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;
    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
    return function(V, opts) {
        if (!opts) opts = {};
        let x = +V;
        if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
                throw new TypeError("Argument is not a finite number");
            }
            x = sign(x) * Math.floor(Math.abs(x));
            if (x < lowerBound || x > upperBound) {
                throw new TypeError("Argument is not in byte range");
            }
            return x;
        }
        if (!isNaN(x) && opts.clamp) {
            x = evenRound(x);
            if (x < lowerBound) x = lowerBound;
            if (x > upperBound) x = upperBound;
            return x;
        }
        if (!Number.isFinite(x) || x === 0) {
            return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
            return x - moduloVal;
        } else if (typeOpts.unsigned) {
            if (x < 0) {
                x += moduloVal;
            } else if (x === -0) {
                return 0;
            }
        }
        return x;
    };
}
conversions["void"] = function() {
    return undefined;
};
conversions["boolean"] = function(val) {
    return !!val;
};
conversions["byte"] = createNumberConversion(8, {
    unsigned: false
});
conversions["octet"] = createNumberConversion(8, {
    unsigned: true
});
conversions["short"] = createNumberConversion(16, {
    unsigned: false
});
conversions["unsigned short"] = createNumberConversion(16, {
    unsigned: true
});
conversions["long"] = createNumberConversion(32, {
    unsigned: false
});
conversions["unsigned long"] = createNumberConversion(32, {
    unsigned: true
});
conversions["long long"] = createNumberConversion(32, {
    unsigned: false,
    moduloBitLength: 64
});
conversions["unsigned long long"] = createNumberConversion(32, {
    unsigned: true,
    moduloBitLength: 64
});
conversions["double"] = function(V) {
    const x = +V;
    if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
    }
    return x;
};
conversions["unrestricted double"] = function(V) {
    const x = +V;
    if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
    }
    return x;
};
// not quite valid, but good enough for JS
conversions["float"] = conversions["double"];
conversions["unrestricted float"] = conversions["unrestricted double"];
conversions["DOMString"] = function(V, opts) {
    if (!opts) opts = {};
    if (opts.treatNullAsEmptyString && V === null) {
        return "";
    }
    return String(V);
};
conversions["ByteString"] = function(V, opts) {
    const x = String(V);
    let c = undefined;
    for(let i = 0; (c = x.codePointAt(i)) !== undefined; ++i){
        if (c > 255) {
            throw new TypeError("Argument is not a valid bytestring");
        }
    }
    return x;
};
conversions["USVString"] = function(V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for(let i = 0; i < n; ++i){
        const c = S.charCodeAt(i);
        if (c < 0xD800 || c > 0xDFFF) {
            U.push(String.fromCodePoint(c));
        } else if (0xDC00 <= c && c <= 0xDFFF) {
            U.push(String.fromCodePoint(0xFFFD));
        } else {
            if (i === n - 1) {
                U.push(String.fromCodePoint(0xFFFD));
            } else {
                const d = S.charCodeAt(i + 1);
                if (0xDC00 <= d && d <= 0xDFFF) {
                    const a = c & 0x3FF;
                    const b = d & 0x3FF;
                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                    ++i;
                } else {
                    U.push(String.fromCodePoint(0xFFFD));
                }
            }
        }
    }
    return U.join('');
};
conversions["Date"] = function(V, opts) {
    if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
        return undefined;
    }
    return V;
};
conversions["RegExp"] = function(V, opts) {
    if (!(V instanceof RegExp)) {
        V = new RegExp(V);
    }
    return V;
};
}}),
"[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports.mixin = function mixin(target, source) {
    const keys = Object.getOwnPropertyNames(source);
    for(let i = 0; i < keys.length; ++i){
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
    }
};
module.exports.wrapperSymbol = Symbol("wrapper");
module.exports.implSymbol = Symbol("impl");
module.exports.wrapperForImpl = function(impl) {
    return impl[module.exports.wrapperSymbol];
};
module.exports.implForWrapper = function(wrapper) {
    return wrapper[module.exports.implSymbol];
};
}}),
"[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const punycode = __turbopack_context__.r("[externals]/punycode [external] (punycode, cjs)");
const tr46 = __turbopack_context__.r("[project]/node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js [app-ssr] (ecmascript)");
const specialSchemes = {
    ftp: 21,
    file: null,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
};
const failure = Symbol("failure");
function countSymbols(str) {
    return punycode.ucs2.decode(str).length;
}
function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
}
function isASCIIDigit(c) {
    return c >= 0x30 && c <= 0x39;
}
function isASCIIAlpha(c) {
    return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A;
}
function isASCIIAlphanumeric(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
}
function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;
}
function isSingleDot(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
}
function isDoubleDot(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
}
function isWindowsDriveLetterCodePoints(cp1, cp2) {
    return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
}
function isWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
}
function isNormalizedWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
}
function containsForbiddenHostCodePoint(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
}
function containsForbiddenHostCodePointExcludingPercent(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
}
function isSpecialScheme(scheme) {
    return specialSchemes[scheme] !== undefined;
}
function isSpecial(url) {
    return isSpecialScheme(url.scheme);
}
function defaultPort(scheme) {
    return specialSchemes[scheme];
}
function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
        hex = "0" + hex;
    }
    return "%" + hex;
}
function utf8PercentEncode(c) {
    const buf = new Buffer(c);
    let str = "";
    for(let i = 0; i < buf.length; ++i){
        str += percentEncode(buf[i]);
    }
    return str;
}
function utf8PercentDecode(str) {
    const input = new Buffer(str);
    const output = [];
    for(let i = 0; i < input.length; ++i){
        if (input[i] !== 37) {
            output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
            output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
            i += 2;
        } else {
            output.push(input[i]);
        }
    }
    return new Buffer(output).toString();
}
function isC0ControlPercentEncode(c) {
    return c <= 0x1F || c > 0x7E;
}
const extraPathPercentEncodeSet = new Set([
    32,
    34,
    35,
    60,
    62,
    63,
    96,
    123,
    125
]);
function isPathPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
}
const extraUserinfoPercentEncodeSet = new Set([
    47,
    58,
    59,
    61,
    64,
    91,
    92,
    93,
    94,
    124
]);
function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
}
function percentEncodeChar(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
    }
    return cStr;
}
function parseIPv4Number(input) {
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
    }
    if (input === "") {
        return 0;
    }
    const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
    if (regex.test(input)) {
        return failure;
    }
    return parseInt(input, R);
}
function parseIPv4(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
            parts.pop();
        }
    }
    if (parts.length > 4) {
        return input;
    }
    const numbers = [];
    for (const part of parts){
        if (part === "") {
            return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
            return input;
        }
        numbers.push(n);
    }
    for(let i = 0; i < numbers.length - 1; ++i){
        if (numbers[i] > 255) {
            return failure;
        }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers){
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
    }
    return ipv4;
}
function serializeIPv4(address) {
    let output = "";
    let n = address;
    for(let i = 1; i <= 4; ++i){
        output = String(n % 256) + output;
        if (i !== 4) {
            output = "." + output;
        }
        n = Math.floor(n / 256);
    }
    return output;
}
function parseIPv6(input) {
    const address = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = punycode.ucs2.decode(input);
    if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
            return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
    }
    while(pointer < input.length){
        if (pieceIndex === 8) {
            return failure;
        }
        if (input[pointer] === 58) {
            if (compress !== null) {
                return failure;
            }
            ++pointer;
            ++pieceIndex;
            compress = pieceIndex;
            continue;
        }
        let value = 0;
        let length = 0;
        while(length < 4 && isASCIIHex(input[pointer])){
            value = value * 0x10 + parseInt(at(input, pointer), 16);
            ++pointer;
            ++length;
        }
        if (input[pointer] === 46) {
            if (length === 0) {
                return failure;
            }
            pointer -= length;
            if (pieceIndex > 6) {
                return failure;
            }
            let numbersSeen = 0;
            while(input[pointer] !== undefined){
                let ipv4Piece = null;
                if (numbersSeen > 0) {
                    if (input[pointer] === 46 && numbersSeen < 4) {
                        ++pointer;
                    } else {
                        return failure;
                    }
                }
                if (!isASCIIDigit(input[pointer])) {
                    return failure;
                }
                while(isASCIIDigit(input[pointer])){
                    const number = parseInt(at(input, pointer));
                    if (ipv4Piece === null) {
                        ipv4Piece = number;
                    } else if (ipv4Piece === 0) {
                        return failure;
                    } else {
                        ipv4Piece = ipv4Piece * 10 + number;
                    }
                    if (ipv4Piece > 255) {
                        return failure;
                    }
                    ++pointer;
                }
                address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;
                ++numbersSeen;
                if (numbersSeen === 2 || numbersSeen === 4) {
                    ++pieceIndex;
                }
            }
            if (numbersSeen !== 4) {
                return failure;
            }
            break;
        } else if (input[pointer] === 58) {
            ++pointer;
            if (input[pointer] === undefined) {
                return failure;
            }
        } else if (input[pointer] !== undefined) {
            return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
    }
    if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while(pieceIndex !== 0 && swaps > 0){
            const temp = address[compress + swaps - 1];
            address[compress + swaps - 1] = address[pieceIndex];
            address[pieceIndex] = temp;
            --pieceIndex;
            --swaps;
        }
    } else if (compress === null && pieceIndex !== 8) {
        return failure;
    }
    return address;
}
function serializeIPv6(address) {
    let output = "";
    const seqResult = findLongestZeroSequence(address);
    const compress = seqResult.idx;
    let ignore0 = false;
    for(let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex){
        if (ignore0 && address[pieceIndex] === 0) {
            continue;
        } else if (ignore0) {
            ignore0 = false;
        }
        if (compress === pieceIndex) {
            const separator = pieceIndex === 0 ? "::" : ":";
            output += separator;
            ignore0 = true;
            continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
            output += ":";
        }
    }
    return output;
}
function parseHost(input, isSpecialArg) {
    if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
            return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
    }
    if (!isSpecialArg) {
        return parseOpaqueHost(input);
    }
    const domain = utf8PercentDecode(input);
    const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
    if (asciiDomain === null) {
        return failure;
    }
    if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
    }
    const ipv4Host = parseIPv4(asciiDomain);
    if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
    }
    return asciiDomain;
}
function parseOpaqueHost(input) {
    if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
    }
    let output = "";
    const decoded = punycode.ucs2.decode(input);
    for(let i = 0; i < decoded.length; ++i){
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
    }
    return output;
}
function findLongestZeroSequence(arr) {
    let maxIdx = null;
    let maxLen = 1; // only find elements > 1
    let currStart = null;
    let currLen = 0;
    for(let i = 0; i < arr.length; ++i){
        if (arr[i] !== 0) {
            if (currLen > maxLen) {
                maxIdx = currStart;
                maxLen = currLen;
            }
            currStart = null;
            currLen = 0;
        } else {
            if (currStart === null) {
                currStart = i;
            }
            ++currLen;
        }
    }
    // if trailing zeros
    if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
    }
    return {
        idx: maxIdx,
        len: maxLen
    };
}
function serializeHost(host) {
    if (typeof host === "number") {
        return serializeIPv4(host);
    }
    // IPv6 serializer
    if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
    }
    return host;
}
function trimControlChars(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
}
function trimTabAndNewline(url) {
    return url.replace(/\u0009|\u000A|\u000D/g, "");
}
function shortenPath(url) {
    const path = url.path;
    if (path.length === 0) {
        return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
    }
    path.pop();
}
function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
}
function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
}
function isNormalizedWindowsDriveLetter(string) {
    return /^[A-Za-z]:$/.test(string);
}
function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
        this.url = {
            scheme: "",
            username: "",
            password: "",
            host: null,
            port: null,
            path: [],
            query: null,
            fragment: null,
            cannotBeABaseURL: false
        };
        const res = trimControlChars(this.input);
        if (res !== this.input) {
            this.parseError = true;
        }
        this.input = res;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
        this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = punycode.ucs2.decode(this.input);
    for(; this.pointer <= this.input.length; ++this.pointer){
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
        // exec state machine
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
            break; // terminate algorithm
        } else if (ret === failure) {
            this.failure = true;
            break;
        }
    }
}
URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
    } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
    } else {
        this.parseError = true;
        return failure;
    }
    return true;
};
URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
    } else if (c === 58) {
        if (this.stateOverride) {
            if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
                return false;
            }
            if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
                return false;
            }
            if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
                return false;
            }
            if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
                return false;
            }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
            return false;
        }
        if (this.url.scheme === "file") {
            if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
                this.parseError = true;
            }
            this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
            this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
            this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
            this.state = "path or authority";
            ++this.pointer;
        } else {
            this.url.cannotBeABaseURL = true;
            this.url.path.push("");
            this.state = "cannot-be-a-base-URL path";
        }
    } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
    } else {
        this.parseError = true;
        return failure;
    }
    return true;
};
URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
    } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
    } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
    } else {
        this.state = "relative";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
    } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === 47) {
        this.state = "authority";
    } else {
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
    } else if (c === 47) {
        this.state = "relative slash";
    } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
    } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
    } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
    } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "special authority ignore slashes";
    } else if (c === 47) {
        this.state = "authority";
    } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
    } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
    } else {
        this.parseError = true;
    }
    return true;
};
URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
            this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
        const len = countSymbols(this.buffer);
        for(let pointer = 0; pointer < len; ++pointer){
            const codePoint = this.buffer.codePointAt(pointer);
            if (codePoint === 58 && !this.passwordTokenSeenFlag) {
                this.passwordTokenSeenFlag = true;
                continue;
            }
            const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
            if (this.passwordTokenSeenFlag) {
                this.url.password += encodedCodePoints;
            } else {
                this.url.username += encodedCodePoints;
            }
        }
        this.buffer = "";
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
            this.parseError = true;
            return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
    } else {
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
    } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
            this.parseError = true;
            return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
            return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
            return false;
        }
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
            this.parseError = true;
            return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
            this.parseError = true;
            return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
            return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
            return false;
        }
    } else {
        if (c === 91) {
            this.arrFlag = true;
        } else if (c === 93) {
            this.arrFlag = false;
        }
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (isASCIIDigit(c)) {
        this.buffer += cStr;
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
            const port = parseInt(this.buffer);
            if (port > Math.pow(2, 16) - 1) {
                this.parseError = true;
                return failure;
            }
            this.url.port = port === defaultPort(this.url.scheme) ? null : port;
            this.buffer = "";
        }
        if (this.stateOverride) {
            return false;
        }
        this.state = "path start";
        --this.pointer;
    } else {
        this.parseError = true;
        return failure;
    }
    return true;
};
const fileOtherwiseCodePoints = new Set([
    47,
    92,
    63,
    35
]);
URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    if (c === 47 || c === 92) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
        } else if (c === 63) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = "";
            this.state = "query";
        } else if (c === 35) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
            this.url.fragment = "";
            this.state = "fragment";
        } else {
            if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
            !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
            !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
                this.url.host = this.base.host;
                this.url.path = this.base.path.slice();
                shortenPath(this.url);
            } else {
                this.parseError = true;
            }
            this.state = "path";
            --this.pointer;
        }
    } else {
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === 47 || c === 92) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "file host";
    } else {
        if (this.base !== null && this.base.scheme === "file") {
            if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
                this.url.path.push(this.base.path[0]);
            } else {
                this.url.host = this.base.host;
            }
        }
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
            this.parseError = true;
            this.state = "path";
        } else if (this.buffer === "") {
            this.url.host = "";
            if (this.stateOverride) {
                return false;
            }
            this.state = "path start";
        } else {
            let host = parseHost(this.buffer, isSpecial(this.url));
            if (host === failure) {
                return failure;
            }
            if (host === "localhost") {
                host = "";
            }
            this.url.host = host;
            if (this.stateOverride) {
                return false;
            }
            this.buffer = "";
            this.state = "path start";
        }
    } else {
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
            --this.pointer;
        }
    } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
    } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
    } else if (c !== undefined) {
        this.state = "path";
        if (c !== 47) {
            --this.pointer;
        }
    }
    return true;
};
URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
            this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
            shortenPath(this.url);
            if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
                this.url.path.push("");
            }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
            if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
                if (this.url.host !== "" && this.url.host !== null) {
                    this.parseError = true;
                    this.url.host = "";
                }
                this.buffer = this.buffer[0] + ":";
            }
            this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
            while(this.url.path.length > 1 && this.url.path[0] === ""){
                this.parseError = true;
                this.url.path.shift();
            }
        }
        if (c === 63) {
            this.url.query = "";
            this.state = "query";
        }
        if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
        }
    } else {
        // TODO: If c is not a URL code point and not "%", parse error.
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
    }
    return true;
};
URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
    if (c === 63) {
        this.url.query = "";
        this.state = "query";
    } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
    } else {
        // TODO: Add: not a URL code point
        if (!isNaN(c) && c !== 37) {
            this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        if (!isNaN(c)) {
            this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
    }
    return true;
};
URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
            this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
        for(let i = 0; i < buffer.length; ++i){
            if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 || buffer[i] === 0x3C || buffer[i] === 0x3E) {
                this.url.query += percentEncode(buffer[i]);
            } else {
                this.url.query += String.fromCodePoint(buffer[i]);
            }
        }
        this.buffer = "";
        if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
        }
    } else {
        // TODO: If c is not a URL code point and not "%", parse error.
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (isNaN(c)) {} else if (c === 0x0) {
        this.parseError = true;
    } else {
        // TODO: If c is not a URL code point and not "%", parse error.
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
    }
    return true;
};
function serializeURL(url, excludeFragment) {
    let output = url.scheme + ":";
    if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
            output += url.username;
            if (url.password !== "") {
                output += ":" + url.password;
            }
            output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
            output += ":" + url.port;
        }
    } else if (url.host === null && url.scheme === "file") {
        output += "//";
    }
    if (url.cannotBeABaseURL) {
        output += url.path[0];
    } else {
        for (const string of url.path){
            output += "/" + string;
        }
    }
    if (url.query !== null) {
        output += "?" + url.query;
    }
    if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
    }
    return output;
}
function serializeOrigin(tuple) {
    let result = tuple.scheme + "://";
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
        result += ":" + tuple.port;
    }
    return result;
}
module.exports.serializeURL = serializeURL;
module.exports.serializeURLOrigin = function(url) {
    // https://url.spec.whatwg.org/#concept-url-origin
    switch(url.scheme){
        case "blob":
            try {
                return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
            } catch (e) {
                // serializing an opaque origin returns "null"
                return "null";
            }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
            return serializeOrigin({
                scheme: url.scheme,
                host: url.host,
                port: url.port
            });
        case "file":
            // spec says "exercise to the reader", chrome says "file://"
            return "file://";
        default:
            // serializing an opaque origin returns "null"
            return "null";
    }
};
module.exports.basicURLParse = function(input, options) {
    if (options === undefined) {
        options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
        return "failure";
    }
    return usm.url;
};
module.exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode.ucs2.decode(username);
    for(let i = 0; i < decoded.length; ++i){
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
};
module.exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode.ucs2.decode(password);
    for(let i = 0; i < decoded.length; ++i){
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
};
module.exports.serializeHost = serializeHost;
module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
module.exports.serializeInteger = function(integer) {
    return String(integer);
};
module.exports.parseURL = function(input, options) {
    if (options === undefined) {
        options = {};
    }
    // We don't handle blobs, so this just delegates:
    return module.exports.basicURLParse(input, {
        baseURL: options.baseURL,
        encodingOverride: options.encodingOverride
    });
};
}}),
"[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const usm = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)");
exports.implementation = class URLImpl {
    constructor(constructorArgs){
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== undefined) {
            parsedBase = usm.basicURLParse(base);
            if (parsedBase === "failure") {
                throw new TypeError("Invalid base URL");
            }
        }
        const parsedURL = usm.basicURLParse(url, {
            baseURL: parsedBase
        });
        if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
    // TODO: query stuff
    }
    get href() {
        return usm.serializeURL(this._url);
    }
    set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
    }
    get origin() {
        return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
        return this._url.scheme + ":";
    }
    set protocol(v) {
        usm.basicURLParse(v + ":", {
            url: this._url,
            stateOverride: "scheme start"
        });
    }
    get username() {
        return this._url.username;
    }
    set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
        }
        usm.setTheUsername(this._url, v);
    }
    get password() {
        return this._url.password;
    }
    set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
        }
        usm.setThePassword(this._url, v);
    }
    get host() {
        const url = this._url;
        if (url.host === null) {
            return "";
        }
        if (url.port === null) {
            return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
    }
    set host(v) {
        if (this._url.cannotBeABaseURL) {
            return;
        }
        usm.basicURLParse(v, {
            url: this._url,
            stateOverride: "host"
        });
    }
    get hostname() {
        if (this._url.host === null) {
            return "";
        }
        return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
        if (this._url.cannotBeABaseURL) {
            return;
        }
        usm.basicURLParse(v, {
            url: this._url,
            stateOverride: "hostname"
        });
    }
    get port() {
        if (this._url.port === null) {
            return "";
        }
        return usm.serializeInteger(this._url.port);
    }
    set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
        }
        if (v === "") {
            this._url.port = null;
        } else {
            usm.basicURLParse(v, {
                url: this._url,
                stateOverride: "port"
            });
        }
    }
    get pathname() {
        if (this._url.cannotBeABaseURL) {
            return this._url.path[0];
        }
        if (this._url.path.length === 0) {
            return "";
        }
        return "/" + this._url.path.join("/");
    }
    set pathname(v) {
        if (this._url.cannotBeABaseURL) {
            return;
        }
        this._url.path = [];
        usm.basicURLParse(v, {
            url: this._url,
            stateOverride: "path start"
        });
    }
    get search() {
        if (this._url.query === null || this._url.query === "") {
            return "";
        }
        return "?" + this._url.query;
    }
    set search(v) {
        // TODO: query stuff
        const url = this._url;
        if (v === "") {
            url.query = null;
            return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, {
            url,
            stateOverride: "query"
        });
    }
    get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
            return "";
        }
        return "#" + this._url.fragment;
    }
    set hash(v) {
        if (v === "") {
            this._url.fragment = null;
            return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, {
            url: this._url,
            stateOverride: "fragment"
        });
    }
    toJSON() {
        return this.href;
    }
};
}}),
"[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const conversions = __turbopack_context__.r("[project]/node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js [app-ssr] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js [app-ssr] (ecmascript)");
const Impl = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js [app-ssr] (ecmascript)");
const impl = utils.implSymbol;
function URL(url) {
    if (!this || this[impl] || !(this instanceof URL)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    }
    if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    }
    const args = [];
    for(let i = 0; i < arguments.length && i < 2; ++i){
        args[i] = arguments[i];
    }
    args[0] = conversions["USVString"](args[0]);
    if (args[1] !== undefined) {
        args[1] = conversions["USVString"](args[1]);
    }
    module.exports.setup(this, args);
}
URL.prototype.toJSON = function toJSON() {
    if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
    }
    const args = [];
    for(let i = 0; i < arguments.length && i < 0; ++i){
        args[i] = arguments[i];
    }
    return this[impl].toJSON.apply(this[impl], args);
};
Object.defineProperty(URL.prototype, "href", {
    get () {
        return this[impl].href;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
    },
    enumerable: true,
    configurable: true
});
URL.prototype.toString = function() {
    if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
    }
    return this.href;
};
Object.defineProperty(URL.prototype, "origin", {
    get () {
        return this[impl].origin;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "protocol", {
    get () {
        return this[impl].protocol;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "username", {
    get () {
        return this[impl].username;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "password", {
    get () {
        return this[impl].password;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "host", {
    get () {
        return this[impl].host;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "hostname", {
    get () {
        return this[impl].hostname;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "port", {
    get () {
        return this[impl].port;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "pathname", {
    get () {
        return this[impl].pathname;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "search", {
    get () {
        return this[impl].search;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "hash", {
    get () {
        return this[impl].hash;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
    },
    enumerable: true,
    configurable: true
});
module.exports = {
    is (obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
    },
    create (constructorArgs, privateData) {
        let obj = Object.create(URL.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
    },
    setup (obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
    },
    interface: URL,
    expose: {
        Window: {
            URL: URL
        },
        Worker: {
            URL: URL
        }
    }
};
}}),
"[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
exports.URL = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js [app-ssr] (ecmascript)").interface;
exports.serializeURL = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").serializeURL;
exports.serializeURLOrigin = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").serializeURLOrigin;
exports.basicURLParse = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").basicURLParse;
exports.setTheUsername = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").setTheUsername;
exports.setThePassword = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").setThePassword;
exports.serializeHost = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").serializeHost;
exports.serializeInteger = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").serializeInteger;
exports.parseURL = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").parseURL;
}}),
"[project]/node_modules/.pnpm/node-fetch@2.6.13/node_modules/node-fetch/lib/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "FetchError": ()=>FetchError,
    "Headers": ()=>Headers,
    "Request": ()=>Request,
    "Response": ()=>Response,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/http [external] (http, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/url [external] (url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$https__$5b$external$5d$__$28$https$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/https [external] (https, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/zlib [external] (zlib, cjs)");
;
;
;
;
;
;
// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js
// fix for "Readable" isn't a named export issue
const Readable = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable;
const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');
class Blob {
    constructor(){
        this[TYPE] = '';
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for(let i = 0; i < length; i++){
                const element = a[i];
                let buffer;
                if (element instanceof Buffer) {
                    buffer = element;
                } else if (ArrayBuffer.isView(element)) {
                    buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
                } else if (element instanceof ArrayBuffer) {
                    buffer = Buffer.from(element);
                } else if (element instanceof Blob) {
                    buffer = element[BUFFER];
                } else {
                    buffer = Buffer.from(typeof element === 'string' ? element : String(element));
                }
                size += buffer.length;
                buffers.push(buffer);
            }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== undefined && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
            this[TYPE] = type;
        }
    }
    get size() {
        return this[BUFFER].length;
    }
    get type() {
        return this[TYPE];
    }
    text() {
        return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
    }
    stream() {
        const readable = new Readable();
        readable._read = function() {};
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
    }
    toString() {
        return '[object Blob]';
    }
    slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === undefined) {
            relativeStart = 0;
        } else if (start < 0) {
            relativeStart = Math.max(size + start, 0);
        } else {
            relativeStart = Math.min(start, size);
        }
        if (end === undefined) {
            relativeEnd = size;
        } else if (end < 0) {
            relativeEnd = Math.max(size + end, 0);
        } else {
            relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], {
            type: arguments[2]
        });
        blob[BUFFER] = slicedBuffer;
        return blob;
    }
}
Object.defineProperties(Blob.prototype, {
    size: {
        enumerable: true
    },
    type: {
        enumerable: true
    },
    slice: {
        enumerable: true
    }
});
Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: 'Blob',
    writable: false,
    enumerable: false,
    configurable: true
});
/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */ /**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */ function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    // when err.type is `system`, err.code contains system error code
    if (systemError) {
        this.code = this.errno = systemError.code;
    }
    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
}
FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';
let convert;
try {
    convert = (()=>{
        const e = new Error("Cannot find module 'encoding'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })().convert;
} catch (e) {}
const INTERNALS = Symbol('Body internals');
// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].PassThrough;
/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */ function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
        // body is undefined or null
        body = null;
    } else if (isURLSearchParams(body)) {
        // body is a URLSearchParams
        body = Buffer.from(body.toString());
    } else if (isBlob(body)) ;
    else if (Buffer.isBuffer(body)) ;
    else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
        // body is ArrayBuffer
        body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
        // body is ArrayBufferView
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) ;
    else {
        // none of the above
        // coerce to string then buffer
        body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) {
        body.on('error', function(err) {
            const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
            _this[INTERNALS].error = error;
        });
    }
}
Body.prototype = {
    get body () {
        return this[INTERNALS].body;
    },
    get bodyUsed () {
        return this[INTERNALS].disturbed;
    },
    /**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */ arrayBuffer () {
        return consumeBody.call(this).then(function(buf) {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
    },
    /**
  * Return raw response as Blob
  *
  * @return Promise
  */ blob () {
        let ct = this.headers && this.headers.get('content-type') || '';
        return consumeBody.call(this).then(function(buf) {
            return Object.assign(// Prevent copying
            new Blob([], {
                type: ct.toLowerCase()
            }), {
                [BUFFER]: buf
            });
        });
    },
    /**
  * Decode response as json
  *
  * @return  Promise
  */ json () {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
            try {
                return JSON.parse(buffer.toString());
            } catch (err) {
                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
            }
        });
    },
    /**
  * Decode response as text
  *
  * @return  Promise
  */ text () {
        return consumeBody.call(this).then(function(buffer) {
            return buffer.toString();
        });
    },
    /**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */ buffer () {
        return consumeBody.call(this);
    },
    /**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */ textConverted () {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
            return convertBody(buffer, _this3.headers);
        });
    }
};
// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
    body: {
        enumerable: true
    },
    bodyUsed: {
        enumerable: true
    },
    arrayBuffer: {
        enumerable: true
    },
    blob: {
        enumerable: true
    },
    json: {
        enumerable: true
    },
    text: {
        enumerable: true
    }
});
Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)){
        // istanbul ignore else: future proof
        if (!(name in proto)) {
            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
            Object.defineProperty(proto, name, desc);
        }
    }
};
/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */ function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    // body is null
    if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
    }
    // body is blob
    if (isBlob(body)) {
        body = body.stream();
    }
    // body is buffer
    if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
    }
    // istanbul ignore if: should never happen
    if (!(body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"])) {
        return Body.Promise.resolve(Buffer.alloc(0));
    }
    // body is stream
    // get ready to actually consume the body
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        // allow timeout on slow response body
        if (_this4.timeout) {
            resTimeout = setTimeout(function() {
                abort = true;
                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
            }, _this4.timeout);
        }
        // handle stream errors
        body.on('error', function(err) {
            if (err.name === 'AbortError') {
                // if the request was aborted, reject with this Error
                abort = true;
                reject(err);
            } else {
                // other errors, such as incorrect content-encoding
                reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
            }
        });
        body.on('data', function(chunk) {
            if (abort || chunk === null) {
                return;
            }
            if (_this4.size && accumBytes + chunk.length > _this4.size) {
                abort = true;
                reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
                return;
            }
            accumBytes += chunk.length;
            accum.push(chunk);
        });
        body.on('end', function() {
            if (abort) {
                return;
            }
            clearTimeout(resTimeout);
            try {
                resolve(Buffer.concat(accum, accumBytes));
            } catch (err) {
                // handle streams that have accumulated too much data (issue #414)
                reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
            }
        });
    });
}
/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */ function convertBody(buffer, headers) {
    if (typeof convert !== 'function') {
        throw new Error('The package `encoding` must be installed to use the textConverted() function');
    }
    const ct = headers.get('content-type');
    let charset = 'utf-8';
    let res, str;
    // header
    if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
    }
    // no charset in content type, peek at response body for at most 1024 bytes
    str = buffer.slice(0, 1024).toString();
    // html5
    if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    // html4
    if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
            res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
            if (res) {
                res.pop(); // drop last quote
            }
        }
        if (res) {
            res = /charset=(.*)/i.exec(res.pop());
        }
    }
    // xml
    if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    // found charset
    if (res) {
        charset = res.pop();
        // prevent decode issues when sites use incorrect encoding
        // ref: https://hsivonen.fi/encoding-menu/
        if (charset === 'gb2312' || charset === 'gbk') {
            charset = 'gb18030';
        }
    }
    // turn raw buffers into a single utf-8 buffer
    return convert(buffer, 'UTF-8', charset).toString();
}
/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */ function isURLSearchParams(obj) {
    // Duck-typing as a necessary condition.
    if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
        return false;
    }
    // Brand-checking and more duck-typing as optional condition.
    return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}
/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */ function isBlob(obj) {
    return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */ function clone(instance) {
    let p1, p2;
    let body = instance.body;
    // don't allow cloning a used body
    if (instance.bodyUsed) {
        throw new Error('cannot clone body after it is used');
    }
    // check that body is a stream and not form-data object
    // note: we can't clone the form-data object without having it as a dependency
    if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"] && typeof body.getBoundary !== 'function') {
        // tee instance body
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        // set instance body to teed body and return the other teed body
        instance[INTERNALS].body = p1;
        body = p2;
    }
    return body;
}
/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */ function extractContentType(body) {
    if (body === null) {
        // body is null
        return null;
    } else if (typeof body === 'string') {
        // body is string
        return 'text/plain;charset=UTF-8';
    } else if (isURLSearchParams(body)) {
        // body is a URLSearchParams
        return 'application/x-www-form-urlencoded;charset=UTF-8';
    } else if (isBlob(body)) {
        // body is blob
        return body.type || null;
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        return null;
    } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
        // body is ArrayBuffer
        return null;
    } else if (ArrayBuffer.isView(body)) {
        // body is ArrayBufferView
        return null;
    } else if (typeof body.getBoundary === 'function') {
        // detect form data input from form-data module
        return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) {
        // body is stream
        // can't really do much about this
        return null;
    } else {
        // Body constructor defaults other things to string
        return 'text/plain;charset=UTF-8';
    }
}
/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */ function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
        // body is null
        return 0;
    } else if (isBlob(body)) {
        return body.size;
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        return body.length;
    } else if (body && typeof body.getLengthSync === 'function') {
        // detect form data input from form-data module
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
            // 2.x
            return body.getLengthSync();
        }
        return null;
    } else {
        // body is stream
        return null;
    }
}
/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */ function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
        // body is null
        dest.end();
    } else if (isBlob(body)) {
        body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        dest.write(body);
        dest.end();
    } else {
        // body is stream
        body.pipe(dest);
    }
}
// expose Promise
Body.Promise = ("TURBOPACK ident replacement", globalThis).Promise;
/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */ const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === '') {
        throw new TypeError(`${name} is not a legal HTTP header name`);
    }
}
function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
    }
}
/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */ function find(map, name) {
    name = name.toLowerCase();
    for(const key in map){
        if (key.toLowerCase() === name) {
            return key;
        }
    }
    return undefined;
}
const MAP = Symbol('map');
class Headers {
    /**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */ constructor(){
        let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
        this[MAP] = Object.create(null);
        if (init instanceof Headers) {
            const rawHeaders = init.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames){
                for (const value of rawHeaders[headerName]){
                    this.append(headerName, value);
                }
            }
            return;
        }
        // We don't worry about converting prop to ByteString here as append()
        // will handle it.
        if (init == null) ;
        else if (typeof init === 'object') {
            const method = init[Symbol.iterator];
            if (method != null) {
                if (typeof method !== 'function') {
                    throw new TypeError('Header pairs must be iterable');
                }
                // sequence<sequence<ByteString>>
                // Note: per spec we have to first exhaust the lists then process them
                const pairs = [];
                for (const pair of init){
                    if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
                        throw new TypeError('Each header pair must be iterable');
                    }
                    pairs.push(Array.from(pair));
                }
                for (const pair of pairs){
                    if (pair.length !== 2) {
                        throw new TypeError('Each header pair must be a name/value tuple');
                    }
                    this.append(pair[0], pair[1]);
                }
            } else {
                // record<ByteString, ByteString>
                for (const key of Object.keys(init)){
                    const value = init[key];
                    this.append(key, value);
                }
            }
        } else {
            throw new TypeError('Provided initializer must be an object');
        }
    }
    /**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */ get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === undefined) {
            return null;
        }
        return this[MAP][key].join(', ');
    }
    /**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */ forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        let pairs = getHeaders(this);
        let i = 0;
        while(i < pairs.length){
            var _pairs$i = pairs[i];
            const name = _pairs$i[0], value = _pairs$i[1];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
            i++;
        }
    }
    /**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */ set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== undefined ? key : name] = [
            value
        ];
    }
    /**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */ append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== undefined) {
            this[MAP][key].push(value);
        } else {
            this[MAP][name] = [
                value
            ];
        }
    }
    /**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */ has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== undefined;
    }
    /**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */ delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== undefined) {
            delete this[MAP][key];
        }
    }
    /**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */ raw() {
        return this[MAP];
    }
    /**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */ keys() {
        return createHeadersIterator(this, 'key');
    }
    /**
  * Get an iterator on values.
  *
  * @return  Iterator
  */ values() {
        return createHeadersIterator(this, 'value');
    }
    /**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */ [Symbol.iterator]() {
        return createHeadersIterator(this, 'key+value');
    }
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];
Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: 'Headers',
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperties(Headers.prototype, {
    get: {
        enumerable: true
    },
    forEach: {
        enumerable: true
    },
    set: {
        enumerable: true
    },
    append: {
        enumerable: true
    },
    has: {
        enumerable: true
    },
    delete: {
        enumerable: true
    },
    keys: {
        enumerable: true
    },
    values: {
        enumerable: true
    },
    entries: {
        enumerable: true
    }
});
function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === 'key' ? function(k) {
        return k.toLowerCase();
    } : kind === 'value' ? function(k) {
        return headers[MAP][k].join(', ');
    } : function(k) {
        return [
            k.toLowerCase(),
            headers[MAP][k].join(', ')
        ];
    });
}
const INTERNAL = Symbol('internal');
function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
        target,
        kind,
        index: 0
    };
    return iterator;
}
const HeadersIteratorPrototype = Object.setPrototypeOf({
    next () {
        // istanbul ignore if
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
            throw new TypeError('Value of `this` is not a HeadersIterator');
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
            return {
                value: undefined,
                done: true
            };
        }
        this[INTERNAL].index = index + 1;
        return {
            value: values[index],
            done: false
        };
    }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: 'HeadersIterator',
    writable: false,
    enumerable: false,
    configurable: true
});
/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */ function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({
        __proto__: null
    }, headers[MAP]);
    // http.request() only supports string as Host header. This hack makes
    // specifying custom Host header possible.
    const hostHeaderKey = find(headers[MAP], 'Host');
    if (hostHeaderKey !== undefined) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
}
/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */ function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)){
        if (invalidTokenRegex.test(name)) {
            continue;
        }
        if (Array.isArray(obj[name])) {
            for (const val of obj[name]){
                if (invalidHeaderCharRegex.test(val)) {
                    continue;
                }
                if (headers[MAP][name] === undefined) {
                    headers[MAP][name] = [
                        val
                    ];
                } else {
                    headers[MAP][name].push(val);
                }
            }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
            headers[MAP][name] = [
                obj[name]
            ];
        }
    }
    return headers;
}
const INTERNALS$1 = Symbol('Response internals');
// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__["default"].STATUS_CODES;
/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */ class Response {
    constructor(){
        let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has('Content-Type')) {
            const contentType = extractContentType(body);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        this[INTERNALS$1] = {
            url: opts.url,
            status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers,
            counter: opts.counter
        };
    }
    get url() {
        return this[INTERNALS$1].url || '';
    }
    get status() {
        return this[INTERNALS$1].status;
    }
    /**
  * Convenience property representing if the request ended normally
  */ get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
        return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
        return this[INTERNALS$1].statusText;
    }
    get headers() {
        return this[INTERNALS$1].headers;
    }
    /**
  * Clone this response
  *
  * @return  Response
  */ clone() {
        return new Response(clone(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected
        });
    }
}
Body.mixIn(Response.prototype);
Object.defineProperties(Response.prototype, {
    url: {
        enumerable: true
    },
    status: {
        enumerable: true
    },
    ok: {
        enumerable: true
    },
    redirected: {
        enumerable: true
    },
    statusText: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    clone: {
        enumerable: true
    }
});
Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: 'Response',
    writable: false,
    enumerable: false,
    configurable: true
});
const INTERNALS$2 = Symbol('Request internals');
const URL = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].URL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].URL;
// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].parse;
const format_url = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].format;
/**
 * Wrapper around `new URL` to handle arbitrary URLs
 *
 * @param  {string} urlStr
 * @return {void}
 */ function parseURL(urlStr) {
    /*
 	Check whether the URL is absolute or not
 		Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
 	Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
 */ if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL(urlStr).toString();
    }
    // Fallback to old implementation for arbitrary URLs
    return parse_url(urlStr);
}
const streamDestructionSupported = 'destroy' in __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable.prototype;
/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */ function isRequest(input) {
    return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}
function isAbortSignal(signal) {
    const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === 'AbortSignal');
}
/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */ class Request {
    constructor(input){
        let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let parsedURL;
        // normalize input
        if (!isRequest(input)) {
            if (input && input.href) {
                // in order to support Node.js' Url objects; though WHATWG's URL objects
                // will fall into this branch also (since their `toString()` will return
                // `href` property anyway)
                parsedURL = parseURL(input.href);
            } else {
                // coerce input to a string before attempting to parse
                parsedURL = parseURL(`${input}`);
            }
            input = {};
        } else {
            parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || 'GET';
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
            throw new TypeError('Request with GET/HEAD method cannot have body');
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
            timeout: init.timeout || input.timeout || 0,
            size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has('Content-Type')) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ('signal' in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
            throw new TypeError('Expected signal to be an instanceof AbortSignal');
        }
        this[INTERNALS$2] = {
            method,
            redirect: init.redirect || input.redirect || 'follow',
            headers,
            parsedURL,
            signal
        };
        // node-fetch-only options
        this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
        this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
    }
    get method() {
        return this[INTERNALS$2].method;
    }
    get url() {
        return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
        return this[INTERNALS$2].headers;
    }
    get redirect() {
        return this[INTERNALS$2].redirect;
    }
    get signal() {
        return this[INTERNALS$2].signal;
    }
    /**
  * Clone this request
  *
  * @return  Request
  */ clone() {
        return new Request(this);
    }
}
Body.mixIn(Request.prototype);
Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: 'Request',
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperties(Request.prototype, {
    method: {
        enumerable: true
    },
    url: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    redirect: {
        enumerable: true
    },
    clone: {
        enumerable: true
    },
    signal: {
        enumerable: true
    }
});
/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */ function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    // fetch step 1.3
    if (!headers.has('Accept')) {
        headers.set('Accept', '*/*');
    }
    // Basic fetch
    if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError('Only absolute URLs are supported');
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError('Only HTTP(S) protocols are supported');
    }
    if (request.signal && request.body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable && !streamDestructionSupported) {
        throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
    }
    // HTTP-network-or-cache fetch steps 2.4-2.7
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = '0';
    }
    if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === 'number') {
            contentLengthValue = String(totalBytes);
        }
    }
    if (contentLengthValue) {
        headers.set('Content-Length', contentLengthValue);
    }
    // HTTP-network-or-cache fetch step 2.11
    if (!headers.has('User-Agent')) {
        headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
    }
    // HTTP-network-or-cache fetch step 2.15
    if (request.compress && !headers.has('Accept-Encoding')) {
        headers.set('Accept-Encoding', 'gzip,deflate');
    }
    let agent = request.agent;
    if (typeof agent === 'function') {
        agent = agent(parsedURL);
    }
    // HTTP-network fetch step 4.2
    // chunked encoding is handled by Node.js
    return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
    });
}
/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */ /**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */ function AbortError(message) {
    Error.call(this, message);
    this.type = 'aborted';
    this.message = message;
    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
}
AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';
const URL$1 = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].URL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].URL;
// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].PassThrough;
const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
};
/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */ const isSameProtocol = function isSameProtocol(destination, original) {
    const orig = new URL$1(original).protocol;
    const dest = new URL$1(destination).protocol;
    return orig === dest;
};
/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */ function fetch(url, opts) {
    // allow custom promise
    if (!fetch.Promise) {
        throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
    }
    Body.Promise = fetch.Promise;
    // wrap http.request into fetch
    return new fetch.Promise(function(resolve, reject) {
        // build request object
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === 'https:' ? __TURBOPACK__imported__module__$5b$externals$5d2f$https__$5b$external$5d$__$28$https$2c$__cjs$29$__["default"] : __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__["default"]).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort() {
            let error = new AbortError('The user aborted a request.');
            reject(error);
            if (request.body && request.body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable) {
                destroyStream(request.body, error);
            }
            if (!response || !response.body) return;
            response.body.emit('error', error);
        };
        if (signal && signal.aborted) {
            abort();
            return;
        }
        const abortAndFinalize = function abortAndFinalize() {
            abort();
            finalize();
        };
        // send request
        const req = send(options);
        let reqTimeout;
        if (signal) {
            signal.addEventListener('abort', abortAndFinalize);
        }
        function finalize() {
            req.abort();
            if (signal) signal.removeEventListener('abort', abortAndFinalize);
            clearTimeout(reqTimeout);
        }
        if (request.timeout) {
            req.once('socket', function(socket) {
                reqTimeout = setTimeout(function() {
                    reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
                    finalize();
                }, request.timeout);
            });
        }
        req.on('error', function(err) {
            reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
            if (response && response.body) {
                destroyStream(response.body, err);
            }
            finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
            if (signal && signal.aborted) {
                return;
            }
            if (response && response.body) {
                destroyStream(response.body, err);
            }
        });
        /* c8 ignore next 18 */ if (parseInt(process.version.substring(1)) < 14) {
            // Before Node.js 14, pipeline() does not fully support async iterators and does not always
            // properly handle when the socket close/end events are out of order.
            req.on('socket', function(s) {
                s.addListener('close', function(hadError) {
                    // if a data listener is still present we didn't end cleanly
                    const hasDataListener = s.listenerCount('data') > 0;
                    // if end happened before close but the socket didn't emit an error, do it now
                    if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                        const err = new Error('Premature close');
                        err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                        response.body.emit('error', err);
                    }
                });
            });
        }
        req.on('response', function(res) {
            clearTimeout(reqTimeout);
            const headers = createHeadersLenient(res.headers);
            // HTTP fetch step 5
            if (fetch.isRedirect(res.statusCode)) {
                // HTTP fetch step 5.2
                const location = headers.get('Location');
                // HTTP fetch step 5.3
                let locationURL = null;
                try {
                    locationURL = location === null ? null : new URL$1(location, request.url).toString();
                } catch (err) {
                    // error here can only be invalid URL in Location: header
                    // do not throw when options.redirect == manual
                    // let the user extract the errorneous redirect URL
                    if (request.redirect !== 'manual') {
                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
                        finalize();
                        return;
                    }
                }
                // HTTP fetch step 5.5
                switch(request.redirect){
                    case 'error':
                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
                        finalize();
                        return;
                    case 'manual':
                        // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
                        if (locationURL !== null) {
                            // handle corrupted header
                            try {
                                headers.set('Location', locationURL);
                            } catch (err) {
                                // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
                                reject(err);
                            }
                        }
                        break;
                    case 'follow':
                        // HTTP-redirect fetch step 2
                        if (locationURL === null) {
                            break;
                        }
                        // HTTP-redirect fetch step 5
                        if (request.counter >= request.follow) {
                            reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                            finalize();
                            return;
                        }
                        // HTTP-redirect fetch step 6 (counter increment)
                        // Create a new Request object.
                        const requestOpts = {
                            headers: new Headers(request.headers),
                            follow: request.follow,
                            counter: request.counter + 1,
                            agent: request.agent,
                            compress: request.compress,
                            method: request.method,
                            body: request.body,
                            signal: request.signal,
                            timeout: request.timeout,
                            size: request.size
                        };
                        if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                            for (const name of [
                                'authorization',
                                'www-authenticate',
                                'cookie',
                                'cookie2'
                            ]){
                                requestOpts.headers.delete(name);
                            }
                        }
                        // HTTP-redirect fetch step 9
                        if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                            reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                            finalize();
                            return;
                        }
                        // HTTP-redirect fetch step 11
                        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
                            requestOpts.method = 'GET';
                            requestOpts.body = undefined;
                            requestOpts.headers.delete('content-length');
                        }
                        // HTTP-redirect fetch step 15
                        resolve(fetch(new Request(locationURL, requestOpts)));
                        finalize();
                        return;
                }
            }
            // prepare response
            res.once('end', function() {
                if (signal) signal.removeEventListener('abort', abortAndFinalize);
            });
            let body = res.pipe(new PassThrough$1());
            const response_options = {
                url: request.url,
                status: res.statusCode,
                statusText: res.statusMessage,
                headers: headers,
                size: request.size,
                timeout: request.timeout,
                counter: request.counter
            };
            // HTTP-network fetch step 12.1.1.3
            const codings = headers.get('Content-Encoding');
            // HTTP-network fetch step 12.1.1.4: handle content codings
            // in following scenarios we ignore compression support
            // 1. compression support is disabled
            // 2. HEAD request
            // 3. no Content-Encoding header
            // 4. no content response (204)
            // 5. content not modified response (304)
            if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // For Node v6+
            // Be less strict when decoding compressed responses, since sometimes
            // servers send slightly invalid responses that are still accepted
            // by common browsers.
            // Always using Z_SYNC_FLUSH is what cURL does.
            const zlibOptions = {
                flush: __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].Z_SYNC_FLUSH,
                finishFlush: __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].Z_SYNC_FLUSH
            };
            // for gzip
            if (codings == 'gzip' || codings == 'x-gzip') {
                body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createGunzip(zlibOptions));
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // for deflate
            if (codings == 'deflate' || codings == 'x-deflate') {
                // handle the infamous raw deflate response from old servers
                // a hack for old IIS and Apache servers
                const raw = res.pipe(new PassThrough$1());
                raw.once('data', function(chunk) {
                    // see http://stackoverflow.com/questions/37519828
                    if ((chunk[0] & 0x0F) === 0x08) {
                        body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createInflate());
                    } else {
                        body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createInflateRaw());
                    }
                    response = new Response(body, response_options);
                    resolve(response);
                });
                raw.on('end', function() {
                    // some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.
                    if (!response) {
                        response = new Response(body, response_options);
                        resolve(response);
                    }
                });
                return;
            }
            // for br
            if (codings == 'br' && typeof __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createBrotliDecompress === 'function') {
                body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createBrotliDecompress());
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // otherwise, use response as-is
            response = new Response(body, response_options);
            resolve(response);
        });
        writeToStream(req, request);
    });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on('socket', function(s) {
        socket = s;
    });
    request.on('response', function(response) {
        const headers = response.headers;
        if (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {
            response.once('close', function(hadError) {
                // tests for socket presence, as in some situations the
                // the 'socket' event is not triggered for the request
                // (happens in deno), avoids `TypeError`
                // if a data listener is still present we didn't end cleanly
                const hasDataListener = socket && socket.listenerCount('data') > 0;
                if (hasDataListener && !hadError) {
                    const err = new Error('Premature close');
                    err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                    errorCallback(err);
                }
            });
        }
    });
}
function destroyStream(stream, err) {
    if (stream.destroy) {
        stream.destroy(err);
    } else {
        // node < 8
        stream.emit('error', err);
        stream.end();
    }
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */ fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};
// expose Promise
fetch.Promise = ("TURBOPACK ident replacement", globalThis).Promise;
const __TURBOPACK__default__export__ = fetch;
;
}),
"[project]/node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/lib/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "AbortError": ()=>AbortError,
    "FetchError": ()=>FetchError,
    "Headers": ()=>Headers,
    "Request": ()=>Request,
    "Response": ()=>Response,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/http [external] (http, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/url [external] (url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$https__$5b$external$5d$__$28$https$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/https [external] (https, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/zlib [external] (zlib, cjs)");
;
;
;
;
;
;
// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js
// fix for "Readable" isn't a named export issue
const Readable = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable;
const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');
class Blob {
    constructor(){
        this[TYPE] = '';
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for(let i = 0; i < length; i++){
                const element = a[i];
                let buffer;
                if (element instanceof Buffer) {
                    buffer = element;
                } else if (ArrayBuffer.isView(element)) {
                    buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
                } else if (element instanceof ArrayBuffer) {
                    buffer = Buffer.from(element);
                } else if (element instanceof Blob) {
                    buffer = element[BUFFER];
                } else {
                    buffer = Buffer.from(typeof element === 'string' ? element : String(element));
                }
                size += buffer.length;
                buffers.push(buffer);
            }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== undefined && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
            this[TYPE] = type;
        }
    }
    get size() {
        return this[BUFFER].length;
    }
    get type() {
        return this[TYPE];
    }
    text() {
        return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
    }
    stream() {
        const readable = new Readable();
        readable._read = function() {};
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
    }
    toString() {
        return '[object Blob]';
    }
    slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === undefined) {
            relativeStart = 0;
        } else if (start < 0) {
            relativeStart = Math.max(size + start, 0);
        } else {
            relativeStart = Math.min(start, size);
        }
        if (end === undefined) {
            relativeEnd = size;
        } else if (end < 0) {
            relativeEnd = Math.max(size + end, 0);
        } else {
            relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], {
            type: arguments[2]
        });
        blob[BUFFER] = slicedBuffer;
        return blob;
    }
}
Object.defineProperties(Blob.prototype, {
    size: {
        enumerable: true
    },
    type: {
        enumerable: true
    },
    slice: {
        enumerable: true
    }
});
Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: 'Blob',
    writable: false,
    enumerable: false,
    configurable: true
});
/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */ /**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */ function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    // when err.type is `system`, err.code contains system error code
    if (systemError) {
        this.code = this.errno = systemError.code;
    }
    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
}
FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';
let convert;
try {
    convert = (()=>{
        const e = new Error("Cannot find module 'encoding'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })().convert;
} catch (e) {}
const INTERNALS = Symbol('Body internals');
// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].PassThrough;
/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */ function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
        // body is undefined or null
        body = null;
    } else if (isURLSearchParams(body)) {
        // body is a URLSearchParams
        body = Buffer.from(body.toString());
    } else if (isBlob(body)) ;
    else if (Buffer.isBuffer(body)) ;
    else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
        // body is ArrayBuffer
        body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
        // body is ArrayBufferView
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) ;
    else {
        // none of the above
        // coerce to string then buffer
        body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) {
        body.on('error', function(err) {
            const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
            _this[INTERNALS].error = error;
        });
    }
}
Body.prototype = {
    get body () {
        return this[INTERNALS].body;
    },
    get bodyUsed () {
        return this[INTERNALS].disturbed;
    },
    /**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */ arrayBuffer () {
        return consumeBody.call(this).then(function(buf) {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
    },
    /**
  * Return raw response as Blob
  *
  * @return Promise
  */ blob () {
        let ct = this.headers && this.headers.get('content-type') || '';
        return consumeBody.call(this).then(function(buf) {
            return Object.assign(// Prevent copying
            new Blob([], {
                type: ct.toLowerCase()
            }), {
                [BUFFER]: buf
            });
        });
    },
    /**
  * Decode response as json
  *
  * @return  Promise
  */ json () {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
            try {
                return JSON.parse(buffer.toString());
            } catch (err) {
                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
            }
        });
    },
    /**
  * Decode response as text
  *
  * @return  Promise
  */ text () {
        return consumeBody.call(this).then(function(buffer) {
            return buffer.toString();
        });
    },
    /**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */ buffer () {
        return consumeBody.call(this);
    },
    /**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */ textConverted () {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
            return convertBody(buffer, _this3.headers);
        });
    }
};
// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
    body: {
        enumerable: true
    },
    bodyUsed: {
        enumerable: true
    },
    arrayBuffer: {
        enumerable: true
    },
    blob: {
        enumerable: true
    },
    json: {
        enumerable: true
    },
    text: {
        enumerable: true
    }
});
Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)){
        // istanbul ignore else: future proof
        if (!(name in proto)) {
            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
            Object.defineProperty(proto, name, desc);
        }
    }
};
/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */ function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    // body is null
    if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
    }
    // body is blob
    if (isBlob(body)) {
        body = body.stream();
    }
    // body is buffer
    if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
    }
    // istanbul ignore if: should never happen
    if (!(body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"])) {
        return Body.Promise.resolve(Buffer.alloc(0));
    }
    // body is stream
    // get ready to actually consume the body
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        // allow timeout on slow response body
        if (_this4.timeout) {
            resTimeout = setTimeout(function() {
                abort = true;
                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
            }, _this4.timeout);
        }
        // handle stream errors
        body.on('error', function(err) {
            if (err.name === 'AbortError') {
                // if the request was aborted, reject with this Error
                abort = true;
                reject(err);
            } else {
                // other errors, such as incorrect content-encoding
                reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
            }
        });
        body.on('data', function(chunk) {
            if (abort || chunk === null) {
                return;
            }
            if (_this4.size && accumBytes + chunk.length > _this4.size) {
                abort = true;
                reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
                return;
            }
            accumBytes += chunk.length;
            accum.push(chunk);
        });
        body.on('end', function() {
            if (abort) {
                return;
            }
            clearTimeout(resTimeout);
            try {
                resolve(Buffer.concat(accum, accumBytes));
            } catch (err) {
                // handle streams that have accumulated too much data (issue #414)
                reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
            }
        });
    });
}
/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */ function convertBody(buffer, headers) {
    if (typeof convert !== 'function') {
        throw new Error('The package `encoding` must be installed to use the textConverted() function');
    }
    const ct = headers.get('content-type');
    let charset = 'utf-8';
    let res, str;
    // header
    if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
    }
    // no charset in content type, peek at response body for at most 1024 bytes
    str = buffer.slice(0, 1024).toString();
    // html5
    if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    // html4
    if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
            res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
            if (res) {
                res.pop(); // drop last quote
            }
        }
        if (res) {
            res = /charset=(.*)/i.exec(res.pop());
        }
    }
    // xml
    if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    // found charset
    if (res) {
        charset = res.pop();
        // prevent decode issues when sites use incorrect encoding
        // ref: https://hsivonen.fi/encoding-menu/
        if (charset === 'gb2312' || charset === 'gbk') {
            charset = 'gb18030';
        }
    }
    // turn raw buffers into a single utf-8 buffer
    return convert(buffer, 'UTF-8', charset).toString();
}
/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */ function isURLSearchParams(obj) {
    // Duck-typing as a necessary condition.
    if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
        return false;
    }
    // Brand-checking and more duck-typing as optional condition.
    return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}
/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */ function isBlob(obj) {
    return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */ function clone(instance) {
    let p1, p2;
    let body = instance.body;
    // don't allow cloning a used body
    if (instance.bodyUsed) {
        throw new Error('cannot clone body after it is used');
    }
    // check that body is a stream and not form-data object
    // note: we can't clone the form-data object without having it as a dependency
    if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"] && typeof body.getBoundary !== 'function') {
        // tee instance body
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        // set instance body to teed body and return the other teed body
        instance[INTERNALS].body = p1;
        body = p2;
    }
    return body;
}
/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */ function extractContentType(body) {
    if (body === null) {
        // body is null
        return null;
    } else if (typeof body === 'string') {
        // body is string
        return 'text/plain;charset=UTF-8';
    } else if (isURLSearchParams(body)) {
        // body is a URLSearchParams
        return 'application/x-www-form-urlencoded;charset=UTF-8';
    } else if (isBlob(body)) {
        // body is blob
        return body.type || null;
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        return null;
    } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
        // body is ArrayBuffer
        return null;
    } else if (ArrayBuffer.isView(body)) {
        // body is ArrayBufferView
        return null;
    } else if (typeof body.getBoundary === 'function') {
        // detect form data input from form-data module
        return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) {
        // body is stream
        // can't really do much about this
        return null;
    } else {
        // Body constructor defaults other things to string
        return 'text/plain;charset=UTF-8';
    }
}
/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */ function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
        // body is null
        return 0;
    } else if (isBlob(body)) {
        return body.size;
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        return body.length;
    } else if (body && typeof body.getLengthSync === 'function') {
        // detect form data input from form-data module
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
            // 2.x
            return body.getLengthSync();
        }
        return null;
    } else {
        // body is stream
        return null;
    }
}
/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */ function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
        // body is null
        dest.end();
    } else if (isBlob(body)) {
        body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        dest.write(body);
        dest.end();
    } else {
        // body is stream
        body.pipe(dest);
    }
}
// expose Promise
Body.Promise = ("TURBOPACK ident replacement", globalThis).Promise;
/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */ const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === '') {
        throw new TypeError(`${name} is not a legal HTTP header name`);
    }
}
function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
    }
}
/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */ function find(map, name) {
    name = name.toLowerCase();
    for(const key in map){
        if (key.toLowerCase() === name) {
            return key;
        }
    }
    return undefined;
}
const MAP = Symbol('map');
class Headers {
    /**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */ constructor(){
        let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
        this[MAP] = Object.create(null);
        if (init instanceof Headers) {
            const rawHeaders = init.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames){
                for (const value of rawHeaders[headerName]){
                    this.append(headerName, value);
                }
            }
            return;
        }
        // We don't worry about converting prop to ByteString here as append()
        // will handle it.
        if (init == null) ;
        else if (typeof init === 'object') {
            const method = init[Symbol.iterator];
            if (method != null) {
                if (typeof method !== 'function') {
                    throw new TypeError('Header pairs must be iterable');
                }
                // sequence<sequence<ByteString>>
                // Note: per spec we have to first exhaust the lists then process them
                const pairs = [];
                for (const pair of init){
                    if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
                        throw new TypeError('Each header pair must be iterable');
                    }
                    pairs.push(Array.from(pair));
                }
                for (const pair of pairs){
                    if (pair.length !== 2) {
                        throw new TypeError('Each header pair must be a name/value tuple');
                    }
                    this.append(pair[0], pair[1]);
                }
            } else {
                // record<ByteString, ByteString>
                for (const key of Object.keys(init)){
                    const value = init[key];
                    this.append(key, value);
                }
            }
        } else {
            throw new TypeError('Provided initializer must be an object');
        }
    }
    /**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */ get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === undefined) {
            return null;
        }
        return this[MAP][key].join(', ');
    }
    /**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */ forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        let pairs = getHeaders(this);
        let i = 0;
        while(i < pairs.length){
            var _pairs$i = pairs[i];
            const name = _pairs$i[0], value = _pairs$i[1];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
            i++;
        }
    }
    /**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */ set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== undefined ? key : name] = [
            value
        ];
    }
    /**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */ append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== undefined) {
            this[MAP][key].push(value);
        } else {
            this[MAP][name] = [
                value
            ];
        }
    }
    /**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */ has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== undefined;
    }
    /**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */ delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== undefined) {
            delete this[MAP][key];
        }
    }
    /**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */ raw() {
        return this[MAP];
    }
    /**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */ keys() {
        return createHeadersIterator(this, 'key');
    }
    /**
  * Get an iterator on values.
  *
  * @return  Iterator
  */ values() {
        return createHeadersIterator(this, 'value');
    }
    /**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */ [Symbol.iterator]() {
        return createHeadersIterator(this, 'key+value');
    }
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];
Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: 'Headers',
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperties(Headers.prototype, {
    get: {
        enumerable: true
    },
    forEach: {
        enumerable: true
    },
    set: {
        enumerable: true
    },
    append: {
        enumerable: true
    },
    has: {
        enumerable: true
    },
    delete: {
        enumerable: true
    },
    keys: {
        enumerable: true
    },
    values: {
        enumerable: true
    },
    entries: {
        enumerable: true
    }
});
function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === 'key' ? function(k) {
        return k.toLowerCase();
    } : kind === 'value' ? function(k) {
        return headers[MAP][k].join(', ');
    } : function(k) {
        return [
            k.toLowerCase(),
            headers[MAP][k].join(', ')
        ];
    });
}
const INTERNAL = Symbol('internal');
function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
        target,
        kind,
        index: 0
    };
    return iterator;
}
const HeadersIteratorPrototype = Object.setPrototypeOf({
    next () {
        // istanbul ignore if
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
            throw new TypeError('Value of `this` is not a HeadersIterator');
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
            return {
                value: undefined,
                done: true
            };
        }
        this[INTERNAL].index = index + 1;
        return {
            value: values[index],
            done: false
        };
    }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: 'HeadersIterator',
    writable: false,
    enumerable: false,
    configurable: true
});
/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */ function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({
        __proto__: null
    }, headers[MAP]);
    // http.request() only supports string as Host header. This hack makes
    // specifying custom Host header possible.
    const hostHeaderKey = find(headers[MAP], 'Host');
    if (hostHeaderKey !== undefined) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
}
/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */ function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)){
        if (invalidTokenRegex.test(name)) {
            continue;
        }
        if (Array.isArray(obj[name])) {
            for (const val of obj[name]){
                if (invalidHeaderCharRegex.test(val)) {
                    continue;
                }
                if (headers[MAP][name] === undefined) {
                    headers[MAP][name] = [
                        val
                    ];
                } else {
                    headers[MAP][name].push(val);
                }
            }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
            headers[MAP][name] = [
                obj[name]
            ];
        }
    }
    return headers;
}
const INTERNALS$1 = Symbol('Response internals');
// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__["default"].STATUS_CODES;
/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */ class Response {
    constructor(){
        let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has('Content-Type')) {
            const contentType = extractContentType(body);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        this[INTERNALS$1] = {
            url: opts.url,
            status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers,
            counter: opts.counter
        };
    }
    get url() {
        return this[INTERNALS$1].url || '';
    }
    get status() {
        return this[INTERNALS$1].status;
    }
    /**
  * Convenience property representing if the request ended normally
  */ get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
        return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
        return this[INTERNALS$1].statusText;
    }
    get headers() {
        return this[INTERNALS$1].headers;
    }
    /**
  * Clone this response
  *
  * @return  Response
  */ clone() {
        return new Response(clone(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected
        });
    }
}
Body.mixIn(Response.prototype);
Object.defineProperties(Response.prototype, {
    url: {
        enumerable: true
    },
    status: {
        enumerable: true
    },
    ok: {
        enumerable: true
    },
    redirected: {
        enumerable: true
    },
    statusText: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    clone: {
        enumerable: true
    }
});
Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: 'Response',
    writable: false,
    enumerable: false,
    configurable: true
});
const INTERNALS$2 = Symbol('Request internals');
const URL = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].URL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].URL;
// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].parse;
const format_url = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].format;
/**
 * Wrapper around `new URL` to handle arbitrary URLs
 *
 * @param  {string} urlStr
 * @return {void}
 */ function parseURL(urlStr) {
    /*
 	Check whether the URL is absolute or not
 		Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
 	Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
 */ if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL(urlStr).toString();
    }
    // Fallback to old implementation for arbitrary URLs
    return parse_url(urlStr);
}
const streamDestructionSupported = 'destroy' in __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable.prototype;
/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */ function isRequest(input) {
    return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}
function isAbortSignal(signal) {
    const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === 'AbortSignal');
}
/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */ class Request {
    constructor(input){
        let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let parsedURL;
        // normalize input
        if (!isRequest(input)) {
            if (input && input.href) {
                // in order to support Node.js' Url objects; though WHATWG's URL objects
                // will fall into this branch also (since their `toString()` will return
                // `href` property anyway)
                parsedURL = parseURL(input.href);
            } else {
                // coerce input to a string before attempting to parse
                parsedURL = parseURL(`${input}`);
            }
            input = {};
        } else {
            parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || 'GET';
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
            throw new TypeError('Request with GET/HEAD method cannot have body');
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
            timeout: init.timeout || input.timeout || 0,
            size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has('Content-Type')) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ('signal' in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
            throw new TypeError('Expected signal to be an instanceof AbortSignal');
        }
        this[INTERNALS$2] = {
            method,
            redirect: init.redirect || input.redirect || 'follow',
            headers,
            parsedURL,
            signal
        };
        // node-fetch-only options
        this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
        this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
    }
    get method() {
        return this[INTERNALS$2].method;
    }
    get url() {
        return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
        return this[INTERNALS$2].headers;
    }
    get redirect() {
        return this[INTERNALS$2].redirect;
    }
    get signal() {
        return this[INTERNALS$2].signal;
    }
    /**
  * Clone this request
  *
  * @return  Request
  */ clone() {
        return new Request(this);
    }
}
Body.mixIn(Request.prototype);
Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: 'Request',
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperties(Request.prototype, {
    method: {
        enumerable: true
    },
    url: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    redirect: {
        enumerable: true
    },
    clone: {
        enumerable: true
    },
    signal: {
        enumerable: true
    }
});
/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */ function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    // fetch step 1.3
    if (!headers.has('Accept')) {
        headers.set('Accept', '*/*');
    }
    // Basic fetch
    if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError('Only absolute URLs are supported');
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError('Only HTTP(S) protocols are supported');
    }
    if (request.signal && request.body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable && !streamDestructionSupported) {
        throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
    }
    // HTTP-network-or-cache fetch steps 2.4-2.7
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = '0';
    }
    if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === 'number') {
            contentLengthValue = String(totalBytes);
        }
    }
    if (contentLengthValue) {
        headers.set('Content-Length', contentLengthValue);
    }
    // HTTP-network-or-cache fetch step 2.11
    if (!headers.has('User-Agent')) {
        headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
    }
    // HTTP-network-or-cache fetch step 2.15
    if (request.compress && !headers.has('Accept-Encoding')) {
        headers.set('Accept-Encoding', 'gzip,deflate');
    }
    let agent = request.agent;
    if (typeof agent === 'function') {
        agent = agent(parsedURL);
    }
    // HTTP-network fetch step 4.2
    // chunked encoding is handled by Node.js
    return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
    });
}
/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */ /**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */ function AbortError(message) {
    Error.call(this, message);
    this.type = 'aborted';
    this.message = message;
    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
}
AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';
const URL$1 = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].URL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].URL;
// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].PassThrough;
const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
};
/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */ const isSameProtocol = function isSameProtocol(destination, original) {
    const orig = new URL$1(original).protocol;
    const dest = new URL$1(destination).protocol;
    return orig === dest;
};
/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */ function fetch(url, opts) {
    // allow custom promise
    if (!fetch.Promise) {
        throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
    }
    Body.Promise = fetch.Promise;
    // wrap http.request into fetch
    return new fetch.Promise(function(resolve, reject) {
        // build request object
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === 'https:' ? __TURBOPACK__imported__module__$5b$externals$5d2f$https__$5b$external$5d$__$28$https$2c$__cjs$29$__["default"] : __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__["default"]).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort() {
            let error = new AbortError('The user aborted a request.');
            reject(error);
            if (request.body && request.body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable) {
                destroyStream(request.body, error);
            }
            if (!response || !response.body) return;
            response.body.emit('error', error);
        };
        if (signal && signal.aborted) {
            abort();
            return;
        }
        const abortAndFinalize = function abortAndFinalize() {
            abort();
            finalize();
        };
        // send request
        const req = send(options);
        let reqTimeout;
        if (signal) {
            signal.addEventListener('abort', abortAndFinalize);
        }
        function finalize() {
            req.abort();
            if (signal) signal.removeEventListener('abort', abortAndFinalize);
            clearTimeout(reqTimeout);
        }
        if (request.timeout) {
            req.once('socket', function(socket) {
                reqTimeout = setTimeout(function() {
                    reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
                    finalize();
                }, request.timeout);
            });
        }
        req.on('error', function(err) {
            reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
            if (response && response.body) {
                destroyStream(response.body, err);
            }
            finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
            if (signal && signal.aborted) {
                return;
            }
            if (response && response.body) {
                destroyStream(response.body, err);
            }
        });
        /* c8 ignore next 18 */ if (parseInt(process.version.substring(1)) < 14) {
            // Before Node.js 14, pipeline() does not fully support async iterators and does not always
            // properly handle when the socket close/end events are out of order.
            req.on('socket', function(s) {
                s.addListener('close', function(hadError) {
                    // if a data listener is still present we didn't end cleanly
                    const hasDataListener = s.listenerCount('data') > 0;
                    // if end happened before close but the socket didn't emit an error, do it now
                    if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                        const err = new Error('Premature close');
                        err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                        response.body.emit('error', err);
                    }
                });
            });
        }
        req.on('response', function(res) {
            clearTimeout(reqTimeout);
            const headers = createHeadersLenient(res.headers);
            // HTTP fetch step 5
            if (fetch.isRedirect(res.statusCode)) {
                // HTTP fetch step 5.2
                const location = headers.get('Location');
                // HTTP fetch step 5.3
                let locationURL = null;
                try {
                    locationURL = location === null ? null : new URL$1(location, request.url).toString();
                } catch (err) {
                    // error here can only be invalid URL in Location: header
                    // do not throw when options.redirect == manual
                    // let the user extract the errorneous redirect URL
                    if (request.redirect !== 'manual') {
                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
                        finalize();
                        return;
                    }
                }
                // HTTP fetch step 5.5
                switch(request.redirect){
                    case 'error':
                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
                        finalize();
                        return;
                    case 'manual':
                        // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
                        if (locationURL !== null) {
                            // handle corrupted header
                            try {
                                headers.set('Location', locationURL);
                            } catch (err) {
                                // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
                                reject(err);
                            }
                        }
                        break;
                    case 'follow':
                        // HTTP-redirect fetch step 2
                        if (locationURL === null) {
                            break;
                        }
                        // HTTP-redirect fetch step 5
                        if (request.counter >= request.follow) {
                            reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                            finalize();
                            return;
                        }
                        // HTTP-redirect fetch step 6 (counter increment)
                        // Create a new Request object.
                        const requestOpts = {
                            headers: new Headers(request.headers),
                            follow: request.follow,
                            counter: request.counter + 1,
                            agent: request.agent,
                            compress: request.compress,
                            method: request.method,
                            body: request.body,
                            signal: request.signal,
                            timeout: request.timeout,
                            size: request.size
                        };
                        if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                            for (const name of [
                                'authorization',
                                'www-authenticate',
                                'cookie',
                                'cookie2'
                            ]){
                                requestOpts.headers.delete(name);
                            }
                        }
                        // HTTP-redirect fetch step 9
                        if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                            reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                            finalize();
                            return;
                        }
                        // HTTP-redirect fetch step 11
                        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
                            requestOpts.method = 'GET';
                            requestOpts.body = undefined;
                            requestOpts.headers.delete('content-length');
                        }
                        // HTTP-redirect fetch step 15
                        resolve(fetch(new Request(locationURL, requestOpts)));
                        finalize();
                        return;
                }
            }
            // prepare response
            res.once('end', function() {
                if (signal) signal.removeEventListener('abort', abortAndFinalize);
            });
            let body = res.pipe(new PassThrough$1());
            const response_options = {
                url: request.url,
                status: res.statusCode,
                statusText: res.statusMessage,
                headers: headers,
                size: request.size,
                timeout: request.timeout,
                counter: request.counter
            };
            // HTTP-network fetch step 12.1.1.3
            const codings = headers.get('Content-Encoding');
            // HTTP-network fetch step 12.1.1.4: handle content codings
            // in following scenarios we ignore compression support
            // 1. compression support is disabled
            // 2. HEAD request
            // 3. no Content-Encoding header
            // 4. no content response (204)
            // 5. content not modified response (304)
            if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // For Node v6+
            // Be less strict when decoding compressed responses, since sometimes
            // servers send slightly invalid responses that are still accepted
            // by common browsers.
            // Always using Z_SYNC_FLUSH is what cURL does.
            const zlibOptions = {
                flush: __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].Z_SYNC_FLUSH,
                finishFlush: __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].Z_SYNC_FLUSH
            };
            // for gzip
            if (codings == 'gzip' || codings == 'x-gzip') {
                body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createGunzip(zlibOptions));
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // for deflate
            if (codings == 'deflate' || codings == 'x-deflate') {
                // handle the infamous raw deflate response from old servers
                // a hack for old IIS and Apache servers
                const raw = res.pipe(new PassThrough$1());
                raw.once('data', function(chunk) {
                    // see http://stackoverflow.com/questions/37519828
                    if ((chunk[0] & 0x0F) === 0x08) {
                        body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createInflate());
                    } else {
                        body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createInflateRaw());
                    }
                    response = new Response(body, response_options);
                    resolve(response);
                });
                raw.on('end', function() {
                    // some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.
                    if (!response) {
                        response = new Response(body, response_options);
                        resolve(response);
                    }
                });
                return;
            }
            // for br
            if (codings == 'br' && typeof __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createBrotliDecompress === 'function') {
                body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createBrotliDecompress());
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // otherwise, use response as-is
            response = new Response(body, response_options);
            resolve(response);
        });
        writeToStream(req, request);
    });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on('socket', function(s) {
        socket = s;
    });
    request.on('response', function(response) {
        const headers = response.headers;
        if (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {
            response.once('close', function(hadError) {
                // tests for socket presence, as in some situations the
                // the 'socket' event is not triggered for the request
                // (happens in deno), avoids `TypeError`
                // if a data listener is still present we didn't end cleanly
                const hasDataListener = socket && socket.listenerCount('data') > 0;
                if (hasDataListener && !hadError) {
                    const err = new Error('Premature close');
                    err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                    errorCallback(err);
                }
            });
        }
    });
}
function destroyStream(stream, err) {
    if (stream.destroy) {
        stream.destroy(err);
    } else {
        // node < 8
        stream.emit('error', err);
        stream.end();
    }
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */ fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};
// expose Promise
fetch.Promise = ("TURBOPACK ident replacement", globalThis).Promise;
const __TURBOPACK__default__export__ = fetch;
;
}),
"[project]/node_modules/.pnpm/fetch-ponyfill@7.1.0/node_modules/fetch-ponyfill/fetch-node.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var fetch = __turbopack_context__.r("[project]/node_modules/.pnpm/node-fetch@2.6.13/node_modules/node-fetch/lib/index.mjs [app-ssr] (ecmascript)");
function wrapFetchForNode(fetch) {
    // Support schemaless URIs on the server for parity with the browser.
    // https://github.com/matthew-andrews/isomorphic-fetch/pull/10
    return function(u, options) {
        if (typeof u === 'string' && u.slice(0, 2) === '//') {
            return fetch('https:' + u, options);
        }
        return fetch(u, options);
    };
}
module.exports = function(context) {
    // Support webpack module import weirdness.
    var fetchFn = fetch.default ? fetch.default : fetch;
    // This modifies the global `node-fetch` object, which isn't great, since
    // different callers to `fetch-ponyfill` which pass a different Promise
    // implementation would each expect to have their implementation used. But,
    // given the way `node-fetch` is implemented, this is the only way to make
    // it work at all.
    if (context && context.Promise) {
        fetchFn.Promise = context.Promise;
    }
    return {
        fetch: wrapFetchForNode(fetchFn),
        Headers: fetch.Headers,
        Request: fetch.Request,
        Response: fetch.Response
    };
};
}}),
"[project]/node_modules/.pnpm/@nhost+hasura-auth-js@2.12.0/node_modules/@nhost/hasura-auth-js/dist/index.cjs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const er = __turbopack_context__.r("[project]/node_modules/.pnpm/jwt-decode@4.0.0/node_modules/jwt-decode/build/cjs/index.js [app-ssr] (ecmascript)"), u = __turbopack_context__.r("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/index.js [app-ssr] (ecmascript)"), W = __turbopack_context__.r("[project]/node_modules/.pnpm/js-cookie@3.0.5/node_modules/js-cookie/dist/js.cookie.js [app-ssr] (ecmascript)"), rr = __turbopack_context__.r("[project]/node_modules/.pnpm/fetch-ponyfill@7.1.0/node_modules/fetch-ponyfill/fetch-node.js [app-ssr] (ecmascript)"), N = "nhostRefreshToken", D = "nhostRefreshTokenId", v = "nhostRefreshTokenExpiresAt", ie = 3, Y = 60, F = 5, J = 0, ee = 1, A = 10, b = 20;
class O extends Error {
    constructor(e){
        super(e.message), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), e instanceof Error ? (this.name = e.name, this.error = {
            error: e.name,
            status: ee,
            message: e.message
        }) : (this.name = e.error, this.error = e);
    }
}
const k = {
    status: A,
    error: "invalid-email",
    message: "Email is incorrectly formatted"
}, oe = {
    status: A,
    error: "invalid-mfa-type",
    message: "MFA type is invalid"
}, ae = {
    status: A,
    error: "invalid-mfa-code",
    message: "MFA code is invalid"
}, V = {
    status: A,
    error: "invalid-password",
    message: "Password is incorrectly formatted"
}, j = {
    status: A,
    error: "invalid-phone-number",
    message: "Phone number is incorrectly formatted"
}, ce = {
    status: A,
    error: "invalid-mfa-ticket",
    message: "MFA ticket is invalid"
}, le = {
    status: A,
    error: "no-mfa-ticket",
    message: "No MFA ticket has been provided"
}, ue = {
    status: A,
    error: "no-refresh-token",
    message: "No refresh token has been provided"
}, de = {
    status: b,
    error: "refresher-already-running",
    message: "The token refresher is already running. You must wait until is has finished before submitting a new token."
}, w = {
    status: b,
    error: "already-signed-in",
    message: "User is already signed in"
}, he = {
    status: b,
    error: "unauthenticated-user",
    message: "User is not authenticated"
}, sr = {
    status: b,
    error: "user-not-anonymous",
    message: "User is not anonymous"
}, fe = {
    status: b,
    error: "unverified-user",
    message: "Email needs verification"
}, Ee = {
    status: A,
    error: "invalid-refresh-token",
    message: "Invalid or expired refresh token"
}, me = {
    status: ee,
    error: "invalid-sign-in-method",
    message: "Invalid sign-in method"
}, U = {
    user: null,
    mfa: null,
    accessToken: {
        value: null,
        expiresAt: null,
        expiresInSeconds: 15
    },
    refreshTimer: {
        startedAt: null,
        attempts: 0,
        lastAttempt: null
    },
    refreshToken: {
        value: null
    },
    importTokenAttempts: 0,
    errors: {}
};
function nr(n) {
    return new TextEncoder().encode(n);
}
function P(n) {
    const e = new Uint8Array(n);
    let r = "";
    for (const t of e)r += String.fromCharCode(t);
    return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function re(n) {
    const e = n.replace(/-/g, "+").replace(/_/g, "/"), r = (4 - e.length % 4) % 4, s = e.padEnd(e.length + r, "="), t = atob(s), i = new ArrayBuffer(t.length), l = new Uint8Array(i);
    for(let f = 0; f < t.length; f++)l[f] = t.charCodeAt(f);
    return i;
}
function ge() {
    return (window == null ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential == "function";
}
function Te(n) {
    const { id: e } = n;
    return {
        ...n,
        id: re(e),
        transports: n.transports
    };
}
function pe(n) {
    return n === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n);
}
class p extends Error {
    constructor({ message: e, code: r, cause: s, name: t }){
        super(e, {
            cause: s
        }), this.name = t != null ? t : s.name, this.code = r;
    }
}
function tr({ error: n, options: e }) {
    var s, t;
    const { publicKey: r } = e;
    if (!r) throw Error("options was missing required publicKey property");
    if (n.name === "AbortError") {
        if (e.signal instanceof AbortSignal) return new p({
            message: "Registration ceremony was sent an abort signal",
            code: "ERROR_CEREMONY_ABORTED",
            cause: n
        });
    } else if (n.name === "ConstraintError") {
        if (((s = r.authenticatorSelection) == null ? void 0 : s.requireResidentKey) === !0) return new p({
            message: "Discoverable credentials were required but no available authenticator supported it",
            code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
            cause: n
        });
        if (((t = r.authenticatorSelection) == null ? void 0 : t.userVerification) === "required") return new p({
            message: "User verification was required but no available authenticator supported it",
            code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
            cause: n
        });
    } else {
        if (n.name === "InvalidStateError") return new p({
            message: "The authenticator was previously registered",
            code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
            cause: n
        });
        if (n.name === "NotAllowedError") return new p({
            message: n.message,
            code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
            cause: n
        });
        if (n.name === "NotSupportedError") return r.pubKeyCredParams.filter((l)=>l.type === "public-key").length === 0 ? new p({
            message: 'No entry in pubKeyCredParams was of type "public-key"',
            code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
            cause: n
        }) : new p({
            message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
            code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
            cause: n
        });
        if (n.name === "SecurityError") {
            const i = window.location.hostname;
            if (pe(i)) {
                if (r.rp.id !== i) return new p({
                    message: `The RP ID "${r.rp.id}" is invalid for this domain`,
                    code: "ERROR_INVALID_RP_ID",
                    cause: n
                });
            } else return new p({
                message: `${window.location.hostname} is an invalid domain`,
                code: "ERROR_INVALID_DOMAIN",
                cause: n
            });
        } else if (n.name === "TypeError") {
            if (r.user.id.byteLength < 1 || r.user.id.byteLength > 64) return new p({
                message: "User ID was not between 1 and 64 characters",
                code: "ERROR_INVALID_USER_ID_LENGTH",
                cause: n
            });
        } else if (n.name === "UnknownError") return new p({
            message: "The authenticator was unable to process the specified options, or could not create a new credential",
            code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
            cause: n
        });
    }
    return n;
}
class ir {
    createNewAbortSignal() {
        if (this.controller) {
            const r = new Error("Cancelling existing WebAuthn API call for new one");
            r.name = "AbortError", this.controller.abort(r);
        }
        const e = new AbortController;
        return this.controller = e, e.signal;
    }
    cancelCeremony() {
        if (this.controller) {
            const e = new Error("Manually cancelling existing WebAuthn API call");
            e.name = "AbortError", this.controller.abort(e), this.controller = void 0;
        }
    }
}
const we = new ir, or = [
    "cross-platform",
    "platform"
];
function Ie(n) {
    if (n && !(or.indexOf(n) < 0)) return n;
}
async function Se(n) {
    var a;
    if (!ge()) throw new Error("WebAuthn is not supported in this browser");
    const r = {
        publicKey: {
            ...n,
            challenge: re(n.challenge),
            user: {
                ...n.user,
                id: nr(n.user.id)
            },
            excludeCredentials: (a = n.excludeCredentials) == null ? void 0 : a.map(Te)
        }
    };
    r.signal = we.createNewAbortSignal();
    let s;
    try {
        s = await navigator.credentials.create(r);
    } catch (o) {
        throw tr({
            error: o,
            options: r
        });
    }
    if (!s) throw new Error("Registration was not completed");
    const { id: t, rawId: i, response: l, type: f } = s;
    let h;
    typeof l.getTransports == "function" && (h = l.getTransports());
    let E;
    if (typeof l.getPublicKeyAlgorithm == "function") try {
        E = l.getPublicKeyAlgorithm();
    } catch (o) {
        $("getPublicKeyAlgorithm()", o);
    }
    let g;
    if (typeof l.getPublicKey == "function") try {
        const o = l.getPublicKey();
        o !== null && (g = P(o));
    } catch (o) {
        $("getPublicKey()", o);
    }
    let T;
    if (typeof l.getAuthenticatorData == "function") try {
        T = P(l.getAuthenticatorData());
    } catch (o) {
        $("getAuthenticatorData()", o);
    }
    return {
        id: t,
        rawId: P(i),
        response: {
            attestationObject: P(l.attestationObject),
            clientDataJSON: P(l.clientDataJSON),
            transports: h,
            publicKeyAlgorithm: E,
            publicKey: g,
            authenticatorData: T
        },
        type: f,
        clientExtensionResults: s.getClientExtensionResults(),
        authenticatorAttachment: Ie(s.authenticatorAttachment)
    };
}
function $(n, e) {
    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${n}. You should report this error to them.
`, e);
}
function ar(n) {
    return new TextDecoder("utf-8").decode(n);
}
function cr() {
    const n = window.PublicKeyCredential;
    return n.isConditionalMediationAvailable === void 0 ? new Promise((e)=>e(!1)) : n.isConditionalMediationAvailable();
}
function lr({ error: n, options: e }) {
    const { publicKey: r } = e;
    if (!r) throw Error("options was missing required publicKey property");
    if (n.name === "AbortError") {
        if (e.signal instanceof AbortSignal) return new p({
            message: "Authentication ceremony was sent an abort signal",
            code: "ERROR_CEREMONY_ABORTED",
            cause: n
        });
    } else {
        if (n.name === "NotAllowedError") return new p({
            message: n.message,
            code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
            cause: n
        });
        if (n.name === "SecurityError") {
            const s = window.location.hostname;
            if (pe(s)) {
                if (r.rpId !== s) return new p({
                    message: `The RP ID "${r.rpId}" is invalid for this domain`,
                    code: "ERROR_INVALID_RP_ID",
                    cause: n
                });
            } else return new p({
                message: `${window.location.hostname} is an invalid domain`,
                code: "ERROR_INVALID_DOMAIN",
                cause: n
            });
        } else if (n.name === "UnknownError") return new p({
            message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
            code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
            cause: n
        });
    }
    return n;
}
async function q(n, e = !1) {
    var T, a;
    if (!ge()) throw new Error("WebAuthn is not supported in this browser");
    let r;
    ((T = n.allowCredentials) == null ? void 0 : T.length) !== 0 && (r = (a = n.allowCredentials) == null ? void 0 : a.map(Te));
    const s = {
        ...n,
        challenge: re(n.challenge),
        allowCredentials: r
    }, t = {};
    if (e) {
        if (!await cr()) throw Error("Browser does not support WebAuthn autofill");
        if (document.querySelectorAll("input[autocomplete$='webauthn']").length < 1) throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');
        t.mediation = "conditional", s.allowCredentials = [];
    }
    t.publicKey = s, t.signal = we.createNewAbortSignal();
    let i;
    try {
        i = await navigator.credentials.get(t);
    } catch (o) {
        throw lr({
            error: o,
            options: t
        });
    }
    if (!i) throw new Error("Authentication was not completed");
    const { id: l, rawId: f, response: h, type: E } = i;
    let g;
    return h.userHandle && (g = ar(h.userHandle)), {
        id: l,
        rawId: P(f),
        response: {
            authenticatorData: P(h.authenticatorData),
            clientDataJSON: P(h.clientDataJSON),
            signature: P(h.signature),
            userHandle: g
        },
        type: E,
        clientExtensionResults: i.getClientExtensionResults(),
        authenticatorAttachment: Ie(i.authenticatorAttachment)
    };
}
const H = "undefined" != "undefined", K = new Map, ur = (n)=>{
    var e;
    return ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : (e = K.get(n)) != null ? e : null;
}, dr = (n, e)=>{
    ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : e ? K.set(n, e) : K.has(n) && K.delete(n);
}, Re = (n, e)=>{
    if (n === "localStorage" || n === "web") return ur;
    if (n === "cookie") return (r)=>{
        var s;
        return H && (s = W.get(r)) != null ? "TURBOPACK unreachable" : null;
    };
    if (!e) throw Error(`clientStorageType is set to '${n}' but no clientStorage has been given`);
    if (n === "react-native") return (r)=>{
        var s;
        return (s = e.getItem) == null ? void 0 : s.call(e, r);
    };
    if (n === "capacitor") return (r)=>{
        var s;
        return (s = e.get) == null ? void 0 : s.call(e, {
            key: r
        });
    };
    if (n === "expo-secure-storage") return (r)=>{
        var s;
        return (s = e.getItemAsync) == null ? void 0 : s.call(e, r);
    };
    if (n === "custom") {
        if (e.getItem && e.removeItem) return e.getItem;
        if (e.getItemAsync) return e.getItemAsync;
        throw Error(`clientStorageType is set to 'custom' but clientStorage is missing either "getItem" and "removeItem" properties or "getItemAsync" property`);
    }
    throw Error(`Unknown storage type: ${n}`);
}, _e = (n, e)=>{
    if (n === "localStorage" || n === "web") return dr;
    if (n === "cookie") return (r, s)=>{
        H && (s ? W.set(r, s, {
            expires: 30,
            sameSite: "lax",
            httpOnly: !1
        }) : W.remove(r));
    };
    if (!e) throw Error(`clientStorageType is set to '${n}' but no clienStorage has been given`);
    if (n === "react-native") return (r, s)=>{
        var t, i;
        return s ? (t = e.setItem) == null ? void 0 : t.call(e, r, s) : (i = e.removeItem) == null ? void 0 : i.call(e, r);
    };
    if (n === "capacitor") return (r, s)=>{
        var t, i;
        return s ? (t = e.set) == null ? void 0 : t.call(e, {
            key: r,
            value: s
        }) : (i = e.remove) == null ? void 0 : i.call(e, {
            key: r
        });
    };
    if (n === "expo-secure-storage") return async (r, s)=>{
        var t, i;
        return s ? (t = e.setItemAsync) == null ? void 0 : t.call(e, r, s) : (i = e.deleteItemAsync) == null ? void 0 : i.call(e, r);
    };
    if (n === "custom") {
        if (!e.removeItem) throw Error("clientStorageType is set to 'custom' but clientStorage is missing a removeItem property");
        if (e.setItem) return (r, s)=>{
            var t, i;
            return s ? (t = e.setItem) == null ? void 0 : t.call(e, r, s) : (i = e.removeItem) == null ? void 0 : i.call(e, r);
        };
        if (e.setItemAsync) return async (r, s)=>{
            var t, i;
            return s ? (t = e.setItemAsync) == null ? void 0 : t.call(e, r, s) : (i = e.removeItem) == null ? void 0 : i.call(e, r);
        };
        throw Error("clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property");
    }
    throw Error(`Unknown storage type: ${n}`);
}, C = (n)=>!n || !n.accessToken.value || !n.accessToken.expiresAt || !n.user ? null : {
        accessToken: n.accessToken.value,
        accessTokenExpiresIn: (n.accessToken.expiresAt.getTime() - Date.now()) / 1e3,
        refreshToken: n.refreshToken.value,
        user: n.user
    }, _ = ({ accessToken: n, refreshToken: e, isError: r, user: s, error: t })=>r ? {
        session: null,
        error: t
    } : s && n ? {
        session: {
            accessToken: n,
            accessTokenExpiresIn: 0,
            refreshToken: e,
            user: s
        },
        error: null
    } : {
        session: null,
        error: null
    }, M = ()=>"undefined" != "undefined" && typeof window.location != "undefined";
let ke = globalThis.fetch;
typeof EdgeRuntime != "string" && (ke = rr().fetch);
const ye = async (n, e, { token: r, body: s, extraHeaders: t } = {})=>{
    const i = {
        "Content-Type": "application/json",
        Accept: "*/*"
    };
    r && (i.Authorization = `Bearer ${r}`);
    const l = {
        ...i,
        ...t
    }, f = {
        method: e,
        headers: l
    };
    s && (f.body = JSON.stringify(s));
    try {
        const h = await ke(n, f);
        if (!h.ok) {
            const E = await h.json();
            return Promise.reject({
                error: E
            });
        }
        try {
            return {
                data: await h.json(),
                error: null
            };
        } catch  {
            return console.warn(`Unexpected response: can't parse the response of the server at ${n}`), {
                data: "OK",
                error: null
            };
        }
    } catch  {
        const E = {
            message: "Network Error",
            status: J,
            error: "network"
        };
        return Promise.reject({
            error: E
        });
    }
}, I = async (n, e, r, s)=>ye(n, "POST", {
        token: r,
        body: e,
        extraHeaders: s
    }), Ae = (n, e)=>ye(n, "GET", {
        token: e
    }), L = (n, e)=>{
    const r = e && Object.entries(e).map(([s, t])=>{
        const i = Array.isArray(t) ? t.join(",") : typeof t == "object" ? JSON.stringify(t) : t;
        return `${s}=${encodeURIComponent(i)}`;
    }).join("&");
    return r ? `${n}?${r}` : n;
}, R = (n, e)=>{
    if (!(e != null && e.redirectTo)) return e;
    const { redirectTo: r, ...s } = e;
    if (!n) return r.startsWith("/") ? s : e;
    const t = new URL(n), i = Object.fromEntries(new URLSearchParams(t.search)), l = new URL(r.startsWith("/") ? t.origin + r : r), f = new URLSearchParams(l.search);
    let h = Object.fromEntries(f);
    r.startsWith("/") && (h = {
        ...i,
        ...h
    });
    let E = t.pathname;
    return l.pathname.length > 1 && (E += l.pathname.slice(1)), {
        ...s,
        redirectTo: L(l.origin + E, h)
    };
};
function x(n, e) {
    var t;
    if (!e) {
        if ("TURBOPACK compile-time truthy", 1) return;
        //TURBOPACK unreachable
        ;
    }
    n = n.replace(/[\[\]]/g, "\\$&");
    const r = new RegExp("[?&#]" + n + "(=([^&#]*)|&|#|$)"), s = r.exec(e);
    return s ? s[2] ? decodeURIComponent(s[2].replace(/\+/g, " ")) : "" : null;
}
function B(n) {
    var r;
    if ("TURBOPACK compile-time truthy", 1) return;
    //TURBOPACK unreachable
    ;
    const e = undefined;
}
const y = (n)=>!!n && typeof n == "string" && !!String(n).toLowerCase().match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/), G = (n)=>!!n && typeof n == "string" && n.length >= ie, Q = (n)=>!!n && typeof n == "string", Pe = (n)=>n && typeof n == "string" && n.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i), ve = ({ backendUrl: n, clientUrl: e, broadcastKey: r, clientStorageType: s = "web", clientStorage: t, refreshIntervalTime: i, autoRefreshToken: l = !0, autoSignIn: f = !0 })=>{
    const h = Re(s, t), E = _e(s, t), g = async (a, o, c, d)=>(await I(`${n}${a}`, o, c, d)).data;
    let T = null;
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return u.createMachine({
        schema: {
            context: {},
            events: {},
            services: {}
        },
        tsTypes: {},
        context: U,
        predictableActionArguments: !0,
        id: "nhost",
        type: "parallel",
        states: {
            authentication: {
                initial: "starting",
                on: {
                    SESSION_UPDATE: [
                        {
                            cond: "hasSession",
                            actions: [
                                "saveSession",
                                "resetTimer",
                                "reportTokenChanged"
                            ],
                            target: ".signedIn"
                        }
                    ]
                },
                states: {
                    starting: {
                        tags: [
                            "loading"
                        ],
                        always: {
                            cond: "isSignedIn",
                            target: "signedIn"
                        },
                        invoke: {
                            id: "importRefreshToken",
                            src: "importRefreshToken",
                            onDone: [
                                {
                                    cond: "hasSession",
                                    actions: [
                                        "saveSession",
                                        "reportTokenChanged"
                                    ],
                                    target: "signedIn"
                                },
                                {
                                    target: "signedOut"
                                }
                            ],
                            onError: [
                                {
                                    cond: "shouldRetryImportToken",
                                    actions: "incrementTokenImportAttempts",
                                    target: "retryTokenImport"
                                },
                                {
                                    actions: [
                                        "saveAuthenticationError"
                                    ],
                                    target: "signedOut"
                                }
                            ]
                        }
                    },
                    retryTokenImport: {
                        tags: [
                            "loading"
                        ],
                        after: {
                            RETRY_IMPORT_TOKEN_DELAY: "starting"
                        }
                    },
                    signedOut: {
                        initial: "noErrors",
                        entry: "reportSignedOut",
                        states: {
                            noErrors: {},
                            success: {},
                            needsSmsOtp: {},
                            needsMfa: {},
                            failed: {},
                            signingOut: {
                                entry: [
                                    "clearContextExceptTokens"
                                ],
                                exit: [
                                    "destroyAccessToken",
                                    "destroyRefreshToken",
                                    "reportTokenChanged"
                                ],
                                invoke: {
                                    src: "signout",
                                    id: "signingOut",
                                    onDone: {
                                        target: "success"
                                    },
                                    onError: {
                                        target: "failed",
                                        actions: [
                                            "saveAuthenticationError"
                                        ]
                                    }
                                }
                            }
                        },
                        on: {
                            SIGNIN_PASSWORD: "authenticating.password",
                            SIGNIN_ANONYMOUS: "authenticating.anonymous",
                            SIGNIN_SECURITY_KEY_EMAIL: "authenticating.securityKeyEmail",
                            SIGNIN_SECURITY_KEY: "authenticating.securityKey",
                            SIGNIN_MFA_TOTP: "authenticating.mfa.totp",
                            SIGNIN_PAT: "authenticating.pat",
                            SIGNIN_ID_TOKEN: "authenticating.idToken"
                        }
                    },
                    authenticating: {
                        entry: "resetErrors",
                        states: {
                            password: {
                                invoke: {
                                    src: "signInPassword",
                                    id: "authenticateUserWithPassword",
                                    onDone: [
                                        {
                                            cond: "hasMfaTicket",
                                            actions: [
                                                "saveMfaTicket"
                                            ],
                                            target: "#nhost.authentication.signedOut.needsMfa"
                                        },
                                        {
                                            actions: [
                                                "saveSession",
                                                "reportTokenChanged"
                                            ],
                                            target: "#nhost.authentication.signedIn"
                                        }
                                    ],
                                    onError: [
                                        {
                                            cond: "unverified",
                                            target: [
                                                "#nhost.authentication.signedOut",
                                                "#nhost.registration.incomplete.needsEmailVerification"
                                            ]
                                        },
                                        {
                                            actions: "saveAuthenticationError",
                                            target: "#nhost.authentication.signedOut.failed"
                                        }
                                    ]
                                }
                            },
                            pat: {
                                invoke: {
                                    src: "signInPAT",
                                    id: "authenticateWithPAT",
                                    onDone: {
                                        actions: [
                                            "savePATSession",
                                            "reportTokenChanged"
                                        ],
                                        target: "#nhost.authentication.signedIn"
                                    },
                                    onError: {
                                        actions: "saveAuthenticationError",
                                        target: "#nhost.authentication.signedOut.failed"
                                    }
                                }
                            },
                            idToken: {
                                invoke: {
                                    src: "signInIdToken",
                                    id: "authenticateWithIdToken",
                                    onDone: {
                                        actions: [
                                            "saveSession",
                                            "reportTokenChanged"
                                        ],
                                        target: "#nhost.authentication.signedIn"
                                    },
                                    onError: {
                                        actions: "saveAuthenticationError",
                                        target: "#nhost.authentication.signedOut.failed"
                                    }
                                }
                            },
                            anonymous: {
                                invoke: {
                                    src: "signInAnonymous",
                                    id: "authenticateAnonymously",
                                    onDone: {
                                        actions: [
                                            "saveSession",
                                            "reportTokenChanged"
                                        ],
                                        target: "#nhost.authentication.signedIn"
                                    },
                                    onError: {
                                        actions: "saveAuthenticationError",
                                        target: "#nhost.authentication.signedOut.failed"
                                    }
                                }
                            },
                            mfa: {
                                states: {
                                    totp: {
                                        invoke: {
                                            src: "signInMfaTotp",
                                            id: "signInMfaTotp",
                                            onDone: {
                                                actions: [
                                                    "saveSession",
                                                    "reportTokenChanged"
                                                ],
                                                target: "#nhost.authentication.signedIn"
                                            },
                                            onError: {
                                                actions: [
                                                    "saveAuthenticationError"
                                                ],
                                                target: "#nhost.authentication.signedOut.failed"
                                            }
                                        }
                                    }
                                }
                            },
                            securityKeyEmail: {
                                invoke: {
                                    src: "signInSecurityKeyEmail",
                                    id: "authenticateUserWithSecurityKey",
                                    onDone: {
                                        actions: [
                                            "saveSession",
                                            "reportTokenChanged"
                                        ],
                                        target: "#nhost.authentication.signedIn"
                                    },
                                    onError: [
                                        {
                                            cond: "unverified",
                                            target: [
                                                "#nhost.authentication.signedOut",
                                                "#nhost.registration.incomplete.needsEmailVerification"
                                            ]
                                        },
                                        {
                                            actions: "saveAuthenticationError",
                                            target: "#nhost.authentication.signedOut.failed"
                                        }
                                    ]
                                }
                            },
                            securityKey: {
                                invoke: {
                                    src: "signInSecurityKey",
                                    id: "authenticateUserWithSecurityKey",
                                    onDone: {
                                        actions: [
                                            "saveSession",
                                            "reportTokenChanged"
                                        ],
                                        target: "#nhost.authentication.signedIn"
                                    },
                                    onError: [
                                        {
                                            cond: "unverified",
                                            target: [
                                                "#nhost.authentication.signedOut",
                                                "#nhost.registration.incomplete.needsEmailVerification"
                                            ]
                                        },
                                        {
                                            actions: "saveAuthenticationError",
                                            target: "#nhost.authentication.signedOut.failed"
                                        }
                                    ]
                                }
                            }
                        }
                    },
                    signedIn: {
                        type: "parallel",
                        entry: [
                            "reportSignedIn",
                            "cleanUrl",
                            "broadcastToken",
                            "resetErrors"
                        ],
                        on: {
                            SIGNOUT: "signedOut.signingOut"
                        },
                        states: {
                            refreshTimer: {
                                id: "timer",
                                initial: "idle",
                                states: {
                                    disabled: {
                                        type: "final"
                                    },
                                    stopped: {
                                        always: {
                                            cond: "noToken",
                                            target: "idle"
                                        }
                                    },
                                    idle: {
                                        always: [
                                            {
                                                cond: "isAutoRefreshDisabled",
                                                target: "disabled"
                                            },
                                            {
                                                cond: "isRefreshTokenPAT",
                                                target: "disabled"
                                            },
                                            {
                                                cond: "hasRefreshToken",
                                                target: "running"
                                            }
                                        ]
                                    },
                                    running: {
                                        initial: "pending",
                                        entry: "resetTimer",
                                        states: {
                                            pending: {
                                                after: {
                                                    1e3: {
                                                        internal: !1,
                                                        target: "pending"
                                                    }
                                                },
                                                always: {
                                                    cond: "refreshTimerShouldRefresh",
                                                    target: "refreshing"
                                                }
                                            },
                                            refreshing: {
                                                invoke: {
                                                    src: "refreshToken",
                                                    id: "refreshToken",
                                                    onDone: {
                                                        actions: [
                                                            "saveSession",
                                                            "resetTimer",
                                                            "reportTokenChanged",
                                                            "broadcastToken"
                                                        ],
                                                        target: "pending"
                                                    },
                                                    onError: [
                                                        {
                                                            cond: "isUnauthorizedError",
                                                            target: "#nhost.authentication.signedOut"
                                                        },
                                                        {
                                                            actions: "saveRefreshAttempt",
                                                            target: "pending"
                                                        }
                                                    ]
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },
            token: {
                initial: "idle",
                states: {
                    idle: {
                        on: {
                            TRY_TOKEN: "running"
                        },
                        initial: "noErrors",
                        states: {
                            noErrors: {},
                            error: {}
                        }
                    },
                    running: {
                        invoke: {
                            src: "refreshToken",
                            id: "authenticateWithToken",
                            onDone: {
                                actions: [
                                    "saveSession",
                                    "reportTokenChanged",
                                    "broadcastToken"
                                ],
                                target: [
                                    "#nhost.authentication.signedIn",
                                    "idle.noErrors"
                                ]
                            },
                            onError: [
                                {
                                    cond: "isSignedIn",
                                    target: "idle.error"
                                },
                                {
                                    actions: "saveAuthenticationError",
                                    target: [
                                        "#nhost.authentication.signedOut.failed",
                                        "idle.error"
                                    ]
                                }
                            ]
                        }
                    }
                }
            },
            registration: {
                initial: "incomplete",
                on: {
                    SIGNED_IN: [
                        {
                            cond: "isAnonymous",
                            target: ".incomplete"
                        },
                        ".complete"
                    ]
                },
                states: {
                    incomplete: {
                        on: {
                            SIGNUP_EMAIL_PASSWORD: "emailPassword",
                            SIGNUP_SECURITY_KEY: "securityKey",
                            PASSWORDLESS_EMAIL: "passwordlessEmail",
                            PASSWORDLESS_SMS: "passwordlessSms",
                            PASSWORDLESS_SMS_OTP: "passwordlessSmsOtp",
                            SIGNIN_EMAIL_OTP: "signInEmailOTP",
                            VERIFY_EMAIL_OTP: "verifyEmailOTP"
                        },
                        initial: "noErrors",
                        states: {
                            noErrors: {},
                            needsEmailVerification: {},
                            needsOtp: {},
                            failed: {}
                        }
                    },
                    emailPassword: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "signUpEmailPassword",
                            id: "signUpEmailPassword",
                            onDone: [
                                {
                                    cond: "hasSession",
                                    actions: [
                                        "saveSession",
                                        "reportTokenChanged"
                                    ],
                                    target: "#nhost.authentication.signedIn"
                                },
                                {
                                    actions: "clearContext",
                                    target: [
                                        "#nhost.authentication.signedOut",
                                        "incomplete.needsEmailVerification"
                                    ]
                                }
                            ],
                            onError: [
                                {
                                    cond: "unverified",
                                    target: "incomplete.needsEmailVerification"
                                },
                                {
                                    actions: "saveRegistrationError",
                                    target: "incomplete.failed"
                                }
                            ]
                        }
                    },
                    securityKey: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "signUpSecurityKey",
                            id: "signUpSecurityKey",
                            onDone: [
                                {
                                    cond: "hasSession",
                                    actions: [
                                        "saveSession",
                                        "reportTokenChanged"
                                    ],
                                    target: "#nhost.authentication.signedIn"
                                },
                                {
                                    actions: "clearContext",
                                    target: [
                                        "#nhost.authentication.signedOut",
                                        "incomplete.needsEmailVerification"
                                    ]
                                }
                            ],
                            onError: [
                                {
                                    cond: "unverified",
                                    target: "incomplete.needsEmailVerification"
                                },
                                {
                                    actions: "saveRegistrationError",
                                    target: "incomplete.failed"
                                }
                            ]
                        }
                    },
                    passwordlessEmail: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "passwordlessEmail",
                            id: "passwordlessEmail",
                            onDone: {
                                actions: "clearContext",
                                target: [
                                    "#nhost.authentication.signedOut",
                                    "incomplete.needsEmailVerification"
                                ]
                            },
                            onError: {
                                actions: "saveRegistrationError",
                                target: "incomplete.failed"
                            }
                        }
                    },
                    passwordlessSms: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "passwordlessSms",
                            id: "passwordlessSms",
                            onDone: {
                                actions: "clearContext",
                                target: [
                                    "#nhost.authentication.signedOut",
                                    "incomplete.needsOtp"
                                ]
                            },
                            onError: {
                                actions: "saveRegistrationError",
                                target: "incomplete.failed"
                            }
                        }
                    },
                    passwordlessSmsOtp: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "passwordlessSmsOtp",
                            id: "passwordlessSmsOtp",
                            onDone: {
                                actions: [
                                    "saveSession",
                                    "reportTokenChanged"
                                ],
                                target: "#nhost.authentication.signedIn"
                            },
                            onError: {
                                actions: "saveRegistrationError",
                                target: "incomplete.failed"
                            }
                        }
                    },
                    signInEmailOTP: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "signInEmailOTP",
                            id: "signInEmailOTP",
                            onDone: {
                                actions: "clearContext",
                                target: [
                                    "#nhost.authentication.signedOut",
                                    "incomplete.needsOtp"
                                ]
                            },
                            onError: {
                                actions: "saveRegistrationError",
                                target: "incomplete.failed"
                            }
                        }
                    },
                    verifyEmailOTP: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "verifyEmailOTP",
                            id: "verifyEmailOTP",
                            onDone: {
                                actions: [
                                    "saveSession",
                                    "reportTokenChanged"
                                ],
                                target: "#nhost.authentication.signedIn"
                            },
                            onError: {
                                actions: "saveRegistrationError",
                                target: "incomplete.failed"
                            }
                        }
                    },
                    complete: {
                        on: {
                            SIGNED_OUT: "incomplete"
                        }
                    }
                }
            }
        }
    }, {
        actions: {
            reportSignedIn: u.send("SIGNED_IN"),
            reportSignedOut: u.send("SIGNED_OUT"),
            reportTokenChanged: u.send("TOKEN_CHANGED"),
            incrementTokenImportAttempts: u.assign({
                importTokenAttempts: ({ importTokenAttempts: a })=>a + 1
            }),
            clearContext: u.assign(()=>(E(v, null), E(N, null), E(D, null), {
                    ...U
                })),
            clearContextExceptTokens: u.assign(({ accessToken: a, refreshToken: o })=>({
                    ...U,
                    accessToken: a,
                    refreshToken: o
                })),
            saveSession: u.assign({
                user: (a, { data: o })=>{
                    var c;
                    return ((c = o == null ? void 0 : o.session) == null ? void 0 : c.user) || null;
                },
                accessToken: (a, { data: o })=>{
                    if (o.session) {
                        const { accessTokenExpiresIn: c, accessToken: d } = o.session, m = new Date(Date.now() + c * 1e3);
                        return E(v, m.toISOString()), {
                            value: d,
                            expiresAt: m,
                            expiresInSeconds: c
                        };
                    }
                    return E(v, null), {
                        value: null,
                        expiresAt: null,
                        expiresInSeconds: null
                    };
                },
                refreshToken: (a, { data: o })=>{
                    var m, S;
                    const c = ((m = o.session) == null ? void 0 : m.refreshToken) || null, d = ((S = o.session) == null ? void 0 : S.refreshTokenId) || null;
                    return c && E(N, c), d && E(D, d), {
                        value: c
                    };
                }
            }),
            savePATSession: u.assign({
                user: (a, { data: o })=>{
                    var c;
                    return ((c = o == null ? void 0 : o.session) == null ? void 0 : c.user) || null;
                },
                accessToken: (a, { data: o })=>{
                    if (o.session) {
                        const { accessTokenExpiresIn: c, accessToken: d } = o.session, m = new Date(Date.now() + c * 1e3);
                        return E(v, m.toISOString()), {
                            value: d,
                            expiresAt: m,
                            expiresInSeconds: c
                        };
                    }
                    return E(v, null), {
                        value: null,
                        expiresAt: null,
                        expiresInSeconds: null
                    };
                },
                refreshToken: (a, { data: o })=>{
                    var m, S;
                    const c = ((m = o.session) == null ? void 0 : m.refreshToken) || null, d = ((S = o.session) == null ? void 0 : S.refreshTokenId) || null;
                    return c && E(N, c), d && E(D, d), {
                        value: c,
                        isPAT: !0
                    };
                }
            }),
            saveMfaTicket: u.assign({
                mfa: (a, o)=>{
                    var c;
                    return (c = o.data) == null ? void 0 : c.mfa;
                }
            }),
            resetTimer: u.assign({
                refreshTimer: (a)=>({
                        startedAt: new Date,
                        attempts: 0,
                        lastAttempt: null
                    })
            }),
            saveRefreshAttempt: u.assign({
                refreshTimer: (a, o)=>({
                        startedAt: a.refreshTimer.startedAt,
                        attempts: a.refreshTimer.attempts + 1,
                        lastAttempt: new Date
                    })
            }),
            saveAuthenticationError: u.assign({
                errors: ({ errors: a }, { data: { error: o } })=>({
                        ...a,
                        authentication: o
                    })
            }),
            resetErrors: u.assign({
                errors: (a)=>({}),
                importTokenAttempts: (a)=>0
            }),
            saveRegistrationError: u.assign({
                errors: ({ errors: a }, { data: { error: o } })=>({
                        ...a,
                        registration: o
                    })
            }),
            destroyRefreshToken: u.assign({
                refreshToken: (a)=>(E(N, null), E(D, null), {
                        value: null
                    })
            }),
            destroyAccessToken: u.assign({
                accessToken: (a)=>(E(v, null), {
                        value: null,
                        expiresAt: null,
                        expiresInSeconds: null
                    })
            }),
            cleanUrl: ()=>{
                f && x("refreshToken") && (B("refreshToken"), B("type"));
            },
            broadcastToken: (a)=>{
                if (f && r && T) try {
                    T.postMessage({
                        type: "broadcast_session",
                        payload: {
                            token: a.refreshToken.value,
                            accessToken: a.accessToken.value,
                            user: a.user,
                            expiresAt: a.accessToken.expiresAt ? a.accessToken.expiresAt.toISOString() : null,
                            expiresInSeconds: a.accessToken.expiresInSeconds
                        }
                    });
                } catch  {}
            }
        },
        guards: {
            isAnonymous: (a, o)=>{
                var c;
                return !!((c = a.user) != null && c.isAnonymous);
            },
            isSignedIn: (a)=>!!a.user && !!a.accessToken.value,
            noToken: (a)=>!a.refreshToken.value,
            isRefreshTokenPAT: (a)=>{
                var o;
                return !!((o = a.refreshToken) != null && o.isPAT);
            },
            hasRefreshToken: (a)=>!!a.refreshToken.value,
            isAutoRefreshDisabled: ()=>!l,
            refreshTimerShouldRefresh: (a)=>{
                const { expiresAt: o } = a.accessToken;
                if (!o) return !1;
                if (a.refreshTimer.lastAttempt) return a.refreshTimer.attempts > F ? !1 : Date.now() - a.refreshTimer.lastAttempt.getTime() > Math.pow(2, a.refreshTimer.attempts - 1) * 5e3;
                if (o.getTime() < Date.now() || i && Date.now() - a.refreshTimer.startedAt.getTime() > i * 1e3) return !0;
                if (!a.accessToken.expiresInSeconds) return !1;
                const d = o.getTime() - Date.now();
                return d <= Y * 1e3 / 2 || d <= Y * 1e3 && Math.random() < .1;
            },
            shouldRetryImportToken: (a, o)=>a.importTokenAttempts < F && (o.data.error.status === J || o.data.error.status >= 500),
            unverified: (a, { data: { error: o } })=>o.status === 401 && (o.message === "Email is not verified" || o.error === "unverified-user"),
            hasSession: (a, o)=>{
                var c;
                return !!((c = o.data) != null && c.session);
            },
            hasMfaTicket: (a, o)=>{
                var c;
                return !!((c = o.data) != null && c.mfa);
            },
            isUnauthorizedError: (a, { data: { error: o } })=>o.status === 401
        },
        services: {
            signInPassword: (a, { email: o, password: c })=>y(o) ? G(c) ? g("/signin/email-password", {
                    email: o,
                    password: c
                }) : Promise.reject({
                    error: V
                }) : Promise.reject({
                    error: k
                }),
            signInPAT: (a, { pat: o })=>g("/signin/pat", {
                    personalAccessToken: o
                }),
            signInIdToken: (a, { provider: o, idToken: c, nonce: d })=>g("/signin/idtoken", {
                    provider: o,
                    idToken: c,
                    ...d && {
                        nonce: d
                    }
                }),
            passwordlessSms: (a, { phoneNumber: o, options: c })=>{
                var d;
                return Q(o) ? (d = a.user) != null && d.isAnonymous ? (console.warn("Deanonymisation from a phone number is not yet implemented in hasura-auth"), g("/user/deanonymize", {
                    signInMethod: "passwordless",
                    connection: "sms",
                    phoneNumber: o,
                    options: R(e, c)
                }, a.accessToken.value)) : g("/signin/passwordless/sms", {
                    phoneNumber: o,
                    options: R(e, c)
                }) : Promise.reject({
                    error: j
                });
            },
            passwordlessSmsOtp: (a, { phoneNumber: o, otp: c })=>Q(o) ? g("/signin/passwordless/sms/otp", {
                    phoneNumber: o,
                    otp: c
                }) : Promise.reject({
                    error: j
                }),
            signInEmailOTP: (a, { email: o, options: c })=>y(o) ? g("/signin/otp/email", {
                    email: o,
                    options: R(e, c)
                }) : Promise.reject({
                    error: k
                }),
            verifyEmailOTP: (a, { email: o, otp: c })=>y(o) ? g("/signin/otp/email/verify", {
                    email: o,
                    otp: c
                }) : Promise.reject({
                    error: k
                }),
            passwordlessEmail: (a, { email: o, options: c })=>{
                var d;
                return y(o) ? (d = a.user) != null && d.isAnonymous ? g("/user/deanonymize", {
                    signInMethod: "passwordless",
                    connection: "email",
                    email: o,
                    options: R(e, c)
                }, a.accessToken.value) : g("/signin/passwordless/email", {
                    email: o,
                    options: R(e, c)
                }) : Promise.reject({
                    error: k
                });
            },
            signInAnonymous: (a)=>g("/signin/anonymous"),
            signInMfaTotp: (a, o)=>{
                var d;
                const c = o.ticket || ((d = a.mfa) == null ? void 0 : d.ticket);
                return c ? Pe(c) ? g("/signin/mfa/totp", {
                    ticket: c,
                    otp: o.otp
                }) : Promise.reject({
                    error: ce
                }) : Promise.reject({
                    error: le
                });
            },
            signInSecurityKeyEmail: async (a, { email: o })=>{
                if (!y(o)) throw new O(k);
                const c = await g("/signin/webauthn", {
                    email: o
                });
                let d;
                try {
                    d = await q(c);
                } catch (m) {
                    throw new O(m);
                }
                return g("/signin/webauthn/verify", {
                    email: o,
                    credential: d
                });
            },
            refreshToken: async (a, o)=>{
                const c = o.type === "TRY_TOKEN" ? o.token : a.refreshToken.value;
                return {
                    session: await g("/token", {
                        refreshToken: c
                    }),
                    error: null
                };
            },
            signInSecurityKey: async ()=>{
                try {
                    const a = await g("/signin/webauthn", {});
                    let o;
                    try {
                        o = await q(a);
                    } catch (c) {
                        throw new O(c);
                    }
                    return g("/signin/webauthn/verify", {
                        credential: o
                    });
                } catch (a) {
                    throw new O(a);
                }
            },
            signout: async (a, o)=>{
                const c = await g("/signout", {
                    refreshToken: a.refreshToken.value,
                    all: !!o.all
                }, o.all ? a.accessToken.value : void 0);
                if (r && T) try {
                    T.postMessage({
                        type: "signout"
                    });
                } catch  {}
                return c;
            },
            signUpEmailPassword: async (a, { email: o, password: c, options: d, requestOptions: m })=>{
                var S;
                return y(o) ? G(c) ? (S = a.user) != null && S.isAnonymous ? g("/user/deanonymize", {
                    signInMethod: "email-password",
                    email: o,
                    password: c,
                    options: R(e, d)
                }, a.accessToken.value, m == null ? void 0 : m.headers) : g("/signup/email-password", {
                    email: o,
                    password: c,
                    options: R(e, d)
                }, null, m == null ? void 0 : m.headers) : Promise.reject({
                    error: V
                }) : Promise.reject({
                    error: k
                });
            },
            signUpSecurityKey: async (a, { email: o, options: c, requestOptions: d })=>{
                if (!y(o)) return Promise.reject({
                    error: k
                });
                const m = c == null ? void 0 : c.nickname;
                m && delete c.nickname;
                const S = await g("/signup/webauthn", {
                    email: o,
                    options: c
                }, null, d == null ? void 0 : d.headers);
                let ne;
                try {
                    ne = await Se(S);
                } catch (Je) {
                    throw new O(Je);
                }
                return g("/signup/webauthn/verify", {
                    credential: ne,
                    options: {
                        redirectTo: c == null ? void 0 : c.redirectTo,
                        nickname: m,
                        displayName: c == null ? void 0 : c.displayName,
                        ...(c == null ? void 0 : c.metadata) && {
                            metadata: c == null ? void 0 : c.metadata
                        }
                    }
                });
            },
            importRefreshToken: async (a)=>{
                if (a.user && a.refreshToken.value && a.accessToken.value && a.accessToken.expiresAt) return {
                    session: {
                        accessToken: a.accessToken.value,
                        accessTokenExpiresIn: a.accessToken.expiresAt.getTime() - Date.now(),
                        refreshToken: a.refreshToken.value,
                        user: a.user
                    },
                    error: null
                };
                let o = null;
                if (f) {
                    const d = x("refreshToken") || null;
                    if (d) try {
                        return {
                            session: await g("/token", {
                                refreshToken: d
                            }),
                            error: null
                        };
                    } catch (m) {
                        o = m.error;
                    }
                    else {
                        const m = x("error"), S = x("errorDescription");
                        if (m && S !== "social user already exists") return Promise.reject({
                            session: null,
                            error: {
                                status: A,
                                error: m,
                                message: S || m
                            }
                        });
                    }
                }
                const c = await h(N);
                if (c) try {
                    return {
                        session: await g("/token", {
                            refreshToken: c
                        }),
                        error: null
                    };
                } catch (d) {
                    o = d.error;
                }
                return o ? Promise.reject({
                    error: o,
                    session: null
                }) : {
                    error: null,
                    session: null
                };
            }
        },
        delays: {
            RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts: a })=>Math.pow(2, a - 1) * 5e3
        }
    });
}, Oe = ({ backendUrl: n, clientUrl: e, interpreter: r })=>u.createMachine({
        schema: {
            context: {},
            events: {},
            services: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        id: "changeEmail",
        initial: "idle",
        context: {
            error: null
        },
        states: {
            idle: {
                on: {
                    REQUEST: [
                        {
                            cond: "invalidEmail",
                            actions: "saveInvalidEmailError",
                            target: ".error"
                        },
                        {
                            target: "requesting"
                        }
                    ]
                },
                initial: "initial",
                states: {
                    initial: {},
                    success: {},
                    error: {}
                }
            },
            requesting: {
                invoke: {
                    src: "requestChange",
                    id: "requestChange",
                    onDone: {
                        target: "idle.success",
                        actions: "reportSuccess"
                    },
                    onError: {
                        actions: [
                            "saveRequestError",
                            "reportError"
                        ],
                        target: "idle.error"
                    }
                }
            }
        }
    }, {
        actions: {
            saveInvalidEmailError: u.assign({
                error: (s)=>k
            }),
            saveRequestError: u.assign({
                error: (s, { data: { error: t } })=>t
            }),
            reportError: u.send((s)=>({
                    type: "ERROR",
                    error: s.error
                })),
            reportSuccess: u.send("SUCCESS")
        },
        guards: {
            invalidEmail: (s, { email: t })=>!y(t)
        },
        services: {
            requestChange: async (s, { email: t, options: i })=>(await I(`${n}/user/email/change`, {
                    newEmail: t,
                    options: R(e, i)
                }, r == null ? void 0 : r.getSnapshot().context.accessToken.value)).data
        }
    }), Ne = ({ backendUrl: n, interpreter: e })=>u.createMachine({
        schema: {
            context: {},
            events: {},
            services: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        id: "changePassword",
        initial: "idle",
        context: {
            error: null
        },
        states: {
            idle: {
                on: {
                    REQUEST: [
                        {
                            cond: "invalidPassword",
                            actions: "saveInvalidPasswordError",
                            target: ".error"
                        },
                        {
                            target: "requesting"
                        }
                    ]
                },
                initial: "initial",
                states: {
                    initial: {},
                    success: {},
                    error: {}
                }
            },
            requesting: {
                invoke: {
                    src: "requestChange",
                    id: "requestChange",
                    onDone: {
                        target: "idle.success",
                        actions: "reportSuccess"
                    },
                    onError: {
                        actions: [
                            "saveRequestError",
                            "reportError"
                        ],
                        target: "idle.error"
                    }
                }
            }
        }
    }, {
        actions: {
            saveInvalidPasswordError: u.assign({
                error: (r)=>V
            }),
            saveRequestError: u.assign({
                error: (r, { data: { error: s } })=>s
            }),
            reportError: u.send((r)=>({
                    type: "ERROR",
                    error: r.error
                })),
            reportSuccess: u.send("SUCCESS")
        },
        guards: {
            invalidPassword: (r, { password: s })=>!G(s)
        },
        services: {
            requestChange: (r, { password: s, ticket: t })=>I(`${n}/user/password`, {
                    newPassword: s,
                    ticket: t
                }, e == null ? void 0 : e.getSnapshot().context.accessToken.value)
        }
    }), hr = ({ backendUrl: n, interpreter: e })=>u.createMachine({
        schema: {
            context: {},
            events: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        id: "enableMfa",
        initial: "idle",
        context: {
            error: null,
            imageUrl: null,
            secret: null
        },
        states: {
            idle: {
                initial: "initial",
                on: {
                    GENERATE: "generating",
                    DISABLE: "disabling"
                },
                states: {
                    initial: {},
                    error: {},
                    disabled: {}
                }
            },
            generating: {
                invoke: {
                    src: "generate",
                    id: "generate",
                    onDone: {
                        target: "generated",
                        actions: [
                            "reportGeneratedSuccess",
                            "saveGeneration"
                        ]
                    },
                    onError: {
                        actions: [
                            "saveError",
                            "reportGeneratedError"
                        ],
                        target: "idle.error"
                    }
                }
            },
            generated: {
                initial: "idle",
                states: {
                    idle: {
                        initial: "idle",
                        on: {
                            ACTIVATE: [
                                {
                                    cond: "invalidMfaType",
                                    actions: "saveInvalidMfaTypeError",
                                    target: ".error"
                                },
                                {
                                    cond: "invalidMfaCode",
                                    actions: "saveInvalidMfaCodeError",
                                    target: ".error"
                                },
                                {
                                    target: "activating"
                                }
                            ],
                            DISABLE: "#enableMfa.disabling"
                        },
                        states: {
                            idle: {},
                            error: {}
                        }
                    },
                    activating: {
                        invoke: {
                            src: "activate",
                            id: "activate",
                            onDone: {
                                target: "activated",
                                actions: "reportSuccess"
                            },
                            onError: {
                                actions: [
                                    "saveError",
                                    "reportError"
                                ],
                                target: "idle.error"
                            }
                        }
                    },
                    activated: {
                        type: "final"
                    }
                }
            },
            disabling: {
                invoke: {
                    src: "disable",
                    id: "disable",
                    onDone: {
                        target: "idle.disabled",
                        actions: "reportSuccess"
                    },
                    onError: {
                        actions: [
                            "saveError",
                            "reportError"
                        ],
                        target: "idle.error"
                    }
                }
            }
        }
    }, {
        actions: {
            saveInvalidMfaTypeError: u.assign({
                error: (r)=>oe
            }),
            saveInvalidMfaCodeError: u.assign({
                error: (r)=>ae
            }),
            saveError: u.assign({
                error: (r, { data: { error: s } })=>s
            }),
            saveGeneration: u.assign({
                imageUrl: (r, { data: { imageUrl: s } })=>s,
                secret: (r, { data: { totpSecret: s } })=>s
            }),
            reportError: u.send((r, s)=>({
                    type: "ERROR",
                    error: r.error
                })),
            reportSuccess: u.send("SUCCESS"),
            reportGeneratedSuccess: u.send("GENERATED"),
            reportGeneratedError: u.send((r)=>({
                    type: "GENERATED_ERROR",
                    error: r.error
                }))
        },
        guards: {
            invalidMfaCode: (r, { code: s })=>!s,
            invalidMfaType: (r, { activeMfaType: s })=>!s || s !== "totp"
        },
        services: {
            generate: async (r)=>{
                const { data: s } = await Ae(`${n}/mfa/totp/generate`, e == null ? void 0 : e.getSnapshot().context.accessToken.value);
                return s;
            },
            activate: (r, { code: s, activeMfaType: t })=>I(`${n}/user/mfa`, {
                    code: s,
                    activeMfaType: t
                }, e == null ? void 0 : e.getSnapshot().context.accessToken.value),
            disable: (r, { code: s })=>I(`${n}/user/mfa`, {
                    code: s,
                    activeMfaType: ""
                }, e == null ? void 0 : e.getSnapshot().context.accessToken.value)
        }
    }), be = ({ backendUrl: n, clientUrl: e })=>u.createMachine({
        schema: {
            context: {},
            events: {},
            services: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        id: "changePassword",
        initial: "idle",
        context: {
            error: null
        },
        states: {
            idle: {
                on: {
                    REQUEST: [
                        {
                            cond: "invalidEmail",
                            actions: "saveInvalidEmailError",
                            target: ".error"
                        },
                        {
                            target: "requesting"
                        }
                    ]
                },
                initial: "initial",
                states: {
                    initial: {},
                    success: {},
                    error: {}
                }
            },
            requesting: {
                invoke: {
                    src: "requestChange",
                    id: "requestChange",
                    onDone: {
                        target: "idle.success",
                        actions: "reportSuccess"
                    },
                    onError: {
                        actions: [
                            "saveRequestError",
                            "reportError"
                        ],
                        target: "idle.error"
                    }
                }
            }
        }
    }, {
        actions: {
            saveInvalidEmailError: u.assign({
                error: (r)=>k
            }),
            saveRequestError: u.assign({
                error: (r, { data: { error: s } })=>s
            }),
            reportError: u.send((r)=>({
                    type: "ERROR",
                    error: r.error
                })),
            reportSuccess: u.send("SUCCESS")
        },
        guards: {
            invalidEmail: (r, { email: s })=>!y(s)
        },
        services: {
            requestChange: (r, { email: s, options: t })=>I(`${n}/user/password/reset`, {
                    email: s,
                    options: R(e, t)
                })
        }
    }), De = ({ backendUrl: n, clientUrl: e })=>u.createMachine({
        schema: {
            context: {},
            events: {},
            services: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        id: "sendVerificationEmail",
        initial: "idle",
        context: {
            error: null
        },
        states: {
            idle: {
                on: {
                    REQUEST: [
                        {
                            cond: "invalidEmail",
                            actions: "saveInvalidEmailError",
                            target: ".error"
                        },
                        {
                            target: "requesting"
                        }
                    ]
                },
                initial: "initial",
                states: {
                    initial: {},
                    success: {},
                    error: {}
                }
            },
            requesting: {
                invoke: {
                    src: "request",
                    id: "request",
                    onDone: {
                        target: "idle.success",
                        actions: "reportSuccess"
                    },
                    onError: {
                        actions: [
                            "saveRequestError",
                            "reportError"
                        ],
                        target: "idle.error"
                    }
                }
            }
        }
    }, {
        actions: {
            saveInvalidEmailError: u.assign({
                error: (r)=>k
            }),
            saveRequestError: u.assign({
                error: (r, { data: { error: s } })=>s
            }),
            reportError: u.send((r)=>({
                    type: "ERROR",
                    error: r.error
                })),
            reportSuccess: u.send("SUCCESS")
        },
        guards: {
            invalidEmail: (r, { email: s })=>!y(s)
        },
        services: {
            request: async (r, { email: s, options: t })=>(await I(`${n}/user/email/send-verification-email`, {
                    email: s,
                    options: R(e, t)
                })).data
        }
    });
class se {
    constructor({ clientStorageType: e = "web", autoSignIn: r = !0, autoRefreshToken: s = !0, start: t = !0, backendUrl: i, clientUrl: l, broadcastKey: f, devTools: h, ...E }){
        var g;
        if (this._started = !1, this._subscriptionsQueue = new Set, this._subscriptions = new Set, this.backendUrl = i, this.clientUrl = l, this._machine = ve({
            ...E,
            backendUrl: i,
            clientUrl: l,
            broadcastKey: f,
            clientStorageType: e,
            autoSignIn: r,
            autoRefreshToken: s
        }), t && this.start({
            devTools: h
        }), "undefined" != "undefined" && f) try {
            this._channel = new BroadcastChannel(f), r && ((g = this._channel) == null || g.addEventListener("message", (T)=>{
                var c;
                const { type: a, payload: o } = T.data;
                if (a === "broadcast_session") {
                    const d = (c = this.interpreter) == null ? void 0 : c.getSnapshot().context, m = d == null ? void 0 : d.refreshToken.value;
                    this.interpreter && o.token && o.token !== m && this.interpreter.send("SESSION_UPDATE", {
                        data: {
                            session: {
                                user: o.user,
                                accessToken: o.accessToken,
                                refreshToken: o.token,
                                accessTokenExpiresIn: o.expiresInSeconds
                            }
                        }
                    });
                }
            })), this._channel.addEventListener("message", (T)=>{
                const { type: a } = T.data;
                a === "signout" && this.interpreter && this.interpreter.send("SIGNOUT");
            });
        } catch  {}
    }
    start({ devTools: e = !1, initialSession: r, interpreter: s } = {}) {
        var l, f;
        const t = {
            ...this.machine.context,
            accessToken: {
                ...this.machine.context.accessToken
            },
            refreshToken: {
                ...this.machine.context.refreshToken
            }
        };
        r && (t.user = r.user, t.refreshToken.value = (l = r.refreshToken) != null ? l : null, t.accessToken.value = (f = r.accessToken) != null ? f : null, t.accessToken.expiresAt = new Date(Date.now() + r.accessTokenExpiresIn * 1e3));
        const i = this.machine.withContext(t);
        this._interpreter || (this._interpreter = s || u.interpret(i, {
            devTools: e
        })), (!this._started || "undefined" == "undefined") && (this._interpreter.initialized && (this._interpreter.stop(), this._subscriptions.forEach((h)=>h())), this._interpreter.start(i.initialState), this._subscriptionsQueue.forEach((h)=>h(this))), this._started = !0;
    }
    get machine() {
        return this._machine;
    }
    get interpreter() {
        return this._interpreter;
    }
    get started() {
        return this._started;
    }
    subscribe(e) {
        if (this.started) {
            const r = e(this);
            return this._subscriptions.add(r), r;
        } else return this._subscriptionsQueue.add(e), ()=>{
            console.log("onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.");
        };
    }
}
class Ce extends se {
    constructor({ ...e }){
        super({
            ...e,
            autoSignIn: M() && e.autoSignIn,
            autoRefreshToken: M() && e.autoRefreshToken,
            clientStorageType: "cookie"
        });
    }
}
const fr = Ce, xe = async ({ backendUrl: n, interpreter: e }, r)=>{
    try {
        const { data: s } = await I(`${n}/user/webauthn/add`, {}, e == null ? void 0 : e.getSnapshot().context.accessToken.value);
        let t;
        try {
            t = await Se(s);
        } catch (l) {
            throw new O(l);
        }
        const { data: i } = await I(`${n}/user/webauthn/verify`, {
            credential: t,
            nickname: r
        }, e == null ? void 0 : e.getSnapshot().context.accessToken.value);
        return {
            key: i,
            isError: !1,
            error: null,
            isSuccess: !0
        };
    } catch (s) {
        const { error: t } = s;
        return {
            isError: !0,
            error: t,
            isSuccess: !1
        };
    }
}, Me = async (n, e, r)=>new Promise((s)=>{
        n.send("REQUEST", {
            email: e,
            options: r
        }), n.onTransition((t)=>{
            t.matches({
                idle: "error"
            }) ? s({
                error: t.context.error,
                isError: !0,
                needsEmailVerification: !1
            }) : t.matches({
                idle: "success"
            }) && s({
                error: null,
                isError: !1,
                needsEmailVerification: !0
            });
        });
    }), Ue = async (n, e, r)=>new Promise((s)=>{
        n.send("REQUEST", {
            password: e,
            ticket: r
        }), n.onTransition((t)=>{
            t.matches({
                idle: "error"
            }) ? s({
                error: t.context.error,
                isError: !0,
                isSuccess: !1
            }) : t.matches({
                idle: "success"
            }) && s({
                error: null,
                isError: !1,
                isSuccess: !0
            });
        });
    }), Er = (n)=>new Promise((e)=>{
        n.send("GENERATE"), n.onTransition((r)=>{
            r.matches("generated") ? e({
                error: null,
                isError: !1,
                isGenerated: !0,
                qrCodeDataUrl: r.context.imageUrl || "",
                totpSecret: r.context.secret
            }) : r.matches({
                idle: "error"
            }) && e({
                error: r.context.error || null,
                isError: !0,
                isGenerated: !1,
                qrCodeDataUrl: "",
                totpSecret: r.context.secret
            });
        });
    }), mr = (n, e)=>new Promise((r)=>{
        n.send("ACTIVATE", {
            activeMfaType: "totp",
            code: e
        }), n.onTransition((s)=>{
            s.matches({
                generated: "activated"
            }) ? r({
                error: null,
                isActivated: !0,
                isError: !1
            }) : s.matches({
                generated: {
                    idle: "error"
                }
            }) && r({
                error: s.context.error,
                isActivated: !1,
                isError: !0
            });
        });
    }), gr = (n, e)=>new Promise((r)=>{
        n.send("DISABLE", {
            code: e
        }), n.onTransition((s)=>{
            s.matches({
                idle: "disabled"
            }) ? r({
                error: null,
                isDisabled: !0,
                isError: !1
            }) : s.matches({
                idle: "error"
            }) && r({
                error: s.context.error,
                isDisabled: !1,
                isError: !0
            });
        });
    }), Ke = async (n, e, r)=>new Promise((s)=>{
        n.send("REQUEST", {
            email: e,
            options: r
        }), n.onTransition((t)=>{
            t.matches({
                idle: "error"
            }) ? s({
                error: t.context.error,
                isError: !0,
                isSent: !1
            }) : t.matches({
                idle: "success"
            }) && s({
                error: null,
                isError: !1,
                isSent: !0
            });
        });
    }), Ve = (n, e, r)=>new Promise((s)=>{
        n.send("REQUEST", {
            email: e,
            options: r
        }), n.onTransition((t)=>{
            t.matches({
                idle: "error"
            }) ? s({
                error: t.context.error,
                isError: !0,
                isSent: !1
            }) : t.matches({
                idle: "success"
            }) && s({
                error: null,
                isError: !1,
                isSent: !0
            });
        });
    }), Le = (n)=>new Promise((e)=>{
        const { changed: r } = n.send("SIGNIN_ANONYMOUS");
        r || e({
            isSuccess: !1,
            isError: !0,
            error: w,
            user: null,
            accessToken: null,
            refreshToken: null
        }), n.onTransition((s)=>{
            s.matches({
                authentication: "signedIn"
            }) && e({
                isSuccess: !0,
                isError: !1,
                error: null,
                user: s.context.user,
                accessToken: s.context.accessToken.value,
                refreshToken: s.context.refreshToken.value
            }), s.matches({
                authentication: {
                    signedOut: "failed"
                }
            }) && e({
                isSuccess: !1,
                isError: !0,
                error: s.context.errors.authentication || null,
                user: null,
                accessToken: null,
                refreshToken: null
            });
        });
    }), Ge = (n, e, r)=>new Promise((s)=>{
        const { changed: t, context: i } = n.send("SIGNIN_PASSWORD", {
            email: e,
            password: r
        });
        if (!t) return s({
            accessToken: i.accessToken.value,
            refreshToken: i.refreshToken.value,
            error: w,
            isError: !0,
            isSuccess: !1,
            needsEmailVerification: !1,
            needsMfaOtp: !1,
            mfa: null,
            user: i.user
        });
        n.onTransition((l)=>{
            l.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) ? s({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !0,
                needsMfaOtp: !1,
                mfa: null,
                user: null
            }) : l.matches({
                authentication: {
                    signedOut: "needsMfa"
                }
            }) ? s({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !1,
                needsMfaOtp: !0,
                mfa: l.context.mfa,
                user: null
            }) : l.matches({
                authentication: {
                    signedOut: "failed"
                }
            }) ? s({
                accessToken: null,
                refreshToken: null,
                error: l.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                needsEmailVerification: !1,
                needsMfaOtp: !1,
                mfa: null,
                user: null
            }) : l.matches({
                authentication: "signedIn"
            }) && s({
                accessToken: l.context.accessToken.value,
                refreshToken: l.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                needsEmailVerification: !1,
                needsMfaOtp: !1,
                mfa: null,
                user: l.context.user
            });
        });
    }), z = (n, e, r)=>new Promise((s)=>{
        const { changed: t } = n.send("PASSWORDLESS_EMAIL", {
            email: e,
            options: r
        });
        if (!t) return s({
            error: w,
            isError: !0,
            isSuccess: !1
        });
        n.onTransition((i)=>{
            i.matches("registration.incomplete.failed") ? s({
                error: i.context.errors.registration || null,
                isError: !0,
                isSuccess: !1
            }) : i.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) && s({
                error: null,
                isError: !1,
                isSuccess: !0
            });
        });
    }), He = (n, e)=>new Promise((r)=>{
        const { changed: s, context: t } = n.send({
            type: "SIGNIN_SECURITY_KEY_EMAIL",
            email: e
        });
        if (!s) return r({
            accessToken: t.accessToken.value,
            refreshToken: t.refreshToken.value,
            error: w,
            isError: !0,
            isSuccess: !1,
            needsEmailVerification: !1,
            user: t.user
        });
        n.onTransition((i)=>{
            i.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) ? r({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !0,
                user: null
            }) : i.matches({
                authentication: {
                    signedOut: "failed"
                }
            }) ? r({
                accessToken: null,
                refreshToken: null,
                error: i.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                needsEmailVerification: !1,
                user: null
            }) : i.matches({
                authentication: "signedIn"
            }) && r({
                accessToken: i.context.accessToken.value,
                refreshToken: i.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                needsEmailVerification: !1,
                user: i.context.user
            });
        });
    });
function te(n) {
    return {
        error: n.message || "Something went wrong!",
        status: n.status || 1,
        message: n.message || "Something went wrong!"
    };
}
const $e = async (n, e)=>{
    var l, f;
    const r = (l = n.interpreter) == null ? void 0 : l.getSnapshot(), s = r == null ? void 0 : r.context.accessToken.value;
    let t;
    try {
        t = (await I(`${n.backendUrl}/elevate/webauthn`, {
            email: e
        }, s)).data;
    } catch (h) {
        return {
            error: te(h),
            isError: !0,
            isSuccess: !1,
            elevated: !1
        };
    }
    let i;
    try {
        i = await q(t);
    } catch (h) {
        return {
            error: te(h),
            isError: !0,
            isSuccess: !1,
            elevated: !1
        };
    }
    try {
        const { data: { session: h }, error: E } = await I(`${n.backendUrl}/elevate/webauthn/verify`, {
            email: e,
            credential: i
        }, s);
        return h && !E ? ((f = n.interpreter) == null || f.send({
            type: "SESSION_UPDATE",
            data: {
                session: h
            }
        }), {
            error: null,
            isError: !1,
            isSuccess: !0,
            elevated: !0
        }) : {
            error: E,
            isError: !0,
            isSuccess: !1,
            elevated: !1
        };
    } catch (h) {
        const { error: E } = h;
        return {
            error: E,
            isError: !0,
            isSuccess: !1,
            elevated: !1
        };
    }
}, We = (n, e, r)=>new Promise((s)=>{
        const { changed: t, context: i } = n.send("SIGNIN_MFA_TOTP", {
            otp: e,
            ticket: r
        });
        if (!t) return s({
            accessToken: i.accessToken.value,
            refreshToken: i.refreshToken.value,
            error: w,
            isError: !0,
            isSuccess: !1,
            user: i.user
        });
        n.onTransition((l)=>{
            l.matches({
                authentication: {
                    signedOut: "failed"
                }
            }) ? s({
                accessToken: null,
                refreshToken: null,
                error: l.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                user: null
            }) : l.matches({
                authentication: "signedIn"
            }) && s({
                accessToken: l.context.accessToken.value,
                refreshToken: l.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                user: l.context.user
            });
        });
    }), Ye = (n, e)=>new Promise((r)=>{
        const { changed: s } = n.send("SIGNIN_PAT", {
            pat: e
        });
        s || r({
            isSuccess: !1,
            isError: !0,
            error: w,
            user: null,
            accessToken: null,
            refreshToken: null
        }), n.onTransition((t)=>{
            if (t.matches({
                authentication: {
                    signedOut: "failed"
                }
            })) return r({
                accessToken: null,
                refreshToken: null,
                user: null,
                error: t.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1
            });
            if (t.matches({
                authentication: "signedIn"
            })) return r({
                accessToken: t.context.accessToken.value,
                refreshToken: t.context.refreshToken.value,
                user: t.context.user,
                error: null,
                isError: !1,
                isSuccess: !0
            });
        });
    }), X = (n, e, r)=>new Promise((s)=>{
        const { changed: t } = n.send("PASSWORDLESS_SMS", {
            phoneNumber: e,
            options: r
        });
        if (!t) return s({
            error: w,
            isError: !0,
            isSuccess: !1,
            needsOtp: !1
        });
        n.onTransition((i)=>{
            i.matches("registration.incomplete.needsOtp") ? s({
                error: null,
                isError: !1,
                isSuccess: !1,
                needsOtp: !0
            }) : i.matches("registration.incomplete.failed") && s({
                error: i.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                needsOtp: !1
            });
        });
    }), Fe = (n, e, r)=>new Promise((s)=>{
        const { changed: t } = n.send({
            type: "PASSWORDLESS_SMS_OTP",
            phoneNumber: e,
            otp: r
        });
        if (!t) return s({
            error: w,
            isError: !0,
            isSuccess: !1,
            user: null,
            accessToken: null,
            refreshToken: null
        });
        n.onTransition((i)=>{
            i.matches({
                authentication: "signedIn"
            }) ? s({
                error: null,
                isError: !1,
                isSuccess: !0,
                user: i.context.user,
                accessToken: i.context.accessToken.value,
                refreshToken: i.context.refreshToken.value
            }) : i.matches({
                registration: {
                    incomplete: "failed"
                }
            }) && s({
                error: i.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                user: null,
                accessToken: null,
                refreshToken: null
            });
        });
    }), je = async (n, e)=>new Promise((r)=>{
        const { event: s } = n.send("SIGNOUT", {
            all: e
        });
        if (s.type !== "SIGNED_OUT") return r({
            isSuccess: !1,
            isError: !0,
            error: he
        });
        n.onTransition((t)=>{
            t.matches({
                authentication: {
                    signedOut: "success"
                }
            }) ? r({
                isSuccess: !0,
                isError: !1,
                error: null
            }) : t.matches("authentication.signedOut.failed") && r({
                isSuccess: !1,
                isError: !0,
                error: t.context.errors.signout || null
            });
        });
    }), Z = (n, e, r, s, t)=>new Promise((i)=>{
        const { changed: l, context: f } = n.send("SIGNUP_EMAIL_PASSWORD", {
            email: e,
            password: r,
            options: s,
            requestOptions: t
        });
        if (!l) return i({
            error: w,
            accessToken: f.accessToken.value,
            refreshToken: f.refreshToken.value,
            isError: !0,
            isSuccess: !1,
            needsEmailVerification: !1,
            user: f.user
        });
        n.onTransition((h)=>{
            h.matches("registration.incomplete.failed") ? i({
                accessToken: null,
                refreshToken: null,
                error: h.context.errors.registration || null,
                isError: !0,
                isSuccess: !1,
                needsEmailVerification: !1,
                user: null
            }) : h.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) ? i({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !0,
                user: null
            }) : h.matches({
                authentication: "signedIn",
                registration: "complete"
            }) && i({
                accessToken: h.context.accessToken.value,
                refreshToken: h.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                needsEmailVerification: !1,
                user: h.context.user
            });
        });
    }), qe = (n, e, r, s)=>new Promise((t)=>{
        const { changed: i, context: l } = n.send("SIGNUP_SECURITY_KEY", {
            email: e,
            options: r,
            requestOptions: s
        });
        if (!i) return t({
            error: w,
            accessToken: l.accessToken.value,
            refreshToken: l.refreshToken.value,
            isError: !0,
            isSuccess: !1,
            needsEmailVerification: !1,
            user: l.user
        });
        n.onTransition((f)=>{
            f.matches("registration.incomplete.failed") ? t({
                accessToken: null,
                refreshToken: null,
                error: f.context.errors.registration || null,
                isError: !0,
                isSuccess: !1,
                needsEmailVerification: !1,
                user: null
            }) : f.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) ? t({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !0,
                user: null
            }) : f.matches({
                authentication: "signedIn",
                registration: "complete"
            }) && t({
                accessToken: f.context.accessToken.value,
                refreshToken: f.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                needsEmailVerification: !1,
                user: f.context.user
            });
        });
    }), Be = (n, e, r)=>new Promise((s)=>{
        const { changed: t } = n.send("SIGNIN_EMAIL_OTP", {
            email: e,
            options: r
        });
        if (!t) return s({
            error: w,
            isError: !0,
            isSuccess: !1,
            needsOtp: !1
        });
        n.onTransition((i)=>{
            i.matches("registration.incomplete.needsOtp") ? s({
                error: null,
                isError: !1,
                isSuccess: !0,
                needsOtp: !0
            }) : i.matches("registration.incomplete.failed") && s({
                error: i.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                needsOtp: !1
            });
        });
    }), Qe = (n, e, r)=>new Promise((s)=>{
        const { changed: t } = n.send({
            type: "VERIFY_EMAIL_OTP",
            email: e,
            otp: r
        });
        if (!t) return s({
            error: w,
            isError: !0,
            isSuccess: !1,
            user: null,
            accessToken: null,
            refreshToken: null
        });
        n.onTransition((i)=>{
            i.matches({
                authentication: "signedIn"
            }) ? s({
                error: null,
                isError: !1,
                isSuccess: !0,
                user: i.context.user,
                accessToken: i.context.accessToken.value,
                refreshToken: i.context.refreshToken.value
            }) : i.matches({
                registration: {
                    incomplete: "failed"
                }
            }) && s({
                error: i.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                user: null,
                accessToken: null,
                refreshToken: null
            });
        });
    }), ze = (n, { provider: e, idToken: r, nonce: s })=>new Promise((t)=>{
        const { changed: i } = n.send("SIGNIN_ID_TOKEN", {
            provider: e,
            idToken: r,
            ...s && {
                nonce: s
            }
        });
        i || t({
            isSuccess: !1,
            isError: !0,
            error: w,
            user: null,
            accessToken: null,
            refreshToken: null
        }), n.onTransition((l)=>{
            if (l.matches({
                authentication: {
                    signedOut: "failed"
                }
            })) return t({
                accessToken: null,
                refreshToken: null,
                user: null,
                error: l.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1
            });
            if (l.matches({
                authentication: "signedIn"
            })) return t({
                accessToken: l.context.accessToken.value,
                refreshToken: l.context.refreshToken.value,
                user: l.context.user,
                error: null,
                isError: !1,
                isSuccess: !0
            });
        });
    }), Xe = async ({ backendUrl: n, interpreter: e }, { provider: r, idToken: s, nonce: t })=>{
    try {
        return await I(`${n}/link/idtoken`, {
            provider: r,
            idToken: s,
            ...t && {
                nonce: t
            }
        }, e == null ? void 0 : e.getSnapshot().context.accessToken.value), {
            isError: !1,
            error: null,
            isSuccess: !0
        };
    } catch (i) {
        const { error: l } = i;
        return {
            isError: !0,
            error: l,
            isSuccess: !1
        };
    }
}, Ze = (n)=>new Promise((e)=>{
        const { changed: r, context: s } = n.send({
            type: "SIGNIN_SECURITY_KEY"
        });
        if (!r) return e({
            accessToken: s.accessToken.value,
            refreshToken: s.refreshToken.value,
            error: w,
            isError: !0,
            isSuccess: !1,
            needsEmailVerification: !1,
            user: s.user
        });
        n.onTransition((t)=>{
            t.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) ? e({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !0,
                user: null
            }) : t.matches({
                authentication: {
                    signedOut: "failed"
                }
            }) ? e({
                accessToken: null,
                refreshToken: null,
                error: t.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                needsEmailVerification: !1,
                user: null
            }) : t.matches({
                authentication: "signedIn"
            }) && e({
                accessToken: t.context.accessToken.value,
                refreshToken: t.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                needsEmailVerification: !1,
                user: t.context.user
            });
        });
    }), Tr = async ({ backendUrl: n, interpreter: e }, { expiresAt: r, metadata: s })=>{
    try {
        const { data: t } = await I(`${n}/pat`, {
            expiresAt: r.toISOString(),
            metadata: s
        }, e == null ? void 0 : e.getSnapshot().context.accessToken.value);
        return {
            data: t ? {
                id: t.id || null,
                personalAccessToken: t.personalAccessToken || null
            } : null,
            isError: !1,
            error: null,
            isSuccess: !0
        };
    } catch (t) {
        const { error: i } = t;
        return {
            isError: !0,
            error: i,
            isSuccess: !1,
            data: null
        };
    }
};
class pr {
    constructor({ url: e, broadcastKey: r, autoRefreshToken: s = !0, autoSignIn: t = !0, clientStorage: i, clientStorageType: l, refreshIntervalTime: f, start: h = !0 }){
        var E;
        this.url = e, this._client = new se({
            backendUrl: e,
            clientUrl: "undefined" != "undefined" && ((E = window.location) == null ? void 0 : E.origin) || "",
            broadcastKey: r,
            autoRefreshToken: s,
            autoSignIn: t,
            start: h,
            clientStorage: i,
            clientStorageType: l,
            refreshIntervalTime: f
        });
    }
    async signUp(e, r) {
        const s = await this.waitUntilReady();
        if ("securityKey" in e) {
            const { email: f, options: h } = e;
            return _(await qe(s, f, h, r));
        }
        const { email: t, password: i, options: l } = e;
        return _(await Z(s, t, i, l, r));
    }
    async connectProvider(e) {
        const s = (await this.waitUntilReady()).getSnapshot().context.accessToken.value, { provider: t, options: i } = e, l = L(`${this._client.backendUrl}/signin/provider/${t}`, R(this._client.clientUrl, {
            ...i,
            connect: s
        }));
        return M() && (window.location.href = l), {
            providerUrl: l
        };
    }
    async signInIdToken(e) {
        const r = await this.waitUntilReady(), s = await ze(r, e);
        return {
            ..._(s),
            mfa: null
        };
    }
    async linkIdToken(e) {
        return Xe(this._client, e);
    }
    async signIn(e) {
        const r = await this.waitUntilReady();
        if (!e) {
            const s = await Le(r);
            return {
                ..._(s),
                mfa: null
            };
        }
        if ("provider" in e) {
            const { provider: s, options: t } = e, i = L(`${this._client.backendUrl}/signin/provider/${s}`, R(this._client.clientUrl, t));
            return M() && (window.location.href = i), {
                providerUrl: i,
                provider: s,
                session: null,
                mfa: null,
                error: null
            };
        }
        if ("email" in e && "password" in e) {
            const s = await Ge(r, e.email, e.password);
            return s.needsEmailVerification ? {
                session: null,
                mfa: null,
                error: fe
            } : s.needsMfaOtp ? {
                session: null,
                mfa: s.mfa,
                error: null
            } : {
                ..._(s),
                mfa: null
            };
        }
        if ("email" in e && "securityKey" in e) {
            if (e.securityKey !== !0) throw Error("securityKey must be true");
            const s = await He(r, e.email);
            return {
                ..._(s),
                mfa: null
            };
        }
        if ("email" in e) {
            const { email: s, options: t } = e, { error: i } = await z(r, s, t);
            return {
                session: null,
                mfa: null,
                error: i
            };
        }
        if ("phoneNumber" in e && "otp" in e) {
            const s = await Fe(r, e.phoneNumber, e.otp);
            return {
                ..._(s),
                mfa: null
            };
        }
        if ("phoneNumber" in e) {
            const { error: s } = await X(r, e.phoneNumber, e.options);
            return {
                error: s,
                mfa: null,
                session: null
            };
        }
        if ("otp" in e) {
            const s = await We(r, e.otp, e.ticket);
            return {
                ..._(s),
                mfa: null
            };
        }
        return {
            error: me,
            mfa: null,
            session: null
        };
    }
    async signInPAT(e) {
        const r = await this.waitUntilReady(), s = await Ye(r, e);
        return _(s);
    }
    async signInEmailOTP(e, r) {
        const s = await this.waitUntilReady(), { error: t } = await Be(s, e, r);
        return {
            error: t,
            session: null,
            mfa: null
        };
    }
    async verifyEmailOTP(e, r) {
        const s = await this.waitUntilReady(), t = await Qe(s, e, r);
        return {
            ..._(t),
            mfa: null
        };
    }
    async signInSecurityKey() {
        const e = await this.waitUntilReady(), r = await Ze(e);
        return {
            ..._(r),
            mfa: null
        };
    }
    async signOut(e) {
        const r = await this.waitUntilReady(), { error: s } = await je(r, e == null ? void 0 : e.all);
        return {
            error: s
        };
    }
    async resetPassword({ email: e, options: r }) {
        const s = u.interpret(be(this._client)).start(), { error: t } = await Ke(s, e, r);
        return {
            error: t
        };
    }
    async changePassword({ newPassword: e, ticket: r }) {
        const s = u.interpret(Ne(this._client)).start(), { error: t } = await Ue(s, e, r);
        return {
            error: t
        };
    }
    async sendVerificationEmail({ email: e, options: r }) {
        const s = u.interpret(De(this._client)).start(), { error: t } = await Ve(s, e, r);
        return {
            error: t
        };
    }
    async changeEmail({ newEmail: e, options: r }) {
        const s = u.interpret(Oe(this._client)).start(), { error: t } = await Me(s, e, r);
        return {
            error: t
        };
    }
    async deanonymize(e) {
        const r = await this.waitUntilReady();
        if (e.signInMethod === "passwordless") {
            if (e.connection === "email") {
                const { error: s } = await z(r, e.email, e.options);
                return {
                    error: s
                };
            }
            if (e.connection === "sms") {
                const { error: s } = await X(r, e.phoneNumber, e.options);
                return {
                    error: s
                };
            }
        }
        if (e.signInMethod === "email-password") {
            const { error: s } = await Z(r, e.email, e.password, e.options);
            return {
                error: s
            };
        }
        throw Error("Unknown deanonymization method");
    }
    async addSecurityKey(e) {
        const { error: r, key: s } = await xe(this._client, e);
        return {
            error: r,
            key: s
        };
    }
    async elevateEmailSecurityKey(e) {
        if (!e) throw Error("A user email is required");
        return {
            ...await $e(this._client, e),
            mfa: null
        };
    }
    async createPAT(e, r) {
        return Tr(this._client, {
            expiresAt: e,
            metadata: r
        });
    }
    onTokenChanged(e) {
        return this._client.subscribe(()=>{
            var s;
            const r = (s = this._client.interpreter) == null ? void 0 : s.onTransition(({ event: t, context: i })=>{
                t.type === "TOKEN_CHANGED" && e(C(i));
            });
            return ()=>r == null ? void 0 : r.stop();
        });
    }
    onAuthStateChanged(e) {
        return this._client.subscribe(()=>{
            var s;
            const r = (s = this._client.interpreter) == null ? void 0 : s.onTransition(({ event: t, context: i })=>{
                (t.type === "SIGNED_IN" || t.type === "SIGNED_OUT") && e(t.type, C(i));
            });
            return ()=>r == null ? void 0 : r.stop();
        });
    }
    isAuthenticated() {
        var e;
        return !!((e = this._client.interpreter) != null && e.getSnapshot().matches({
            authentication: "signedIn"
        }));
    }
    async isAuthenticatedAsync() {
        return (await this.waitUntilReady()).getSnapshot().matches({
            authentication: "signedIn"
        });
    }
    getAuthenticationStatus() {
        var r;
        const e = ((r = this.client.interpreter) == null ? void 0 : r.getSnapshot().context.importTokenAttempts) || 0;
        return this.isReady() ? {
            isAuthenticated: this.isAuthenticated(),
            isLoading: !1,
            connectionAttempts: e
        } : {
            isAuthenticated: !1,
            isLoading: !0,
            connectionAttempts: e
        };
    }
    getAccessToken() {
        var e, r;
        return (r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot().context.accessToken.value) != null ? r : void 0;
    }
    getDecodedAccessToken() {
        const e = this.getAccessToken();
        return e ? er.jwtDecode(e) : null;
    }
    getHasuraClaims() {
        var e;
        return ((e = this.getDecodedAccessToken()) == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
    }
    getHasuraClaim(e) {
        var r;
        return ((r = this.getHasuraClaims()) == null ? void 0 : r[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
    }
    async refreshSession(e) {
        try {
            const r = await this.waitUntilReady();
            return new Promise((s)=>{
                const t = e || r.getSnapshot().context.refreshToken.value;
                if (!t) return s({
                    session: null,
                    error: ue
                });
                const { changed: i } = r.send("TRY_TOKEN", {
                    token: t
                });
                if (!i) return s({
                    session: null,
                    error: de
                });
                r.onTransition((l)=>{
                    l.matches({
                        token: {
                            idle: "error"
                        }
                    }) ? s({
                        session: null,
                        error: Ee
                    }) : l.event.type === "TOKEN_CHANGED" && s({
                        session: C(l.context),
                        error: null
                    });
                });
            });
        } catch (r) {
            return {
                session: null,
                error: r.message
            };
        }
    }
    getSession() {
        var e, r;
        return C((r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : r.context);
    }
    async initWithSession({ session: e }) {
        this.client.start({
            initialSession: e
        }), await this.waitUntilReady();
    }
    getUser() {
        var e, r, s;
        return ((s = (r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : r.context) == null ? void 0 : s.user) || null;
    }
    waitUntilReady() {
        const r = this._client.interpreter;
        if (!r) throw Error("Auth interpreter not set");
        return r.getSnapshot().hasTag("loading") ? new Promise((s, t)=>{
            let i = setTimeout(()=>t("The state machine is not yet ready after 15 seconds."), 15e3);
            r.onTransition((l)=>{
                if (!l.hasTag("loading")) return clearTimeout(i), s(r);
            });
        }) : Promise.resolve(r);
    }
    isReady() {
        var e, r;
        return !((r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) != null && r.hasTag("loading"));
    }
    get client() {
        return this._client;
    }
}
exports.AuthClient = se;
exports.AuthClientSSR = fr;
exports.AuthCookieClient = Ce;
exports.CodifiedError = O;
exports.EMAIL_NEEDS_VERIFICATION = fe;
exports.HasuraAuthClient = pr;
exports.INITIAL_MACHINE_CONTEXT = U;
exports.INVALID_EMAIL_ERROR = k;
exports.INVALID_MFA_CODE_ERROR = ae;
exports.INVALID_MFA_TICKET_ERROR = ce;
exports.INVALID_MFA_TYPE_ERROR = oe;
exports.INVALID_PASSWORD_ERROR = V;
exports.INVALID_PHONE_NUMBER_ERROR = j;
exports.INVALID_REFRESH_TOKEN = Ee;
exports.INVALID_SIGN_IN_METHOD = me;
exports.MIN_PASSWORD_LENGTH = ie;
exports.NETWORK_ERROR_CODE = J;
exports.NHOST_JWT_EXPIRES_AT_KEY = v;
exports.NHOST_REFRESH_TOKEN_ID_KEY = D;
exports.NHOST_REFRESH_TOKEN_KEY = N;
exports.NO_MFA_TICKET_ERROR = le;
exports.NO_REFRESH_TOKEN = ue;
exports.OTHER_ERROR_CODE = ee;
exports.REFRESH_TOKEN_MAX_ATTEMPTS = F;
exports.STATE_ERROR_CODE = b;
exports.TOKEN_REFRESHER_RUNNING_ERROR = de;
exports.TOKEN_REFRESH_MARGIN_SECONDS = Y;
exports.USER_ALREADY_SIGNED_IN = w;
exports.USER_NOT_ANONYMOUS = sr;
exports.USER_UNAUTHENTICATED = he;
exports.VALIDATION_ERROR_CODE = A;
exports.activateMfaPromise = mr;
exports.addSecurityKeyPromise = xe;
exports.changeEmailPromise = Me;
exports.changePasswordPromise = Ue;
exports.createAuthMachine = ve;
exports.createChangeEmailMachine = Oe;
exports.createChangePasswordMachine = Ne;
exports.createEnableMfaMachine = hr;
exports.createResetPasswordMachine = be;
exports.createSendVerificationEmailMachine = De;
exports.disableMfaPromise = gr;
exports.elevateEmailSecurityKeyPromise = $e;
exports.encodeQueryParameters = L;
exports.generateQrCodePromise = Er;
exports.getAuthenticationResult = _;
exports.getFetch = Ae;
exports.getParameterByName = x;
exports.getSession = C;
exports.isBrowser = M;
exports.isValidEmail = y;
exports.isValidPassword = G;
exports.isValidPhoneNumber = Q;
exports.isValidTicket = Pe;
exports.linkIdTokenPromise = Xe;
exports.localStorageGetter = Re;
exports.localStorageSetter = _e;
exports.postFetch = I;
exports.removeParameterFromWindow = B;
exports.resetPasswordPromise = Ke;
exports.rewriteRedirectTo = R;
exports.sendVerificationEmailPromise = Ve;
exports.signInAnonymousPromise = Le;
exports.signInEmailOTPPromise = Be;
exports.signInEmailPasswordPromise = Ge;
exports.signInEmailPasswordlessPromise = z;
exports.signInEmailSecurityKeyPromise = He;
exports.signInIdTokenPromise = ze;
exports.signInMfaTotpPromise = We;
exports.signInPATPromise = Ye;
exports.signInSecurityKeyPromise = Ze;
exports.signInSmsPasswordlessOtpPromise = Fe;
exports.signInSmsPasswordlessPromise = X;
exports.signOutPromise = je;
exports.signUpEmailPasswordPromise = Z;
exports.signUpEmailSecurityKeyPromise = qe;
exports.verifyEmailOTPPromise = Qe; //# sourceMappingURL=index.cjs.js.map
}}),
"[project]/node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
module.exports = DelayedStream;
function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);
DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for(var option in options){
        delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
    };
    source.on('error', function() {});
    if (delayedStream.pauseStream) {
        source.pause();
    }
    return delayedStream;
};
Object.defineProperty(DelayedStream.prototype, 'readable', {
    configurable: true,
    enumerable: true,
    get: function() {
        return this.source.readable;
    }
});
DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream.prototype.resume = function() {
    if (!this._released) {
        this.release();
    }
    this.source.resume();
};
DelayedStream.prototype.pause = function() {
    this.source.pause();
};
DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach((function(args) {
        this.emit.apply(this, args);
    }).bind(this));
    this._bufferedEvents = [];
};
DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
};
DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
        this.emit.apply(this, args);
        return;
    }
    if (args[0] === 'data') {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
};
DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
        return;
    }
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    this._maxDataSizeExceeded = true;
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this.emit('error', new Error(message));
};
}}),
"[project]/node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var DelayedStream = __turbopack_context__.r("[project]/node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js [app-ssr] (ecmascript)");
module.exports = CombinedStream;
function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);
CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for(var option in options){
        combinedStream[option] = options[option];
    }
    return combinedStream;
};
CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== 'function' && typeof stream !== 'string' && typeof stream !== 'boolean' && typeof stream !== 'number' && !Buffer.isBuffer(stream);
};
CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
            var newStream = DelayedStream.create(stream, {
                maxDataSize: Infinity,
                pauseStream: this.pauseStreams
            });
            stream.on('data', this._checkDataSize.bind(this));
            stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
            stream.pause();
        }
    }
    this._streams.push(stream);
    return this;
};
CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
};
CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
        this._pendingNext = true;
        return; // defer call
    }
    this._insideLoop = true;
    try {
        do {
            this._pendingNext = false;
            this._realGetNext();
        }while (this._pendingNext)
    } finally{
        this._insideLoop = false;
    }
};
CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == 'undefined') {
        this.end();
        return;
    }
    if (typeof stream !== 'function') {
        this._pipeNext(stream);
        return;
    }
    var getStream = stream;
    getStream((function(stream) {
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
            stream.on('data', this._checkDataSize.bind(this));
            this._handleErrors(stream);
        }
        this._pipeNext(stream);
    }).bind(this));
};
CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        stream.on('end', this._getNext.bind(this));
        stream.pipe(this, {
            end: false
        });
        return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
};
CombinedStream.prototype._handleErrors = function(stream) {
    var self = this;
    stream.on('error', function(err) {
        self._emitError(err);
    });
};
CombinedStream.prototype.write = function(data) {
    this.emit('data', data);
};
CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
        return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == 'function') this._currentStream.pause();
    this.emit('pause');
};
CombinedStream.prototype.resume = function() {
    if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == 'function') this._currentStream.resume();
    this.emit('resume');
};
CombinedStream.prototype.end = function() {
    this._reset();
    this.emit('end');
};
CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit('close');
};
CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
};
CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this._emitError(new Error(message));
};
CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self = this;
    this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
            return;
        }
        self.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
    }
};
CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit('error', err);
};
}}),
"[project]/node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module dependencies.
 * @private
 */ var db = __turbopack_context__.r("[project]/node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js [app-ssr] (ecmascript)");
var extname = __turbopack_context__.r("[externals]/path [external] (path, cjs)").extname;
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().substr(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    // source preference (least -> most)
    var preference = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            if (types[extension]) {
                var from = preference.indexOf(db[types[extension]].source);
                var to = preference.indexOf(mime.source);
                if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
                    continue;
                }
            }
            // set the extension -> mime
            types[extension] = type;
        }
    });
}
}}),
"[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = defer;
/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */ function defer(fn) {
    var nextTick = typeof setImmediate == 'function' ? setImmediate : typeof process == 'object' && typeof process.nextTick == 'function' ? process.nextTick : null;
    if (nextTick) {
        nextTick(fn);
    } else {
        setTimeout(fn, 0);
    }
}
}}),
"[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var defer = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js [app-ssr] (ecmascript)");
// API
module.exports = async;
/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */ function async(callback) {
    var isAsync = false;
    // check if async happened
    defer(function() {
        isAsync = true;
    });
    return function async_callback(err, result) {
        if (isAsync) {
            callback(err, result);
        } else {
            defer(function nextTick_callback() {
                callback(err, result);
            });
        }
    };
}
}}),
"[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
// API
module.exports = abort;
/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */ function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    // reset leftover jobs
    state.jobs = {};
}
/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */ function clean(key) {
    if (typeof this.jobs[key] == 'function') {
        this.jobs[key]();
    }
}
}}),
"[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var async = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js [app-ssr] (ecmascript)"), abort = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js [app-ssr] (ecmascript)");
// API
module.exports = iterate;
/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */ function iterate(list, iterator, state, callback) {
    // store current index
    var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        // don't repeat yourself
        // skip secondary callbacks
        if (!(key in state.jobs)) {
            return;
        }
        // clean up jobs
        delete state.jobs[key];
        if (error) {
            // don't process rest of the results
            // stop still active jobs
            // and reset the list
            abort(state);
        } else {
            state.results[key] = output;
        }
        // return salvaged results
        callback(error, state.results);
    });
}
/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */ function runJob(iterator, key, item, callback) {
    var aborter;
    // allow shortcut if iterator expects only two arguments
    if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
    } else {
        aborter = iterator(item, key, async(callback));
    }
    return aborter;
}
}}),
"[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
// API
module.exports = state;
/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */ function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
        // sort array keys based on it's values
        // sort object's keys just on own merit
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
            return sortMethod(list[a], list[b]);
        });
    }
    return initState;
}
}}),
"[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var abort = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js [app-ssr] (ecmascript)"), async = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js [app-ssr] (ecmascript)");
// API
module.exports = terminator;
/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */ function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
        return;
    }
    // fast forward iteration index
    this.index = this.size;
    // abort jobs
    abort(this);
    // send back results we have so far
    async(callback)(null, this.results);
}
}}),
"[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var iterate = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js [app-ssr] (ecmascript)"), initState = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js [app-ssr] (ecmascript)"), terminator = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js [app-ssr] (ecmascript)");
// Public API
module.exports = parallel;
/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function parallel(list, iterator, callback) {
    var state = initState(list);
    while(state.index < (state['keyedList'] || list).length){
        iterate(list, iterator, state, function(error, result) {
            if (error) {
                callback(error, result);
                return;
            }
            // looks like it's the last one
            if (Object.keys(state.jobs).length === 0) {
                callback(null, state.results);
                return;
            }
        });
        state.index++;
    }
    return terminator.bind(state, callback);
}
}}),
"[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var iterate = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js [app-ssr] (ecmascript)"), initState = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js [app-ssr] (ecmascript)"), terminator = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js [app-ssr] (ecmascript)");
// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending = ascending;
module.exports.descending = descending;
/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
            callback(error, result);
            return;
        }
        state.index++;
        // are we there yet?
        if (state.index < (state['keyedList'] || list).length) {
            iterate(list, iterator, state, iteratorHandler);
            return;
        }
        // done here
        callback(null, state.results);
    });
    return terminator.bind(state, callback);
}
/*
 * -- Sort methods
 */ /**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function descending(a, b) {
    return -1 * ascending(a, b);
}
}}),
"[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var serialOrdered = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js [app-ssr] (ecmascript)");
// Public API
module.exports = serial;
/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
}
}}),
"[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = {
    parallel: __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js [app-ssr] (ecmascript)"),
    serial: __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js [app-ssr] (ecmascript)"),
    serialOrdered: __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js [app-ssr] (ecmascript)")
};
}}),
"[project]/node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('.')} */ module.exports = Object;
}}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('.')} */ module.exports = Error;
}}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./eval')} */ module.exports = EvalError;
}}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./range')} */ module.exports = RangeError;
}}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./ref')} */ module.exports = ReferenceError;
}}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./syntax')} */ module.exports = SyntaxError;
}}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./type')} */ module.exports = TypeError;
}}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./uri')} */ module.exports = URIError;
}}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./abs')} */ module.exports = Math.abs;
}}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./floor')} */ module.exports = Math.floor;
}}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./max')} */ module.exports = Math.max;
}}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./min')} */ module.exports = Math.min;
}}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./pow')} */ module.exports = Math.pow;
}}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./round')} */ module.exports = Math.round;
}}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./isNaN')} */ module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
};
}}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var $isNaN = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js [app-ssr] (ecmascript)");
/** @type {import('./sign')} */ module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
        return number;
    }
    return number < 0 ? -1 : +1;
};
}}),
"[project]/node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;
}}),
"[project]/node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('.')} */ var $gOPD = __turbopack_context__.r("[project]/node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js [app-ssr] (ecmascript)");
if ($gOPD) {
    try {
        $gOPD([], 'length');
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
    }
}
module.exports = $gOPD;
}}),
"[project]/node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
    try {
        $defineProperty({}, 'a', {
            value: 1
        });
    } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
    }
}
module.exports = $defineProperty;
}}),
"[project]/node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./shams')} */ /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }
    /** @type {{ [k in symbol]?: unknown }} */ var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(var _ in obj){
        return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        // eslint-disable-next-line no-extra-parens
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }
    return true;
};
}}),
"[project]/node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __turbopack_context__.r("[project]/node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }
    return hasSymbolSham();
};
}}),
"[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./Reflect.getPrototypeOf')} */ module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
}}),
"[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var $Object = __turbopack_context__.r("[project]/node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js [app-ssr] (ecmascript)");
/** @type {import('./Object.getPrototypeOf')} */ module.exports = $Object.getPrototypeOf || null;
}}),
"[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var reflectGetProto = __turbopack_context__.r("[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js [app-ssr] (ecmascript)");
var originalGetProto = __turbopack_context__.r("[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js [app-ssr] (ecmascript)");
var getDunderProto = __turbopack_context__.r("[project]/node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ module.exports = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
        throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
} : null;
}}),
"[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1){
        arr[i] = a[i];
    }
    for(var j = 0; j < b.length; j += 1){
        arr[j + a.length] = b[j];
    }
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
        arr[j] = arrLike[i];
    }
    return arr;
};
var joiny = function(arr, joiner) {
    var str = '';
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++){
        boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};
}}),
"[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var implementation = __turbopack_context__.r("[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js [app-ssr] (ecmascript)");
module.exports = Function.prototype.bind || implementation;
}}),
"[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./functionCall')} */ module.exports = Function.prototype.call;
}}),
"[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./functionApply')} */ module.exports = Function.prototype.apply;
}}),
"[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @type {import('./reflectApply')} */ module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
}}),
"[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var bind = __turbopack_context__.r("[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js [app-ssr] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js [app-ssr] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js [app-ssr] (ecmascript)");
var $reflectApply = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js [app-ssr] (ecmascript)");
/** @type {import('./actualApply')} */ module.exports = $reflectApply || bind.call($call, $apply);
}}),
"[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var bind = __turbopack_context__.r("[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js [app-ssr] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-ssr] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js [app-ssr] (ecmascript)");
var $actualApply = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js [app-ssr] (ecmascript)");
/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */ module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
};
}}),
"[project]/node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var callBind = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js [app-ssr] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js [app-ssr] (ecmascript)");
var hasProtoAccessor;
try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
} catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
    }
}
// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;
/** @type {import('./get')} */ module.exports = desc && typeof desc.get === 'function' ? callBind([
    desc.get
]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */ function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
} : false;
}}),
"[project]/node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __turbopack_context__.r("[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);
}}),
"[project]/node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var undefined1;
var $Object = __turbopack_context__.r("[project]/node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js [app-ssr] (ecmascript)");
var $Error = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js [app-ssr] (ecmascript)");
var $EvalError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js [app-ssr] (ecmascript)");
var $RangeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js [app-ssr] (ecmascript)");
var $ReferenceError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js [app-ssr] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js [app-ssr] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-ssr] (ecmascript)");
var $URIError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js [app-ssr] (ecmascript)");
var abs = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js [app-ssr] (ecmascript)");
var floor = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js [app-ssr] (ecmascript)");
var max = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js [app-ssr] (ecmascript)");
var min = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js [app-ssr] (ecmascript)");
var pow = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js [app-ssr] (ecmascript)");
var round = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js [app-ssr] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js [app-ssr] (ecmascript)");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = __turbopack_context__.r("[project]/node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js [app-ssr] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js [app-ssr] (ecmascript)");
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = __turbopack_context__.r("[project]/node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js [app-ssr] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js [app-ssr] (ecmascript)");
var $ObjectGPO = __turbopack_context__.r("[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js [app-ssr] (ecmascript)");
var $ReflectGPO = __turbopack_context__.r("[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js [app-ssr] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js [app-ssr] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js [app-ssr] (ecmascript)");
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    '%EvalError%': $EvalError,
    '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
    try {
        null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
    }
}
var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
            value = getProto(gen.prototype);
        }
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = __turbopack_context__.r("[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js [app-ssr] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js [app-ssr] (ecmascript)");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};
}}),
"[project]/node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var hasSymbols = __turbopack_context__.r("[project]/node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};
}}),
"[project]/node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js [app-ssr] (ecmascript)");
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var hasToStringTag = __turbopack_context__.r("[project]/node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js [app-ssr] (ecmascript)")();
var hasOwn = __turbopack_context__.r("[project]/node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js [app-ssr] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-ssr] (ecmascript)");
var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
/** @type {import('.')} */ module.exports = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean' || typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean') {
        throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
    }
    if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
            $defineProperty(object, toStringTag, {
                configurable: !nonConfigurable,
                enumerable: false,
                value: value,
                writable: false
            });
        } else {
            object[toStringTag] = value; // eslint-disable-line no-param-reassign
        }
    }
};
}}),
"[project]/node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/populate.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// populates missing values
module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop]; // eslint-disable-line no-param-reassign
    });
    return dst;
};
}}),
"[project]/node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/form_data.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var CombinedStream = __turbopack_context__.r("[project]/node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js [app-ssr] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var parseUrl = __turbopack_context__.r("[externals]/url [external] (url, cjs)").parse;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
var mime = __turbopack_context__.r("[project]/node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js [app-ssr] (ecmascript)");
var asynckit = __turbopack_context__.r("[project]/node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js [app-ssr] (ecmascript)");
var setToStringTag = __turbopack_context__.r("[project]/node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js [app-ssr] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js [app-ssr] (ecmascript)");
var populate = __turbopack_context__.r("[project]/node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/populate.js [app-ssr] (ecmascript)");
/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {object} options - Properties to be added/overriden for FormData and CombinedStream
 */ function FormData(options) {
    if (!(this instanceof FormData)) {
        return new FormData(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {}; // eslint-disable-line no-param-reassign
    for(var option in options){
        this[option] = options[option];
    }
}
// make it a Stream
util.inherits(FormData, CombinedStream);
FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
FormData.prototype.append = function(field, value, options) {
    options = options || {}; // eslint-disable-line no-param-reassign
    // allow filename as single option
    if (typeof options === 'string') {
        options = {
            filename: options
        }; // eslint-disable-line no-param-reassign
    }
    var append = CombinedStream.prototype.append.bind(this);
    // all that streamy business can't handle numbers
    if (typeof value === 'number' || value == null) {
        value = String(value); // eslint-disable-line no-param-reassign
    }
    // https://github.com/felixge/node-form-data/issues/38
    if (Array.isArray(value)) {
        /*
     * Please convert your array into string
     * the way web server expects it
     */ this._error(new Error('Arrays are not supported.'));
        return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    // pass along options.knownLength
    this._trackLength(header, value, options);
};
FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    /*
   * used w/ getLengthSync(), when length is known.
   * e.g. for streaming directly from a remote server,
   * w/ a known file a size, and not wanting to wait for
   * incoming file to finish to get its size.
   */ if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
    } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
    } else if (typeof value === 'string') {
        valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    // @check why add CRLF? does this account for custom/multiple CRLFs?
    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    // empty or either doesn't have path or not an http response or not a stream
    if (!value || !value.path && !(value.readable && hasOwn(value, 'httpVersion')) && !(value instanceof Stream)) {
        return;
    }
    // no need to bother with the length
    if (!options.knownLength) {
        this._valuesToMeasure.push(value);
    }
};
FormData.prototype._lengthRetriever = function(value, callback) {
    if (hasOwn(value, 'fd')) {
        // take read range into a account
        // `end` = Infinity > read file till the end
        //
        // TODO: Looks like there is bug in Node fs.createReadStream
        // it doesn't respect `end` options without `start` options
        // Fix it when node fixes it.
        // https://github.com/joyent/node/issues/7819
        if (value.end != undefined && value.end != Infinity && value.start != undefined) {
            // when end specified
            // no need to calculate range
            // inclusive, starts with 0
            callback(null, value.end + 1 - (value.start ? value.start : 0)); // eslint-disable-line callback-return
        // not that fast snoopy
        } else {
            // still need to fetch file size from fs
            fs.stat(value.path, function(err, stat) {
                if (err) {
                    callback(err);
                    return;
                }
                // update final size based on the range options
                var fileSize = stat.size - (value.start ? value.start : 0);
                callback(null, fileSize);
            });
        }
    // or http response
    } else if (hasOwn(value, 'httpVersion')) {
        callback(null, Number(value.headers['content-length'])); // eslint-disable-line callback-return
    // or request stream http://github.com/mikeal/request
    } else if (hasOwn(value, 'httpModule')) {
        // wait till response come back
        value.on('response', function(response) {
            value.pause();
            callback(null, Number(response.headers['content-length']));
        });
        value.resume();
    // something else
    } else {
        callback('Unknown stream'); // eslint-disable-line callback-return
    }
};
FormData.prototype._multiPartHeader = function(field, value, options) {
    /*
   * custom header specified (as string)?
   * it becomes responsible for boundary
   * (e.g. to handle extra CRLFs on .NET servers)
   */ if (typeof options.header === 'string') {
        return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = '';
    var headers = {
        // add custom disposition as third element or keep it two elements if not
        'Content-Disposition': [
            'form-data',
            'name="' + field + '"'
        ].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        'Content-Type': [].concat(contentType || [])
    };
    // allow custom headers.
    if (typeof options.header === 'object') {
        populate(headers, options.header);
    }
    var header;
    for(var prop in headers){
        if (hasOwn(headers, prop)) {
            header = headers[prop];
            // skip nullish headers.
            if (header == null) {
                continue; // eslint-disable-line no-restricted-syntax, no-continue
            }
            // convert all headers to arrays.
            if (!Array.isArray(header)) {
                header = [
                    header
                ];
            }
            // add non-empty headers.
            if (header.length) {
                contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
            }
        }
    }
    return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};
FormData.prototype._getContentDisposition = function(value, options) {
    var filename;
    if (typeof options.filepath === 'string') {
        // custom filepath for relative paths
        filename = path.normalize(options.filepath).replace(/\\/g, '/');
    } else if (options.filename || value && (value.name || value.path)) {
        /*
     * custom filename take precedence
     * formidable and the browser add a name property
     * fs- and request- streams have path property
     */ filename = path.basename(options.filename || value && (value.name || value.path));
    } else if (value && value.readable && hasOwn(value, 'httpVersion')) {
        // or try http response
        filename = path.basename(value.client._httpMessage.path || '');
    }
    if (filename) {
        return 'filename="' + filename + '"';
    }
};
FormData.prototype._getContentType = function(value, options) {
    // use custom content-type above all
    var contentType = options.contentType;
    // or try `name` from formidable, browser
    if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
    }
    // or try `path` from fs-, request- streams
    if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
    }
    // or if it's http-reponse
    if (!contentType && value && value.readable && hasOwn(value, 'httpVersion')) {
        contentType = value.headers['content-type'];
    }
    // or guess it from the filepath or filename
    if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
    }
    // fallback to the default content type if `value` is not simple value
    if (!contentType && value && typeof value === 'object') {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
};
FormData.prototype._multiPartFooter = function() {
    return (function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
            footer += this._lastBoundary();
        }
        next(footer);
    }).bind(this);
};
FormData.prototype._lastBoundary = function() {
    return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};
FormData.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
        'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
    };
    for(header in userHeaders){
        if (hasOwn(userHeaders, header)) {
            formHeaders[header.toLowerCase()] = userHeaders[header];
        }
    }
    return formHeaders;
};
FormData.prototype.setBoundary = function(boundary) {
    if (typeof boundary !== 'string') {
        throw new TypeError('FormData boundary must be a string');
    }
    this._boundary = boundary;
};
FormData.prototype.getBoundary = function() {
    if (!this._boundary) {
        this._generateBoundary();
    }
    return this._boundary;
};
FormData.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0); // eslint-disable-line new-cap
    var boundary = this.getBoundary();
    // Create the form content. Add Line breaks to the end of data.
    for(var i = 0, len = this._streams.length; i < len; i++){
        if (typeof this._streams[i] !== 'function') {
            // Add content to the buffer.
            if (Buffer.isBuffer(this._streams[i])) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    this._streams[i]
                ]);
            } else {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(this._streams[i])
                ]);
            }
            // Add break after content.
            if (typeof this._streams[i] !== 'string' || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(FormData.LINE_BREAK)
                ]);
            }
        }
    }
    // Add the footer and return the Buffer object.
    return Buffer.concat([
        dataBuffer,
        Buffer.from(this._lastBoundary())
    ]);
};
FormData.prototype._generateBoundary = function() {
    // This generates a 50 character boundary similar to those used by Firefox.
    // They are optimized for boyer-moore parsing.
    this._boundary = '--------------------------' + crypto.randomBytes(12).toString('hex');
};
// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually and add it as knownLength option
FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    // Don't get confused, there are 3 "internal" streams for each keyval pair so it basically checks if there is any value added to the form
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    // https://github.com/form-data/form-data/issues/40
    if (!this.hasKnownLength()) {
        /*
     * Some async length retrievers are present
     * therefore synchronous length calculation is false.
     * Please use getLength(callback) to get proper length
     */ this._error(new Error('Cannot calculate proper length in synchronous way.'));
    }
    return knownLength;
};
// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
        hasKnownLength = false;
    }
    return hasKnownLength;
};
FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
            cb(err);
            return;
        }
        values.forEach(function(length) {
            knownLength += length;
        });
        cb(null, knownLength);
    });
};
FormData.prototype.submit = function(params, cb) {
    var request;
    var options;
    var defaults = {
        method: 'post'
    };
    // parse provided url if it's string or treat it as options object
    if (typeof params === 'string') {
        params = parseUrl(params); // eslint-disable-line no-param-reassign
        /* eslint sort-keys: 0 */ options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
        }, defaults);
    } else {
        options = populate(params, defaults);
        // if no port provided use default one
        if (!options.port) {
            options.port = options.protocol === 'https:' ? 443 : 80;
        }
    }
    // put that good code in getHeaders to some use
    options.headers = this.getHeaders(params.headers);
    // https if specified, fallback to http in any other case
    if (options.protocol === 'https:') {
        request = https.request(options);
    } else {
        request = http.request(options);
    }
    // get content length and fire away
    this.getLength((function(err, length) {
        if (err && err !== 'Unknown stream') {
            this._error(err);
            return;
        }
        // add content length
        if (length) {
            request.setHeader('Content-Length', length);
        }
        this.pipe(request);
        if (cb) {
            var onResponse;
            var callback = function(error, responce) {
                request.removeListener('error', callback);
                request.removeListener('response', onResponse);
                return cb.call(this, error, responce); // eslint-disable-line no-invalid-this
            };
            onResponse = callback.bind(this, null);
            request.on('error', callback);
            request.on('response', onResponse);
        }
    }).bind(this));
    return request;
};
FormData.prototype._error = function(err) {
    if (!this.error) {
        this.error = err;
        this.pause();
        this.emit('error', err);
    }
};
FormData.prototype.toString = function() {
    return '[object FormData]';
};
setToStringTag(FormData, 'FormData');
// Public API
module.exports = FormData;
}}),
"[project]/node_modules/.pnpm/@nhost+hasura-storage-js@2.8.0/node_modules/@nhost/hasura-storage-js/dist/index.cjs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var C = Object.defineProperty;
var N = (t, e, r)=>e in t ? C(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r;
var f = (t, e, r)=>N(t, typeof e != "symbol" ? e + "" : e, r);
Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const x = __turbopack_context__.r("[project]/node_modules/.pnpm/fetch-ponyfill@7.1.0/node_modules/fetch-ponyfill/fetch-node.js [app-ssr] (ecmascript)"), T = __turbopack_context__.r("[project]/node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/form_data.js [app-ssr] (ecmascript)"), d = __turbopack_context__.r("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/index.js [app-ssr] (ecmascript)");
let M = globalThis.fetch;
const O = async (t, e, { accessToken: r, name: s, fileId: a, bucketId: i, adminSecret: o, onUploadProgress: l, headers: c = {} } = {})=>{
    var L;
    const h = {
        ...c
    };
    i && e.append("bucket-id", i), o && (h["x-hasura-admin-secret"] = o), r && (h.Authorization = `Bearer ${r}`);
    const U = `${t}/files`;
    if (typeof XMLHttpRequest == "undefined") try {
        e instanceof T && (M = x().fetch);
        const u = await M(U, {
            method: "POST",
            headers: h,
            body: e
        }), n = await u.json();
        return u.ok ? {
            fileMetadata: n,
            error: null
        } : {
            error: {
                status: u.status,
                message: ((L = n == null ? void 0 : n.error) == null ? void 0 : L.message) || u.statusText,
                error: u.statusText
            },
            fileMetadata: null
        };
    } catch (u) {
        return {
            error: {
                status: 0,
                message: u.message,
                error: u.message
            },
            fileMetadata: null
        };
    }
    return new Promise((u)=>{
        let n = new XMLHttpRequest;
        n.responseType = "json", n.onload = ()=>{
            var p, g, w, S, F, _, I, R;
            if (n.status < 200 || n.status >= 300) {
                const b = {
                    error: (F = (S = (g = (p = n.response) == null ? void 0 : p.error) == null ? void 0 : g.message) != null ? S : (w = n.response) == null ? void 0 : w.error) != null ? F : n.response,
                    message: (R = (I = (_ = n.response) == null ? void 0 : _.error) == null ? void 0 : I.message) != null ? R : n.response,
                    status: n.status
                };
                return u({
                    fileMetadata: null,
                    error: b
                });
            }
            return u({
                fileMetadata: n.response,
                error: null
            });
        }, n.onerror = ()=>{
            const p = {
                error: n.statusText,
                message: n.statusText,
                status: n.status
            };
            return u({
                fileMetadata: null,
                error: p
            });
        }, l && n.upload.addEventListener("progress", l, !1), n.open("POST", U, !0), Object.entries(h).forEach(([p, g])=>{
            n.setRequestHeader(p, g);
        }), n.send(e);
    });
};
function A(t, e) {
    if (!e || Object.keys(e).length === 0) return t;
    const r = new URL(t), s = Object.entries(e).reduce((a, [i, o])=>({
            ...a,
            [i.charAt(0)]: o
        }), {});
    return Object.entries(s).forEach(([a, i])=>{
        i && r.searchParams.set(a, i);
    }), r.toString();
}
let m;
typeof m == "undefined" && (m = x().fetch);
class k {
    constructor({ url: e }){
        f(this, "url");
        f(this, "accessToken");
        f(this, "adminSecret");
        f(this, "headers", {});
        this.url = e;
    }
    async uploadFormData({ formData: e, bucketId: r, headers: s }) {
        const { error: a, fileMetadata: i } = await O(this.url, e, {
            bucketId: r,
            headers: {
                ...this.headers,
                ...s
            },
            accessToken: this.accessToken,
            adminSecret: this.adminSecret
        });
        return a ? {
            fileMetadata: null,
            error: a
        } : i && !("processedFiles" in i) ? {
            fileMetadata: {
                processedFiles: [
                    i
                ]
            },
            error: null
        } : {
            fileMetadata: i,
            error: null
        };
    }
    async uploadFile({ file: e, bucketId: r, id: s, name: a, headers: i }) {
        const o = ("TURBOPACK compile-time truthy", 1) ? new T : "TURBOPACK unreachable";
        o.append("file[]", e), o.append("metadata[]", JSON.stringify({
            id: s,
            name: a
        }));
        const { error: l, fileMetadata: c } = await O(this.url, o, {
            accessToken: this.accessToken,
            adminSecret: this.adminSecret,
            bucketId: r,
            fileId: s,
            name: a,
            headers: {
                ...this.headers,
                ...i
            }
        });
        return l ? {
            fileMetadata: null,
            error: l
        } : c && "processedFiles" in c ? {
            fileMetadata: c.processedFiles[0],
            error: null
        } : {
            fileMetadata: c,
            error: null
        };
    }
    async downloadFile(e) {
        try {
            const { fileId: r, headers: s, ...a } = e, i = A(`${this.url}/files/${r}`, a), o = await m(i, {
                method: "GET",
                headers: {
                    ...this.generateAuthHeaders(),
                    ...this.headers,
                    ...s
                }
            });
            if (!o.ok) throw new Error(await o.text());
            return {
                file: await o.blob(),
                error: null
            };
        } catch (r) {
            return {
                file: null,
                error: r
            };
        }
    }
    async getPresignedUrl(e) {
        try {
            const { fileId: r, headers: s } = e, a = await m(`${this.url}/files/${r}/presignedurl`, {
                method: "GET",
                headers: {
                    ...this.generateAuthHeaders(),
                    ...this.headers,
                    ...s
                }
            });
            if (!a.ok) throw new Error(await a.text());
            return {
                presignedUrl: await a.json(),
                error: null
            };
        } catch (r) {
            return {
                presignedUrl: null,
                error: r
            };
        }
    }
    async delete(e) {
        try {
            const { fileId: r, headers: s } = e, a = await m(`${this.url}/files/${r}`, {
                method: "DELETE",
                headers: {
                    ...this.generateAuthHeaders(),
                    ...this.headers,
                    ...s
                }
            });
            if (!a.ok) throw new Error(await a.text());
            return {
                error: null
            };
        } catch (r) {
            return {
                error: r
            };
        }
    }
    setAccessToken(e) {
        return this.accessToken = e, this;
    }
    setAdminSecret(e) {
        return this.adminSecret = e, this;
    }
    getHeaders() {
        return this.headers;
    }
    setHeaders(e) {
        return e ? (this.headers = {
            ...this.headers,
            ...e
        }, this) : this;
    }
    unsetHeaders() {
        const e = this.headers["x-hasura-role"];
        return this.headers = e ? {
            "x-hasura-role": e
        } : {}, this;
    }
    generateAuthHeaders() {
        if (!(!this.adminSecret && !this.accessToken)) return this.adminSecret ? {
            "x-hasura-admin-secret": this.adminSecret
        } : {
            Authorization: `Bearer ${this.accessToken}`
        };
    }
}
class $ {
    constructor({ url: e, adminSecret: r }){
        f(this, "url");
        f(this, "api");
        this.url = e, this.api = new k({
            url: e
        }), this.setAdminSecret(r);
    }
    async upload(e) {
        return "file" in e ? this.api.uploadFile(e) : this.api.uploadFormData(e);
    }
    getPublicUrl(e) {
        const { fileId: r, ...s } = e;
        return A(`${this.url}/files/${r}`, s);
    }
    async getPresignedUrl(e) {
        const { fileId: r, headers: s, ...a } = e, { presignedUrl: i, error: o } = await this.api.getPresignedUrl(e);
        if (o) return {
            presignedUrl: null,
            error: o
        };
        if (!i) return {
            presignedUrl: null,
            error: new Error("Invalid file id")
        };
        const l = A(i.url, a);
        return {
            presignedUrl: {
                ...i,
                url: l
            },
            error: null
        };
    }
    async download(e) {
        const { file: r, error: s } = await this.api.downloadFile(e);
        return s ? {
            file: null,
            error: s
        } : r ? {
            file: r,
            error: null
        } : {
            file: null,
            error: new Error("File does not exist")
        };
    }
    async delete(e) {
        const { error: r } = await this.api.delete(e);
        return r ? {
            error: r
        } : {
            error: null
        };
    }
    setAccessToken(e) {
        return this.api.setAccessToken(e), this;
    }
    setAdminSecret(e) {
        return this.api.setAdminSecret(e), this;
    }
    getHeaders() {
        return this.api.getHeaders();
    }
    setHeaders(e) {
        return this.api.setHeaders(e), this;
    }
    unsetHeaders() {
        return this.api.unsetHeaders(), this;
    }
}
let D;
typeof D == "undefined" && (D = T);
const y = {
    progress: null,
    loaded: 0,
    error: null,
    bucketId: void 0,
    file: void 0,
    id: void 0
}, H = ()=>d.createMachine({
        predictableActionArguments: !0,
        schema: {
            context: {},
            events: {}
        },
        tsTypes: {},
        context: {
            ...y
        },
        initial: "idle",
        on: {
            DESTROY: {
                actions: "sendDestroy",
                target: "stopped"
            }
        },
        states: {
            idle: {
                on: {
                    ADD: {
                        actions: "addFile"
                    },
                    UPLOAD: {
                        cond: "hasFile",
                        target: "uploading"
                    }
                }
            },
            uploading: {
                entry: "resetProgress",
                on: {
                    UPLOAD_PROGRESS: {
                        actions: [
                            "incrementProgress",
                            "sendProgress"
                        ]
                    },
                    UPLOAD_DONE: "uploaded",
                    UPLOAD_ERROR: "error",
                    CANCEL: "idle"
                },
                invoke: {
                    src: "uploadFile"
                }
            },
            uploaded: {
                entry: [
                    "setFileMetadata",
                    "sendDone"
                ],
                on: {
                    ADD: {
                        actions: "addFile",
                        target: "idle"
                    },
                    UPLOAD: {
                        actions: "resetContext",
                        target: "uploading"
                    }
                }
            },
            error: {
                entry: [
                    "setError",
                    "sendError"
                ],
                on: {
                    ADD: {
                        actions: "addFile",
                        target: "idle"
                    },
                    UPLOAD: {
                        actions: "resetContext",
                        target: "uploading"
                    }
                }
            },
            stopped: {
                type: "final"
            }
        }
    }, {
        guards: {
            hasFile: (t, e)=>!!t.file || !!e.file
        },
        actions: {
            incrementProgress: d.assign({
                loaded: (t, { loaded: e })=>e,
                progress: (t, { progress: e })=>e
            }),
            setFileMetadata: d.assign({
                id: (t, { id: e })=>e,
                bucketId: (t, { bucketId: e })=>e,
                progress: (t)=>100
            }),
            setError: d.assign({
                error: (t, { error: e })=>e
            }),
            sendProgress: ()=>{},
            sendError: ()=>{},
            sendDestroy: ()=>{},
            sendDone: ()=>{},
            resetProgress: d.assign({
                progress: (t)=>null,
                loaded: (t)=>0
            }),
            resetContext: d.assign((t)=>y),
            addFile: d.assign({
                file: (t, { file: e })=>e,
                bucketId: (t, { bucketId: e })=>e,
                id: (t, { id: e })=>e
            })
        },
        services: {
            uploadFile: (t, e)=>(r)=>{
                    const s = e.file || t.file, a = new D;
                    a.append("file[]", s);
                    let i = 0;
                    return O(e.url, a, {
                        fileId: e.id || t.id,
                        bucketId: e.bucketId || t.bucketId,
                        accessToken: e.accessToken,
                        adminSecret: e.adminSecret,
                        name: e.name || s.name,
                        onUploadProgress: (o)=>{
                            const l = o.total ? Math.round(o.loaded * s.size / o.total) : 0, c = l - i;
                            i = l, r({
                                type: "UPLOAD_PROGRESS",
                                progress: o.total ? Math.round(l * 100 / o.total) : 0,
                                loaded: l,
                                additions: c
                            });
                        }
                    }).then(({ fileMetadata: o, error: l })=>{
                        if (l && r({
                            type: "UPLOAD_ERROR",
                            error: l
                        }), o && !("processedFiles" in o)) {
                            const { id: c, bucketId: h } = o;
                            r({
                                type: "UPLOAD_DONE",
                                id: c,
                                bucketId: h
                            });
                        }
                        if (o && "processedFiles" in o) {
                            const { id: c, bucketId: h } = o.processedFiles[0];
                            r({
                                type: "UPLOAD_DONE",
                                id: c,
                                bucketId: h
                            });
                        }
                    }), ()=>{};
                }
        }
    }), { pure: E, sendParent: P } = d.actions, j = ()=>d.createMachine({
        id: "files-list",
        schema: {
            context: {},
            events: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        context: {
            progress: null,
            files: [],
            loaded: 0,
            total: 0
        },
        initial: "idle",
        on: {
            UPLOAD: {
                cond: "hasFileToDownload",
                actions: "addItem",
                target: "uploading"
            },
            ADD: {
                actions: "addItem"
            },
            REMOVE: {
                actions: "removeItem"
            }
        },
        states: {
            idle: {
                entry: [
                    "resetProgress",
                    "resetLoaded",
                    "resetTotal"
                ],
                on: {
                    CLEAR: {
                        actions: "clearList",
                        target: "idle"
                    }
                }
            },
            uploading: {
                entry: [
                    "upload",
                    "startProgress",
                    "resetLoaded",
                    "resetTotal"
                ],
                on: {
                    UPLOAD_PROGRESS: {
                        actions: [
                            "incrementProgress"
                        ]
                    },
                    UPLOAD_DONE: [
                        {
                            cond: "isAllUploaded",
                            target: "uploaded"
                        },
                        {
                            cond: "isAllUploadedOrError",
                            target: "error"
                        }
                    ],
                    UPLOAD_ERROR: [
                        {
                            cond: "isAllUploaded",
                            target: "uploaded"
                        },
                        {
                            cond: "isAllUploadedOrError",
                            target: "error"
                        }
                    ],
                    CANCEL: {
                        actions: "cancel",
                        target: "idle"
                    }
                }
            },
            uploaded: {
                entry: "setUploaded",
                on: {
                    CLEAR: {
                        actions: "clearList",
                        target: "idle"
                    }
                }
            },
            error: {
                on: {
                    CLEAR: {
                        actions: "clearList",
                        target: "idle"
                    }
                }
            }
        }
    }, {
        guards: {
            hasFileToDownload: (t, e)=>t.files.some((r)=>r.getSnapshot().matches("idle")) || !!e.files,
            isAllUploaded: (t)=>t.files.every((e)=>{
                    var r;
                    return (r = e.getSnapshot()) == null ? void 0 : r.matches("uploaded");
                }),
            isAllUploadedOrError: (t)=>t.files.every((e)=>{
                    const r = e.getSnapshot();
                    return (r == null ? void 0 : r.matches("error")) || (r == null ? void 0 : r.matches("uploaded"));
                })
        },
        actions: {
            incrementProgress: d.assign((t, e)=>{
                const r = t.loaded + e.additions, s = Math.round(r * 100 / t.total);
                return {
                    ...t,
                    loaded: r,
                    progress: s
                };
            }),
            setUploaded: d.assign({
                progress: (t)=>100,
                loaded: ({ files: t })=>t.map((e)=>e.getSnapshot()).filter((e)=>e.matches("uploaded")).reduce((e, r)=>{
                        var s;
                        return e + ((s = r.context.file) == null ? void 0 : s.size);
                    }, 0)
            }),
            resetTotal: d.assign({
                total: ({ files: t })=>t.map((e)=>e.getSnapshot()).filter((e)=>!e.matches("uploaded")).reduce((e, r)=>{
                        var s;
                        return e + ((s = r.context.file) == null ? void 0 : s.size);
                    }, 0)
            }),
            resetLoaded: d.assign({
                loaded: (t)=>0
            }),
            startProgress: d.assign({
                progress: (t)=>0
            }),
            resetProgress: d.assign({
                progress: (t)=>null
            }),
            addItem: d.assign((t, { files: e, bucketId: r })=>{
                const s = e ? Array.isArray(e) ? e : "item" in e ? Array.from(e) : [
                    e
                ] : [], a = t.total + s.reduce((o, l)=>o + l.size, 0), i = Math.round(t.loaded * 100 / a);
                return {
                    files: [
                        ...t.files,
                        ...s.map((o)=>d.spawn(H().withConfig({
                                actions: {
                                    sendProgress: P((l, { additions: c })=>({
                                            type: "UPLOAD_PROGRESS",
                                            additions: c
                                        })),
                                    sendDone: P("UPLOAD_DONE"),
                                    sendError: P("UPLOAD_ERROR"),
                                    sendDestroy: P("REMOVE")
                                }
                            }).withContext({
                                ...y,
                                file: o,
                                bucketId: r
                            }), {
                                sync: !0
                            }))
                    ],
                    total: a,
                    loaded: t.loaded,
                    progress: i
                };
            }),
            removeItem: d.assign({
                files: (t)=>t.files.filter((e)=>{
                        var s, a;
                        const r = (s = e.getSnapshot()) == null ? void 0 : s.matches("stopped");
                        return r && ((a = e.stop) == null || a.call(e)), !r;
                    })
            }),
            clearList: E((t)=>t.files.map((e)=>d.send({
                        type: "DESTROY"
                    }, {
                        to: e.id
                    }))),
            upload: E((t, e)=>t.files.map((r)=>d.send(e, {
                        to: r.id
                    }))),
            cancel: E((t)=>t.files.map((e)=>d.send({
                        type: "CANCEL"
                    }, {
                        to: e.id
                    })))
        }
    }), q = async (t, e)=>new Promise((r)=>{
        e.send({
            type: "UPLOAD",
            ...t
        }), e.subscribe((s)=>{
            var a;
            s.matches("error") ? r({
                error: s.context.error,
                isError: !0,
                isUploaded: !1
            }) : s.matches("uploaded") && r({
                error: null,
                isError: !1,
                isUploaded: !0,
                id: s.context.id,
                bucketId: s.context.id,
                name: (a = s.context.file) == null ? void 0 : a.name
            });
        });
    }), z = async (t, e)=>new Promise((r)=>{
        e.send({
            type: "UPLOAD",
            ...t,
            files: t.files
        }), e.onTransition((s)=>{
            s.matches("error") ? r({
                errors: s.context.files.filter((a)=>{
                    var i;
                    return (i = a.getSnapshot()) == null ? void 0 : i.context.error;
                }),
                isError: !0,
                files: []
            }) : s.matches("uploaded") && r({
                errors: [],
                isError: !1,
                files: s.context.files
            });
        });
    });
exports.HasuraStorageApi = k;
exports.HasuraStorageClient = $;
exports.INITIAL_FILE_CONTEXT = y;
exports.appendImageTransformationParameters = A;
exports.createFileUploadMachine = H;
exports.createMultipleFilesUploadMachine = j;
exports.uploadFilePromise = q;
exports.uploadMultipleFilesPromise = z; //# sourceMappingURL=index.cjs.js.map
}}),
"[project]/node_modules/.pnpm/unfetch@4.2.0/node_modules/unfetch/dist/unfetch.module.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
function __TURBOPACK__default__export__(e, n) {
    return n = n || {}, new Promise(function(t, r) {
        var s = new XMLHttpRequest, o = [], u = [], i = {}, a = function() {
            return {
                ok: 2 == (s.status / 100 | 0),
                statusText: s.statusText,
                status: s.status,
                url: s.responseURL,
                text: function() {
                    return Promise.resolve(s.responseText);
                },
                json: function() {
                    return Promise.resolve(s.responseText).then(JSON.parse);
                },
                blob: function() {
                    return Promise.resolve(new Blob([
                        s.response
                    ]));
                },
                clone: a,
                headers: {
                    keys: function() {
                        return o;
                    },
                    entries: function() {
                        return u;
                    },
                    get: function(e) {
                        return i[e.toLowerCase()];
                    },
                    has: function(e) {
                        return e.toLowerCase() in i;
                    }
                }
            };
        };
        for(var l in s.open(n.method || "get", e, !0), s.onload = function() {
            s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e, n, t) {
                o.push(n = n.toLowerCase()), u.push([
                    n,
                    t
                ]), i[n] = i[n] ? i[n] + "," + t : t;
            }), t(a());
        }, s.onerror = r, s.withCredentials = "include" == n.credentials, n.headers)s.setRequestHeader(l, n.headers[l]);
        s.send(n.body || null);
    });
} //# sourceMappingURL=unfetch.module.js.map
}),
"[project]/node_modules/.pnpm/isomorphic-unfetch@3.1.0/node_modules/isomorphic-unfetch/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
function r(m) {
    return m && m.default || m;
}
module.exports = ("TURBOPACK ident replacement", globalThis).fetch = ("TURBOPACK ident replacement", globalThis).fetch || (typeof process == 'undefined' ? r(__turbopack_context__.r("[project]/node_modules/.pnpm/unfetch@4.2.0/node_modules/unfetch/dist/unfetch.module.js [app-ssr] (ecmascript)")) : function(url, opts) {
    return r(__turbopack_context__.r("[project]/node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/lib/index.mjs [app-ssr] (ecmascript)"))(String(url).replace(/^\/\//g, 'https://'), opts);
});
}}),
"[project]/node_modules/.pnpm/@nhost+graphql-js@0.3.0_graphql@16.11.0/node_modules/@nhost/graphql-js/dist/index.cjs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const T = __turbopack_context__.r("[project]/node_modules/.pnpm/isomorphic-unfetch@3.1.0/node_modules/isomorphic-unfetch/index.js [app-ssr] (ecmascript)"), c = __turbopack_context__.r("[project]/node_modules/.pnpm/graphql@16.11.0/node_modules/graphql/index.mjs [app-ssr] (ecmascript)"), m = __turbopack_context__.r("[project]/node_modules/.pnpm/jwt-decode@4.0.0/node_modules/jwt-decode/build/cjs/index.js [app-ssr] (ecmascript)");
function g(r, e, s) {
    return r.document ? r : {
        document: r,
        variables: e,
        config: s
    };
}
function l(r) {
    var n;
    let e;
    const s = r.definitions.filter((t)=>t.kind === "OperationDefinition");
    return s.length === 1 && (e = (n = s[0].name) == null ? void 0 : n.value), e;
}
function k(r) {
    if (typeof r == "string") {
        let s;
        try {
            const n = c.parse(r);
            s = l(n);
        } catch  {}
        return {
            query: r,
            operationName: s
        };
    }
    const e = l(r);
    return {
        query: c.print(r),
        operationName: e
    };
}
class y {
    constructor(e){
        this.headers = {}, this.isAccessTokenValidOrNull = ()=>{
            if (!this.accessToken) return !0;
            try {
                const t = m.jwtDecode(this.accessToken);
                return t.exp != null && t.exp * 1e3 > Date.now();
            } catch (t) {
                return console.error("Error decoding token:", t), !1;
            }
        }, this.awaitForValidAccessTokenOrNull = async ()=>{
            if (this.isAccessTokenValidOrNull()) return !0;
            const t = ()=>this.isAccessTokenValidOrNull() ? Promise.resolve(!0) : new Promise((i)=>{
                    setTimeout(()=>t().then(i), 100);
                });
            return t();
        };
        const { url: s, adminSecret: n } = e;
        this._url = s, this.accessToken = null, this.adminSecret = n;
    }
    async request(e, ...s) {
        const [n, t] = s, i = g(e, n, t), { headers: h, ...d } = t || {}, { query: p, operationName: f } = k(i.document);
        typeof process != "undefined" && !process.env.TEST_MODE && await this.awaitForValidAccessTokenOrNull();
        try {
            const a = await T(this.httpUrl, {
                method: "POST",
                body: JSON.stringify({
                    operationName: f,
                    query: p,
                    variables: n
                }),
                headers: {
                    "Content-Type": "application/json",
                    ...this.generateAccessTokenHeaders(),
                    ...this.headers,
                    ...h
                },
                ...d
            });
            if (!a.ok) return {
                data: null,
                error: {
                    error: a.statusText,
                    message: a.statusText,
                    status: a.status
                }
            };
            const { data: o, errors: u } = await a.json();
            return u ? {
                data: null,
                error: u
            } : typeof o != "object" || Array.isArray(o) || o === null ? {
                data: null,
                error: {
                    error: "invalid-response",
                    message: "incorrect response data from GraphQL server",
                    status: 0
                }
            } : {
                data: o,
                error: null
            };
        } catch (a) {
            const o = a;
            return {
                data: null,
                error: {
                    message: o.message,
                    status: o.name === "AbortError" ? 0 : 500,
                    error: o.name === "AbortError" ? "abort-error" : "unknown"
                }
            };
        }
    }
    get httpUrl() {
        return this._url;
    }
    get wsUrl() {
        return this._url.replace(/^(http)(s?):\/\//, "ws$2://");
    }
    get url() {
        return this._url;
    }
    getUrl() {
        return this._url;
    }
    setAccessToken(e) {
        if (!e) {
            this.accessToken = null;
            return;
        }
        this.accessToken = e;
    }
    getHeaders() {
        return this.headers;
    }
    setHeaders(e) {
        e && (this.headers = {
            ...this.headers,
            ...e
        });
    }
    unsetHeaders() {
        const e = this.headers["x-hasura-role"];
        this.headers = e ? {
            "x-hasura-role": e
        } : {};
    }
    generateAccessTokenHeaders() {
        return this.adminSecret ? {
            "x-hasura-admin-secret": this.adminSecret
        } : this.accessToken ? {
            Authorization: `Bearer ${this.accessToken}`
        } : {};
    }
}
exports.NhostGraphqlClient = y; //# sourceMappingURL=index.cjs.js.map
}}),
"[project]/node_modules/.pnpm/@nhost+nhost-js@3.3.0_graphql@16.11.0/node_modules/@nhost/nhost-js/dist/index.cjs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var k = Object.defineProperty;
var q = (t, e, r)=>e in t ? k(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r;
var a = (t, e, r)=>q(t, typeof e != "symbol" ? e + "" : e, r);
Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const p = __turbopack_context__.r("[project]/node_modules/.pnpm/@nhost+hasura-auth-js@2.12.0/node_modules/@nhost/hasura-auth-js/dist/index.cjs.js [app-ssr] (ecmascript)"), T = __turbopack_context__.r("[project]/node_modules/.pnpm/@nhost+hasura-storage-js@2.8.0/node_modules/@nhost/hasura-storage-js/dist/index.cjs.js [app-ssr] (ecmascript)"), y = __turbopack_context__.r("[project]/node_modules/.pnpm/isomorphic-unfetch@3.1.0/node_modules/isomorphic-unfetch/index.js [app-ssr] (ecmascript)"), H = __turbopack_context__.r("[project]/node_modules/.pnpm/@nhost+graphql-js@0.3.0_graphql@16.11.0/node_modules/@nhost/graphql-js/dist/index.cjs.js [app-ssr] (ecmascript)"), v = /^((?<protocol>http[s]?):\/\/)?(?<host>(localhost|local))(:(?<port>(\d+|__\w+__)))?$/;
function f(t, e) {
    const { subdomain: r, region: n } = t;
    if (!r) throw new Error("A `subdomain` must be set.");
    const u = r.match(v);
    if (u != null && u.groups) {
        const { protocol: h, host: i, port: l } = u.groups, s = E(e);
        return s || (i === "localhost" ? (console.warn('The `subdomain` is set to "localhost". Support for this will be removed in a future release. Please use "local" instead.'), `${h || "http"}://localhost:${l || 1337}/v1/${e}`) : l ? `${h || "https"}://local.${e}.local.nhost.run:${l}/v1` : `${h || "https"}://local.${e}.local.nhost.run/v1`);
    }
    if (!n) throw new Error('`region` must be set when using a `subdomain` other than "local".');
    return `https://${r}.${e}.${n}.nhost.run/v1`;
}
function U() {
    return "undefined" != "undefined";
}
function $() {
    return typeof process != "undefined" && process.env;
}
function E(t) {
    return U() || !$() ? null : process.env[`NHOST_${t.toUpperCase()}_URL`];
}
function O(t, e) {
    const n = e.startsWith("/") ? e : `/${e}`;
    return t + n;
}
function b(t) {
    const e = "subdomain" in t ? f(t, "auth") : t.authUrl, { subdomain: r, region: n } = t;
    if (!e) throw new Error("Please provide `subdomain` or `authUrl`.");
    return new p.HasuraAuthClient({
        url: e,
        broadcastKey: `${r}${n != null ? n : "local"}`,
        ...t
    });
}
function w(t) {
    const e = "subdomain" in t ? f(t, "functions") : t.functionsUrl;
    if (!e) throw new Error("Please provide `subdomain` or `functionsUrl`.");
    return new m({
        url: e,
        ...t
    });
}
class m {
    constructor(e){
        a(this, "url");
        a(this, "accessToken");
        a(this, "adminSecret");
        a(this, "headers", {});
        const { url: r, adminSecret: n } = e;
        this.url = r, this.accessToken = null, this.adminSecret = n;
    }
    async call(e, r, n) {
        var i, l;
        const u = {
            "Content-Type": "application/json",
            ...this.generateAccessTokenHeaders(),
            ...n == null ? void 0 : n.headers,
            ...this.headers
        }, h = O(this.url, e);
        try {
            const s = await y(h, {
                body: r ? JSON.stringify(r) : null,
                headers: u,
                method: "POST"
            });
            if (!s.ok) {
                let c;
                return (i = s.headers.get("content-type")) != null && i.includes("application/json") ? c = await s.json() : c = await s.text(), {
                    res: null,
                    error: {
                        message: c,
                        error: s.statusText,
                        status: s.status
                    }
                };
            }
            let o;
            return (l = s.headers.get("content-type")) != null && l.includes("application/json") ? o = await s.json() : o = await s.text(), {
                res: {
                    data: o,
                    status: s.status,
                    statusText: s.statusText
                },
                error: null
            };
        } catch (s) {
            const o = s;
            return {
                res: null,
                error: {
                    message: o.message,
                    status: o.name === "AbortError" ? 0 : 500,
                    error: o.name === "AbortError" ? "abort-error" : "unknown"
                }
            };
        }
    }
    setAccessToken(e) {
        if (!e) {
            this.accessToken = null;
            return;
        }
        this.accessToken = e;
    }
    getHeaders() {
        return this.headers;
    }
    setHeaders(e) {
        e && (this.headers = {
            ...this.headers,
            ...e
        });
    }
    unsetHeaders() {
        const e = this.headers["x-hasura-role"];
        this.headers = e ? {
            "x-hasura-role": e
        } : {};
    }
    generateAccessTokenHeaders() {
        return this.adminSecret ? {
            "x-hasura-admin-secret": this.adminSecret
        } : this.accessToken ? {
            Authorization: `Bearer ${this.accessToken}`
        } : {};
    }
}
function S(t) {
    const e = "subdomain" in t ? f(t, "graphql") : t.graphqlUrl;
    if (!e) throw new Error("Please provide `subdomain` or `graphqlUrl`.");
    return new H.NhostGraphqlClient({
        url: e,
        ...t
    });
}
function A(t) {
    const e = "subdomain" in t ? f(t, "storage") : t.storageUrl;
    if (!e) throw new Error("Please provide `subdomain` or `storageUrl`.");
    return new T.HasuraStorageClient({
        url: e,
        ...t
    });
}
const _ = (t)=>new C(t);
class C {
    constructor({ refreshIntervalTime: e, clientStorage: r, clientStorageType: n, autoRefreshToken: u, autoSignIn: h, adminSecret: i, devTools: l, start: s = !0, ...o }){
        a(this, "auth");
        a(this, "storage");
        a(this, "functions");
        a(this, "graphql");
        a(this, "_adminSecret");
        a(this, "devTools");
        this.auth = b({
            refreshIntervalTime: e,
            clientStorage: r,
            clientStorageType: n,
            autoRefreshToken: u,
            autoSignIn: h,
            start: s,
            ...o
        }), this.storage = A({
            adminSecret: i,
            ...o
        }), this.functions = w({
            adminSecret: i,
            ...o
        }), this.graphql = S({
            adminSecret: i,
            ...o
        }), this.auth.onAuthStateChanged((c, d)=>{
            if (c === "SIGNED_OUT") {
                this.storage.setAccessToken(void 0), this.functions.setAccessToken(void 0), this.graphql.setAccessToken(void 0);
                return;
            }
            const g = d == null ? void 0 : d.accessToken;
            this.storage.setAccessToken(g), this.functions.setAccessToken(g), this.graphql.setAccessToken(g);
        }), this.auth.onTokenChanged((c)=>{
            const d = c == null ? void 0 : c.accessToken;
            this.storage.setAccessToken(d), this.functions.setAccessToken(d), this.graphql.setAccessToken(d);
        }), this._adminSecret = i, this.devTools = l;
    }
    get adminSecret() {
        return this._adminSecret;
    }
    set adminSecret(e) {
        this._adminSecret = e, this.storage.setAdminSecret(e);
    }
    setRole(e) {
        this.graphql.setHeaders({
            "x-hasura-role": e
        }), this.storage.setHeaders({
            "x-hasura-role": e
        }), this.functions.setHeaders({
            "x-hasura-role": e
        });
    }
    unsetRole() {
        this.graphql.setHeaders((({ "x-hasura-role": e, ...r })=>r)(this.graphql.getHeaders())), this.storage.setHeaders((({ "x-hasura-role": e, ...r })=>r)(this.storage.getHeaders())), this.functions.setHeaders((({ "x-hasura-role": e, ...r })=>r)(this.functions.getHeaders()));
    }
}
exports.NhostClient = C;
exports.NhostFunctionsClient = m;
exports.createAuthClient = b;
exports.createFunctionsClient = w;
exports.createGraphqlClient = S;
exports.createNhostClient = _;
exports.createStorageClient = A;
exports.urlFromSubdomain = f;
Object.keys(p).forEach((t)=>{
    t !== "default" && !Object.prototype.hasOwnProperty.call(exports, t) && Object.defineProperty(exports, t, {
        enumerable: !0,
        get: ()=>p[t]
    });
});
Object.keys(T).forEach((t)=>{
    t !== "default" && !Object.prototype.hasOwnProperty.call(exports, t) && Object.defineProperty(exports, t, {
        enumerable: !0,
        get: ()=>T[t]
    });
}); //# sourceMappingURL=index.cjs.js.map
}}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
;
;
;
;
;
;
;
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript) <locals>");
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useConstant.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>useConstant
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
;
function useConstant(fn) {
    var ref = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"]();
    if (!ref.current) {
        ref.current = {
            v: fn()
        };
    }
    return ref.current.v;
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useInterpret.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "useIdleInterpreter": ()=>useIdleInterpreter,
    "useInterpret": ()=>useInterpret
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$isomorphic$2d$layout$2d$effect$40$1$2e$2$2e$1_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0$2f$node_modules$2f$use$2d$isomorphic$2d$layout$2d$effect$2f$dist$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/use-isomorphic-layout-effect@1.2.1_@types+react@19.1.9_react@19.1.0/node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/interpreter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$State$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/State.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useConstant.js [app-ssr] (ecmascript)");
var __assign = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
var __read = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
;
;
;
;
function useIdleInterpreter(getMachine, options) {
    var machine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        return typeof getMachine === 'function' ? getMachine() : getMachine;
    });
    if (("TURBOPACK compile-time value", "development") !== 'production' && typeof getMachine !== 'function') {
        var _a = __read((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(machine), 1), initialMachine = _a[0];
        if (getMachine !== initialMachine) {
            console.warn('Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\n' + 'Please make sure that you pass the same Machine as argument each time.');
        }
    }
    var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, [
        "context",
        "guards",
        "actions",
        "activities",
        "services",
        "delays",
        "state"
    ]);
    var service = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        var machineConfig = {
            context: context,
            guards: guards,
            actions: actions,
            activities: activities,
            services: services,
            delays: delays
        };
        var machineWithConfig = machine.withConfig(machineConfig, function() {
            return __assign(__assign({}, machine.context), context);
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["interpret"])(machineWithConfig, interpreterOptions);
    });
    // Make sure options are kept updated when they change.
    // This mutation assignment is safe because the service instance is only used
    // in one place -- this hook's caller.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$isomorphic$2d$layout$2d$effect$40$1$2e$2$2e$1_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0$2f$node_modules$2f$use$2d$isomorphic$2d$layout$2d$effect$2f$dist$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        Object.assign(service.machine.options.actions, actions);
        Object.assign(service.machine.options.guards, guards);
        Object.assign(service.machine.options.activities, activities);
        Object.assign(service.machine.options.services, services);
        Object.assign(service.machine.options.delays, delays);
    }, [
        actions,
        guards,
        activities,
        services,
        delays
    ]);
    return service;
}
function useInterpret(getMachine) {
    var _a = [];
    for(var _i = 1; _i < arguments.length; _i++){
        _a[_i - 1] = arguments[_i];
    }
    var _b = __read(_a, 2), _c = _b[0], options = _c === void 0 ? {} : _c, observerOrListener = _b[1];
    var service = useIdleInterpreter(getMachine, options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        if (!observerOrListener) {
            return;
        }
        var sub = service.subscribe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toObserver"])(observerOrListener));
        return function() {
            sub.unsubscribe();
        };
    }, [
        observerOrListener
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        var rehydratedState = options.state;
        service.start(rehydratedState ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$State$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].create(rehydratedState) : undefined);
        return function() {
            service.stop();
            service.status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterpreterStatus"].NotStarted;
        };
    }, []);
    return service;
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getServiceSnapshot": ()=>getServiceSnapshot,
    "isInterpreterStateEqual": ()=>isInterpreterStateEqual,
    "isService": ()=>isService,
    "partition": ()=>partition,
    "shallowEqual": ()=>shallowEqual
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/interpreter.js [app-ssr] (ecmascript)");
var __read = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __values = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
;
function partition(items, predicate) {
    var e_1, _a;
    var _b = __read([
        [],
        []
    ], 2), truthy = _b[0], falsy = _b[1];
    try {
        for(var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()){
            var item = items_1_1.value;
            if (predicate(item)) {
                truthy.push(item);
            } else {
                falsy.push(item);
            }
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    return [
        truthy,
        falsy
    ];
}
function getServiceSnapshot(service) {
    return service.status !== 0 ? service.getSnapshot() : service.machine.initialState;
}
// From https://github.com/reduxjs/react-redux/blob/master/src/utils/shallowEqual.ts
function is(x, y) {
    if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function shallowEqual(objA, objB) {
    if (is(objA, objB)) return true;
    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
        return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for(var i = 0; i < keysA.length; i++){
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
        }
    }
    return true;
}
function isService(actor) {
    return 'state' in actor && 'machine' in actor;
}
function isInterpreterStateEqual(service, prevState, nextState) {
    if (service.status === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterpreterStatus"].NotStarted) {
        return true;
    }
    // Only change the current state if:
    // - the incoming state is the "live" initial state (since it might have new actors)
    // - OR the incoming state actually changed.
    //
    // The "live" initial state will have .changed === undefined.
    var initialStateChanged = nextState.changed === undefined && (Object.keys(nextState.children).length > 0 || typeof prevState.changed === 'boolean');
    return !(nextState.changed || initialStateChanged);
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useMachine.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "useMachine": ()=>useMachine
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$5$2e$0_react$40$19$2e$1$2e$0$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/shim/with-selector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/interpreter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$State$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/State.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useInterpret.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/utils.js [app-ssr] (ecmascript)");
var __read = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
;
;
;
;
;
function identity(a) {
    return a;
}
function useMachine(getMachine) {
    var _a = [];
    for(var _i = 1; _i < arguments.length; _i++){
        _a[_i - 1] = arguments[_i];
    }
    var _b = __read(_a, 1), _c = _b[0], options = _c === void 0 ? {} : _c;
    // using `useIdleInterpreter` allows us to subscribe to the service *before* we start it
    // so we don't miss any notifications
    var service = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useIdleInterpreter"])(getMachine, options);
    var getSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function() {
        if (service.status === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterpreterStatus"].NotStarted) {
            return options.state ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$State$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].create(options.state) : service.machine.initialState;
        }
        return service.getSnapshot();
    }, [
        service
    ]);
    var isEqual = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function(prevState, nextState) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInterpreterStateEqual"])(service, prevState, nextState);
    }, [
        service
    ]);
    var subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function(handleStoreChange) {
        var unsubscribe = service.subscribe(handleStoreChange).unsubscribe;
        return unsubscribe;
    }, [
        service
    ]);
    var storeSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$5$2e$0_react$40$19$2e$1$2e$0$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSyncExternalStoreWithSelector"])(subscribe, getSnapshot, getSnapshot, identity, isEqual);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        var rehydratedState = options.state;
        service.start(rehydratedState ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$State$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].create(rehydratedState) : undefined);
        return function() {
            service.stop();
            service.status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterpreterStatus"].NotStarted;
        };
    }, []);
    return [
        storeSnapshot,
        service.send,
        service
    ];
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useActor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "isActorWithState": ()=>isActorWithState,
    "useActor": ()=>useActor
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$isomorphic$2d$layout$2d$effect$40$1$2e$2$2e$1_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0$2f$node_modules$2f$use$2d$isomorphic$2d$layout$2d$effect$2f$dist$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/use-isomorphic-layout-effect@1.2.1_@types+react@19.1.9_react@19.1.0/node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useConstant.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$5$2e$0_react$40$19$2e$1$2e$0$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/shim/with-selector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/utils.js [app-ssr] (ecmascript)");
;
;
;
;
;
function identity(a) {
    return a;
}
function isActorWithState(actorRef) {
    return 'state' in actorRef;
}
function isDeferredActor(actorRef) {
    return 'deferred' in actorRef;
}
function defaultGetSnapshot(actorRef) {
    return 'getSnapshot' in actorRef ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isService"])(actorRef) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getServiceSnapshot"])(actorRef) : actorRef.getSnapshot() : isActorWithState(actorRef) ? actorRef.state : undefined;
}
function useActor(actorRef, getSnapshot) {
    if (getSnapshot === void 0) {
        getSnapshot = defaultGetSnapshot;
    }
    var actorRefRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(actorRef);
    var deferredEventsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])([]);
    var subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function(handleStoreChange) {
        var unsubscribe = actorRef.subscribe(handleStoreChange).unsubscribe;
        return unsubscribe;
    }, [
        actorRef
    ]);
    var boundGetSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function() {
        return getSnapshot(actorRef);
    }, [
        actorRef,
        getSnapshot
    ]);
    var isEqual = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function(prevState, nextState) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isService"])(actorRef)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInterpreterStateEqual"])(actorRef, prevState, nextState);
        }
        return prevState === nextState;
    }, [
        actorRef
    ]);
    var storeSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$5$2e$0_react$40$19$2e$1$2e$0$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSyncExternalStoreWithSelector"])(subscribe, boundGetSnapshot, boundGetSnapshot, identity, isEqual);
    var send = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        return function() {
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++){
                args[_i] = arguments[_i];
            }
            var event = args[0];
            if (("TURBOPACK compile-time value", "development") !== 'production' && args.length > 1) {
                console.warn("Unexpected payload: ".concat(JSON.stringify(args[1]), ". Only a single event object can be sent to actor send() functions."));
            }
            var currentActorRef = actorRefRef.current;
            // If the previous actor is a deferred actor,
            // queue the events so that they can be replayed
            // on the non-deferred actor.
            if (isDeferredActor(currentActorRef) && currentActorRef.deferred) {
                deferredEventsRef.current.push(event);
            } else {
                currentActorRef.send(event);
            }
        };
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$isomorphic$2d$layout$2d$effect$40$1$2e$2$2e$1_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0$2f$node_modules$2f$use$2d$isomorphic$2d$layout$2d$effect$2f$dist$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        actorRefRef.current = actorRef;
        // Dequeue deferred events from the previous deferred actorRef
        while(deferredEventsRef.current.length > 0){
            var deferredEvent = deferredEventsRef.current.shift();
            actorRef.send(deferredEvent);
        }
    }, [
        actorRef
    ]);
    return [
        storeSnapshot,
        send
    ];
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useSelector.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "useSelector": ()=>useSelector
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$5$2e$0_react$40$19$2e$1$2e$0$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/shim/with-selector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useActor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/utils.js [app-ssr] (ecmascript)");
;
;
;
;
var defaultCompare = function(a, b) {
    return a === b;
};
var defaultGetSnapshot = function(a, initialStateCacheRef) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isService"])(a)) {
        // A status of 0 = interpreter not started
        if (a.status === 0 && initialStateCacheRef.current) {
            return initialStateCacheRef.current;
        }
        var snapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getServiceSnapshot"])(a);
        initialStateCacheRef.current = a.status === 0 ? snapshot : null;
        return snapshot;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isActorWithState"])(a) ? a.state : undefined;
};
function useSelector(actor, selector, compare, getSnapshot) {
    if (compare === void 0) {
        compare = defaultCompare;
    }
    var initialStateCacheRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    var subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function(handleStoreChange) {
        var unsubscribe = actor.subscribe(handleStoreChange).unsubscribe;
        return unsubscribe;
    }, [
        actor
    ]);
    var boundGetSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function() {
        if (getSnapshot) {
            return getSnapshot(actor);
        }
        return defaultGetSnapshot(actor, initialStateCacheRef);
    }, [
        actor,
        getSnapshot
    ]);
    var selectedSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$5$2e$0_react$40$19$2e$1$2e$0$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSyncExternalStoreWithSelector"])(subscribe, boundGetSnapshot, boundGetSnapshot, selector, compare);
    return selectedSnapshot;
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useSpawn.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "useSpawn": ()=>useSpawn
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$behaviors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/behaviors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useConstant.js [app-ssr] (ecmascript)");
;
;
function useSpawn(behavior) {
    var actorRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$behaviors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["spawnBehavior"])(behavior);
    });
    return actorRef;
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/createActorContext.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createActorContext": ()=>createActorContext
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useInterpret.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useActor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useSelector.js [app-ssr] (ecmascript)");
var __assign = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
;
;
;
;
function createActorContext(machine, interpreterOptions, observerOrListener) {
    var ReactContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createContext"](null);
    var OriginalProvider = ReactContext.Provider;
    function Provider(_a) {
        var children = _a.children, _b = _a.machine, providedMachine = _b === void 0 ? machine : _b, options = _a.options;
        var actor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useInterpret"])(providedMachine, __assign(__assign({}, interpreterOptions), options), observerOrListener);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"](OriginalProvider, {
            value: actor
        }, children);
    }
    Provider.displayName = "ActorProvider(".concat(machine.id, ")");
    function useContext() {
        var actor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useContext"](ReactContext);
        if (!actor) {
            throw new Error("You used a hook from \"".concat(Provider.displayName, "\" but it's not inside a <").concat(Provider.displayName, "> component."));
        }
        return actor;
    }
    function useActor() {
        var actor = useContext();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useActor"])(actor);
    }
    function useSelector(selector, compare) {
        var actor = useContext();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSelector"])(actor, selector, compare);
    }
    return {
        Provider: Provider,
        useActorRef: useContext,
        useActor: useActor,
        useSelector: useSelector
    };
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createActorContext": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$createActorContext$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createActorContext"],
    "shallowEqual": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shallowEqual"],
    "useActor": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useActor"],
    "useInterpret": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useInterpret"],
    "useMachine": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useMachine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMachine"],
    "useSelector": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSelector"],
    "useSpawn": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSpawn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSpawn"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useMachine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useMachine.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useActor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useInterpret.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useSelector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSpawn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/useSpawn.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$createActorContext$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/createActorContext.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript) <locals>");
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createActorContext": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createActorContext"],
    "shallowEqual": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["shallowEqual"],
    "useActor": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useActor"],
    "useInterpret": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useInterpret"],
    "useMachine": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useMachine"],
    "useSelector": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useSelector"],
    "useSpawn": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useSpawn"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$1$2e$9_react$40$19$2e$1$2e$0_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript) <exports>");
}),
"[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        }
        cachedValue = useState({
            inst: {
                value: value,
                getSnapshot: getSnapshot
            }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({
                inst: inst
            });
        }, [
            subscribe,
            value,
            getSnapshot
        ]);
        useEffect(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({
                inst: inst
            });
            return subscribe(function() {
                checkIfSnapshotChanged(inst) && forceUpdate({
                    inst: inst
                });
            });
        }, [
            subscribe
        ]);
        useDebugValue(value);
        return value;
    }
    function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
        } catch (error) {
            return !0;
        }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = ("TURBOPACK compile-time truthy", 1) ? useSyncExternalStore$1 : "TURBOPACK unreachable";
    exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}}),
"[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/shim/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-ssr] (ecmascript)");
}
}}),
"[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), shim = __turbopack_context__.r("[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/shim/index.js [app-ssr] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
    exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef(null);
        if (null === instRef.current) {
            var inst = {
                hasValue: !1,
                value: null
            };
            instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(function() {
            function memoizedSelector(nextSnapshot) {
                if (!hasMemo) {
                    hasMemo = !0;
                    memoizedSnapshot = nextSnapshot;
                    nextSnapshot = selector(nextSnapshot);
                    if (void 0 !== isEqual && inst.hasValue) {
                        var currentSelection = inst.value;
                        if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
                    }
                    return memoizedSelection = nextSnapshot;
                }
                currentSelection = memoizedSelection;
                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
                var nextSelection = selector(nextSnapshot);
                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
                memoizedSnapshot = nextSnapshot;
                return memoizedSelection = nextSelection;
            }
            var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
                function() {
                    return memoizedSelector(getSnapshot());
                },
                null === maybeGetServerSnapshot ? void 0 : function() {
                    return memoizedSelector(maybeGetServerSnapshot());
                }
            ];
        }, [
            getSnapshot,
            getServerSnapshot,
            selector,
            isEqual
        ]);
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect(function() {
            inst.hasValue = !0;
            inst.value = value;
        }, [
            value
        ]);
        useDebugValue(value);
        return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}}),
"[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/shim/with-selector.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [app-ssr] (ecmascript)");
}
}}),
"[project]/node_modules/.pnpm/use-isomorphic-layout-effect@1.2.1_@types+react@19.1.9_react@19.1.0/node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>index
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
;
var isClient = typeof document !== 'undefined';
var noop = function noop() {};
var index = isClient ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$6_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useLayoutEffect"] : noop;
;
}),
"[project]/node_modules/.pnpm/@nhost+react@3.11.1_@types+react@19.1.9_graphql@16.11.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@nhost/react/dist/index.cjs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const g = __turbopack_context__.r("[project]/node_modules/.pnpm/@nhost+nhost-js@3.3.0_graphql@16.11.0/node_modules/@nhost/nhost-js/dist/index.cjs.js [app-ssr] (ecmascript)"), p = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.1.9_react@19.1.0_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript)"), C = __turbopack_context__.r("[project]/node_modules/.pnpm/jwt-decode@4.0.0/node_modules/jwt-decode/build/cjs/index.js [app-ssr] (ecmascript)"), k = g.NhostClient;
class L extends k {
    constructor(t){
        super({
            ...t,
            start: !1
        });
    }
}
const P = p.createContext({}), O = ({ nhost: e, initial: t, ...o })=>{
    const i = n.useInterpret(e.auth.client.machine, {
        devTools: e.devTools
    });
    e.auth.client.start({
        interpreter: i,
        initialSession: t,
        devTools: e.devTools
    });
    const d = p.useRef(!0);
    return p.useEffect(()=>{
        d.current ? d.current = !1 : t && i.send("SESSION_UPDATE", {
            data: {
                session: t
            }
        });
    }, [
        t,
        i
    ]), p.createElement(P.Provider, {
        value: e
    }, o.children);
}, M = O, I = ()=>{
    var o;
    const t = (o = p.useContext(P).auth) == null ? void 0 : o.client.interpreter;
    if (!t) throw Error("Could not find the Nhost auth client. Did you wrap your app in <NhostProvider />?");
    return t;
}, x = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>({
            isAuthenticated: t.matches({
                authentication: "signedIn"
            }),
            isLoading: t.hasTag("loading"),
            error: t.context.errors.authentication || null,
            isError: t.matches({
                authentication: {
                    signedOut: "failed"
                }
            }),
            connectionAttempts: t.context.importTokenAttempts
        }), (t, o)=>t.isAuthenticated === o.isAuthenticated && t.isLoading === o.isLoading && t.connectionAttempts === o.connectionAttempts);
};
function N({ children: e }) {
    const { isAuthenticated: t } = x();
    return t ? p.createElement(p.Fragment, null, e) : null;
}
function R({ children: e }) {
    const { isAuthenticated: t } = x();
    return t ? null : p.createElement(p.Fragment, null, e);
}
const y = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>t.context.accessToken.value);
}, v = ()=>p.useContext(P), K = ()=>{
    const e = v(), [t, o] = p.useState(null), i = !t, d = !!t, [l, S] = p.useState(!1);
    return {
        add: async (u)=>{
            S(!0);
            const s = await g.addSecurityKeyPromise(e.auth.client, u), { error: r } = s;
            return r && o(r), S(!1), s;
        },
        isLoading: l,
        isSuccess: i,
        isError: d,
        error: t
    };
}, D = ()=>{
    const e = I(), [t, o] = p.useState(!!e.status && e.getSnapshot().matches({
        authentication: "signedIn"
    }));
    return p.useEffect(()=>e.subscribe((d)=>{
            const l = d.matches({
                authentication: "signedIn"
            });
            o(l);
        }).unsubscribe, [
        e
    ]), t;
};
function V(e) {
    const t = v(), o = p.useMemo(()=>g.createChangeEmailMachine(t.auth.client), [
        t
    ]), i = n.useInterpret(o), d = n.useSelector(i, (s)=>s.matches("requesting")), l = n.useSelector(i, (s)=>s.context.error), S = n.useSelector(i, (s)=>s.matches("idle.error")), m = n.useSelector(i, (s)=>s.matches("idle.success"));
    return {
        changeEmail: p.useCallback(async (s, r = e)=>g.changeEmailPromise(i, s, r), [
            i,
            e
        ]),
        isLoading: d,
        needsEmailVerification: m,
        isError: S,
        error: l
    };
}
const F = ()=>{
    const e = v(), t = p.useMemo(()=>g.createChangePasswordMachine(e.auth.client), [
        e
    ]), o = n.useInterpret(t), i = n.useSelector(o, (u)=>u.matches({
            idle: "error"
        })), d = n.useSelector(o, (u)=>u.matches({
            idle: "success"
        })), l = n.useSelector(o, (u)=>u.context.error), S = n.useSelector(o, (u)=>u.matches("requesting"));
    return {
        changePassword: (u)=>g.changePasswordPromise(o, u),
        isLoading: S,
        isSuccess: d,
        isError: i,
        error: l
    };
}, _ = ()=>{
    const e = v(), t = p.useMemo(()=>g.createEnableMfaMachine(e.auth.client), [
        e
    ]), o = n.useInterpret(t), i = n.useSelector(o, (f)=>f.matches({
            idle: "error"
        }) || f.matches({
            generated: {
                idle: "error"
            }
        })), d = n.useSelector(o, (f)=>f.matches("generating")), l = n.useSelector(o, (f)=>f.matches("generated")), S = n.useSelector(o, (f)=>f.matches({
            generated: "activating"
        })), m = n.useSelector(o, (f)=>f.matches({
            generated: "activated"
        })), u = n.useSelector(o, (f)=>f.matches("disabling")), s = n.useSelector(o, (f)=>f.context.error), r = n.useSelector(o, (f)=>f.context.imageUrl || ""), c = n.useSelector(o, (f)=>f.context.secret || "");
    return {
        generateQrCode: ()=>g.generateQrCodePromise(o),
        isGenerating: d,
        qrCodeDataUrl: r,
        isGenerated: l,
        activateMfa: (f)=>g.activateMfaPromise(o, f),
        isActivating: S,
        isActivated: m,
        isDisabling: u,
        isError: i,
        error: s,
        disableMfa: (f)=>g.disableMfaPromise(o, f),
        totpSecret: c
    };
}, w = ()=>{
    const e = y();
    return e ? C.jwtDecode(e) : null;
}, A = (e)=>{
    const t = v(), o = (h)=>{
        e.send({
            type: "ADD",
            file: h.file,
            bucketId: h.bucketId || E
        });
    }, i = (h)=>g.uploadFilePromise({
            url: t.storage.url,
            accessToken: t.auth.getAccessToken(),
            adminSecret: t.adminSecret,
            ...h
        }, e), d = ()=>{
        e.send("CANCEL");
    }, l = ()=>{
        e.send("DESTROY");
    }, S = n.useSelector(e, (h)=>h.matches("uploading")), m = n.useSelector(e, (h)=>h.matches("uploaded")), u = n.useSelector(e, (h)=>h.matches("error")), s = n.useSelector(e, (h)=>h.context.error || null), r = n.useSelector(e, (h)=>h.context.progress), c = n.useSelector(e, (h)=>h.context.id), E = n.useSelector(e, (h)=>h.context.bucketId), a = n.useSelector(e, (h)=>{
        var f;
        return (f = h.context.file) == null ? void 0 : f.name;
    });
    return {
        add: o,
        upload: i,
        cancel: d,
        destroy: l,
        isUploaded: m,
        isUploading: S,
        isError: u,
        error: s,
        progress: r,
        id: c,
        bucketId: E,
        name: a
    };
}, q = ()=>{
    const e = n.useInterpret(g.createFileUploadMachine);
    return A(e);
}, T = ()=>{
    const e = w();
    return (e == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
}, H = (e)=>{
    const t = T();
    return (t == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
}, j = ()=>{
    const e = v(), [t, o] = p.useState([]), i = n.useInterpret(g.createMultipleFilesUploadMachine, {}, (a)=>{
        a.event.type === "UPLOAD_ERROR" ? o(a.context.files.filter((h)=>{
            var f;
            return (f = h.getSnapshot()) == null ? void 0 : f.context.error;
        })) : (a.matches("uploaded") || a.event.type === "CLEAR") && t.length > 0 && o([]);
    }), d = (a)=>{
        i.send({
            type: "ADD",
            ...a
        });
    }, l = (a)=>g.uploadMultipleFilesPromise({
            url: e.storage.url,
            accessToken: e.auth.getAccessToken(),
            adminSecret: e.adminSecret,
            ...a
        }, i), S = ()=>{
        i.send("CANCEL");
    }, m = ()=>{
        i.send("CLEAR");
    }, u = n.useSelector(i, (a)=>a.matches("uploading")), s = n.useSelector(i, (a)=>a.matches("uploaded")), r = n.useSelector(i, (a)=>a.matches("error")), c = n.useSelector(i, (a)=>a.context.progress), E = n.useSelector(i, (a)=>a.context.files);
    return {
        upload: l,
        add: d,
        clear: m,
        cancel: S,
        progress: c,
        isUploaded: s,
        isUploading: u,
        files: E,
        isError: r,
        errors: t
    };
}, Q = (e)=>{
    const [t, o] = p.useState(!0), i = y();
    p.useEffect(()=>{
        o(!1);
    }, []);
    const d = p.useContext(P);
    return new Proxy({}, {
        get (l, S) {
            let m = `${d.auth.client.backendUrl}/signin/provider/${S}`;
            const u = e != null && e.connect ? {
                connect: i
            } : {};
            return g.encodeQueryParameters(m, g.rewriteRedirectTo(t ? void 0 : d.auth.client.clientUrl, {
                ...e,
                ...u
            }));
        }
    });
}, J = (e)=>{
    const t = v(), o = p.useMemo(()=>g.createResetPasswordMachine(t.auth.client), [
        t
    ]), i = n.useInterpret(o), d = n.useSelector(i, (s)=>s.matches("requesting")), l = n.useSelector(i, (s)=>s.context.error), S = n.useSelector(i, (s)=>s.matches("idle.error")), m = n.useSelector(i, (s)=>s.matches("idle.success"));
    return {
        resetPassword: (s, r = e)=>g.resetPasswordPromise(i, s, r),
        isLoading: d,
        isSent: m,
        isError: S,
        error: l
    };
}, Y = (e)=>{
    const t = v(), o = p.useMemo(()=>g.createSendVerificationEmailMachine(t.auth.client), [
        t
    ]), i = n.useInterpret(o), d = n.useSelector(i, (s)=>s.matches({
            idle: "error"
        })), l = n.useSelector(i, (s)=>s.matches({
            idle: "success"
        })), S = n.useSelector(i, (s)=>s.context.error), m = n.useSelector(i, (s)=>s.matches("requesting"));
    return {
        sendEmail: (s, r = e)=>g.sendVerificationEmailPromise(i, s, r),
        isLoading: m,
        isSent: l,
        isError: d,
        error: S
    };
}, $ = ()=>{
    const e = I(), t = ()=>g.signInAnonymousPromise(e), o = n.useSelector(e, (u)=>u.context.errors.authentication || null, (u, s)=>(u == null ? void 0 : u.error) === (s == null ? void 0 : s.error)), i = n.useSelector(e, (u)=>u.matches({
            authentication: {
                authenticating: "anonymous"
            }
        })), d = n.useSelector(e, (u)=>u.matches({
            authentication: "signedIn"
        })), l = n.useSelector(e, (u)=>u.matches({
            authentication: {
                signedOut: "failed"
            }
        })), S = n.useSelector(e, (u)=>u.context.user, (u, s)=>(u == null ? void 0 : u.id) === (s == null ? void 0 : s.id));
    return {
        accessToken: n.useSelector(e, (u)=>u.context.accessToken.value),
        error: o,
        isError: l,
        isLoading: i,
        isSuccess: d,
        signInAnonymous: t,
        user: S
    };
}, G = ()=>{
    const e = I(), t = (a, h)=>g.signInEmailPasswordPromise(e, a, h), o = (a)=>g.signInMfaTotpPromise(e, a), i = n.useSelector(e, (a)=>a.context.user, (a, h)=>(a == null ? void 0 : a.id) === (h == null ? void 0 : h.id)), d = n.useSelector(e, (a)=>a.context.accessToken.value), l = n.useSelector(e, (a)=>a.context.refreshToken.value), S = n.useSelector(e, (a)=>a.context.errors.authentication || null, (a, h)=>(a == null ? void 0 : a.error) === (h == null ? void 0 : h.error)), m = n.useSelector(e, (a)=>a.matches({
            authentication: "signedIn"
        })), u = n.useSelector(e, (a)=>a.matches({
            authentication: {
                authenticating: "password"
            }
        }), (a, h)=>a === h), s = n.useSelector(e, (a)=>a.matches({
            authentication: {
                signedOut: "noErrors"
            },
            registration: {
                incomplete: "needsEmailVerification"
            }
        }), (a, h)=>a === h), r = n.useSelector(e, (a)=>a.context.mfa !== null), c = n.useSelector(e, (a)=>a.matches({
            authentication: {
                signedOut: "failed"
            }
        }), (a, h)=>a === h), E = n.useSelector(e, (a)=>a.context.mfa);
    return {
        accessToken: d,
        refreshToken: l,
        error: S,
        isError: c,
        isLoading: u,
        isSuccess: m,
        needsEmailVerification: s,
        needsMfaOtp: r,
        mfa: E,
        sendMfaOtp: o,
        signInEmailPassword: t,
        user: i
    };
};
function W(e) {
    const t = I(), o = (m, u = e)=>g.signInEmailPasswordlessPromise(t, m, u), i = n.useSelector(t, (m)=>m.context.errors.registration || null, (m, u)=>(m == null ? void 0 : m.error) === (u == null ? void 0 : u.error)), d = n.useSelector(t, (m)=>m.matches("registration.passwordlessEmail")), l = n.useSelector(t, (m)=>m.matches("registration.incomplete.needsEmailVerification")), S = n.useSelector(t, (m)=>m.matches("registration.incomplete.failed"));
    return {
        signInEmailPasswordless: o,
        isLoading: d,
        isSuccess: l,
        isError: S,
        error: i
    };
}
const z = ()=>{
    const e = I(), t = (r)=>g.signInEmailSecurityKeyPromise(e, r), o = n.useSelector(e, (r)=>r.context.user, (r, c)=>(r == null ? void 0 : r.id) === (c == null ? void 0 : c.id)), i = n.useSelector(e, (r)=>r.context.accessToken.value), d = n.useSelector(e, (r)=>r.context.refreshToken.value), l = n.useSelector(e, (r)=>r.context.errors.authentication || null, (r, c)=>(r == null ? void 0 : r.error) === (c == null ? void 0 : c.error)), S = n.useSelector(e, (r)=>r.matches({
            authentication: "signedIn"
        })), m = n.useSelector(e, (r)=>r.matches({
            authentication: {
                authenticating: "securityKeyEmail"
            }
        }), (r, c)=>r === c), u = n.useSelector(e, (r)=>r.matches({
            authentication: {
                signedOut: "noErrors"
            },
            registration: {
                incomplete: "needsEmailVerification"
            }
        }), (r, c)=>r === c), s = n.useSelector(e, (r)=>r.matches({
            authentication: {
                signedOut: "failed"
            }
        }), (r, c)=>r === c);
    return {
        accessToken: i,
        refreshToken: d,
        error: l,
        isError: s,
        isLoading: m,
        isSuccess: S,
        needsEmailVerification: u,
        signInEmailSecurityKey: t,
        user: o
    };
}, U = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>t.context.user, (t, o)=>(t && JSON.stringify(t)) === (o && JSON.stringify(o)));
}, B = ()=>{
    const e = U(), t = v(), o = T(), i = e ? (o == null ? void 0 : o["x-hasura-auth-elevated"]) === (e == null ? void 0 : e.id) : !1, [d, l] = p.useState(!!i), S = (m)=>g.elevateEmailSecurityKeyPromise(t.auth.client, m);
    return p.useEffect(()=>{
        l(!!i);
    }, [
        i
    ]), {
        elevated: d,
        elevateEmailSecurityKey: S
    };
}, X = ()=>{
    const e = I(), t = (s)=>g.signInPATPromise(e, s), o = n.useSelector(e, (s)=>s.context.user, (s, r)=>(s == null ? void 0 : s.id) === (r == null ? void 0 : r.id)), i = n.useSelector(e, (s)=>s.context.accessToken.value), d = n.useSelector(e, (s)=>s.context.refreshToken.value), l = n.useSelector(e, (s)=>s.context.errors.authentication || null, (s, r)=>(s == null ? void 0 : s.error) === (r == null ? void 0 : r.error)), S = n.useSelector(e, (s)=>s.matches({
            authentication: "signedIn"
        })), m = n.useSelector(e, (s)=>s.matches({
            authentication: {
                authenticating: "password"
            }
        }), (s, r)=>s === r), u = n.useSelector(e, (s)=>s.matches({
            authentication: {
                signedOut: "failed"
            }
        }), (s, r)=>s === r);
    return {
        accessToken: i,
        refreshToken: d,
        error: l,
        isError: u,
        isLoading: m,
        isSuccess: S,
        signInPAT: t,
        user: o
    };
};
function Z(e) {
    const t = I(), [o, i] = p.useState(""), d = (c, E = e)=>(i(c), g.signInSmsPasswordlessPromise(t, c, E)), l = async (...c)=>{
        if (c.length === 2) {
            const [a, h] = c;
            return g.signInSmsPasswordlessOtpPromise(t, a, h);
        }
        const [E] = c;
        return g.signInSmsPasswordlessOtpPromise(t, o, E);
    }, S = n.useSelector(t, (c)=>c.context.errors.registration || null, (c, E)=>(c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)), m = n.useSelector(t, (c)=>c.matches("registration.passwordlessSms") || c.matches("registration.passwordlessSmsOtp")), u = n.useSelector(t, (c)=>c.matches("authentication.signedIn")), s = n.useSelector(t, (c)=>c.matches("registration.incomplete.needsOtp")), r = n.useSelector(t, (c)=>c.matches("registration.incomplete.failed"));
    return {
        signInSmsPasswordless: d,
        sendOtp: l,
        isLoading: m,
        isSuccess: u,
        needsOtp: s,
        isError: r,
        error: S
    };
}
const b = (e = !1)=>{
    const t = I(), o = (l)=>g.signOutPromise(t, typeof l == "boolean" ? l : e), i = n.useSelector(t, (l)=>l.matches({
            authentication: {
                signedOut: "success"
            }
        }), (l, S)=>l === S), d = n.useSelector(t, (l)=>l.context.errors.signout || null, (l, S)=>(l == null ? void 0 : l.error) === (S == null ? void 0 : S.error));
    return {
        signOut: o,
        isSuccess: i,
        error: d
    };
}, ee = (e)=>{
    const t = I(), o = n.useSelector(t, (c)=>!!c.context.errors.registration), i = n.useSelector(t, (c)=>c.context.errors.registration || null, (c, E)=>(c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)), d = n.useSelector(t, (c)=>c.matches("registration.emailPassword")), l = n.useSelector(t, (c)=>c.matches("registration.incomplete.needsEmailVerification")), S = n.useSelector(t, (c)=>c.matches({
            authentication: "signedIn",
            registration: "complete"
        })), m = (c, E, a = e, h)=>g.signUpEmailPasswordPromise(t, c, E, a, h), u = n.useSelector(t, (c)=>c.context.user, (c, E)=>(c == null ? void 0 : c.id) === (E == null ? void 0 : E.id)), s = n.useSelector(t, (c)=>c.context.accessToken.value), r = n.useSelector(t, (c)=>c.context.refreshToken.value);
    return {
        accessToken: s,
        refreshToken: r,
        error: i,
        isError: o,
        isLoading: d,
        isSuccess: S,
        needsEmailVerification: l,
        signUpEmailPassword: m,
        user: u
    };
}, te = (e)=>{
    const t = I(), o = n.useSelector(t, (c)=>!!c.context.errors.registration), i = n.useSelector(t, (c)=>c.context.errors.registration || null, (c, E)=>(c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)), d = n.useSelector(t, (c)=>c.matches("registration.securityKey")), l = n.useSelector(t, (c)=>c.matches("registration.incomplete.needsEmailVerification")), S = n.useSelector(t, (c)=>c.matches({
            authentication: "signedIn",
            registration: "complete"
        })), m = (c, E = e, a)=>g.signUpEmailSecurityKeyPromise(t, c, E, a), u = n.useSelector(t, (c)=>c.context.user, (c, E)=>(c == null ? void 0 : c.id) === (E == null ? void 0 : E.id)), s = n.useSelector(t, (c)=>c.context.accessToken.value), r = n.useSelector(t, (c)=>c.context.refreshToken.value);
    return {
        accessToken: s,
        refreshToken: r,
        error: i,
        isError: o,
        isLoading: d,
        isSuccess: S,
        needsEmailVerification: l,
        signUpEmailSecurityKey: m,
        user: u
    };
}, se = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.avatarUrl;
    }, (t, o)=>t === o);
}, ne = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.defaultRole;
    }, (t, o)=>t === o);
}, re = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.displayName;
    }, (t, o)=>t === o);
}, oe = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.email;
    }, (t, o)=>t === o);
}, ce = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.id;
    }, (t, o)=>t === o);
}, ie = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.isAnonymous;
    }, (t, o)=>t === o);
}, ue = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.locale;
    }, (t, o)=>t === o);
}, ae = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return t.matches("authentication.signedIn") ? ((o = t.context.user) == null ? void 0 : o.roles) || [] : [];
    });
};
function le(e) {
    const t = I(), o = (s, r = e)=>g.signInEmailOTPPromise(t, s, r), i = async (s, r)=>g.verifyEmailOTPPromise(t, s, r), d = n.useSelector(t, (s)=>s.context.errors.registration || null, (s, r)=>(s == null ? void 0 : s.error) === (r == null ? void 0 : r.error)), l = n.useSelector(t, (s)=>s.matches("registration.signInEmailOTP") || s.matches("registration.verifyEmailOTP")), S = n.useSelector(t, (s)=>s.matches("authentication.signedIn")), m = n.useSelector(t, (s)=>s.matches("registration.incomplete.needsOtp")), u = n.useSelector(t, (s)=>s.matches("registration.incomplete.failed"));
    return {
        signInEmailOTP: o,
        verifyEmailOTP: i,
        isLoading: l,
        isSuccess: S,
        isError: u,
        error: d,
        needsOtp: m
    };
}
const de = ()=>{
    const e = I(), t = (s, r, c)=>g.signInIdTokenPromise(e, {
            provider: s,
            idToken: r,
            nonce: c
        }), o = n.useSelector(e, (s)=>s.context.user, (s, r)=>(s == null ? void 0 : s.id) === (r == null ? void 0 : r.id)), i = n.useSelector(e, (s)=>s.context.accessToken.value), d = n.useSelector(e, (s)=>s.context.refreshToken.value), l = n.useSelector(e, (s)=>s.context.errors.authentication || null, (s, r)=>(s == null ? void 0 : s.error) === (r == null ? void 0 : r.error)), S = n.useSelector(e, (s)=>s.matches({
            authentication: "signedIn"
        })), m = n.useSelector(e, (s)=>s.matches({
            authentication: {
                authenticating: "idToken"
            }
        }), (s, r)=>s === r), u = n.useSelector(e, (s)=>s.matches({
            authentication: {
                signedOut: "failed"
            }
        }), (s, r)=>s === r);
    return {
        accessToken: i,
        refreshToken: d,
        error: l,
        isError: u,
        isLoading: m,
        isSuccess: S,
        signInIdToken: t,
        user: o
    };
}, Se = ()=>{
    const e = v(), [t, o] = p.useState(null), i = !t, d = !!t, [l, S] = p.useState(!1);
    return {
        linkIdToken: async ({ provider: u, idToken: s, nonce: r })=>{
            S(!0);
            const c = await g.linkIdTokenPromise(e.auth.client, {
                provider: u,
                idToken: s,
                ...r && {
                    nonce: r
                }
            }), { error: E } = c;
            return E && o(E), S(!1), c;
        },
        isLoading: l,
        isSuccess: i,
        isError: d,
        error: t
    };
}, me = ()=>{
    const e = I(), t = ()=>g.signInSecurityKeyPromise(e), o = n.useSelector(e, (r)=>r.context.user, (r, c)=>(r == null ? void 0 : r.id) === (c == null ? void 0 : c.id)), i = n.useSelector(e, (r)=>r.context.accessToken.value), d = n.useSelector(e, (r)=>r.context.refreshToken.value), l = n.useSelector(e, (r)=>r.context.errors.authentication || null, (r, c)=>(r == null ? void 0 : r.error) === (c == null ? void 0 : c.error)), S = n.useSelector(e, (r)=>r.matches({
            authentication: "signedIn"
        })), m = n.useSelector(e, (r)=>r.matches({
            authentication: {
                authenticating: "securityKeyEmail"
            }
        }), (r, c)=>r === c), u = n.useSelector(e, (r)=>r.matches({
            authentication: {
                signedOut: "noErrors"
            },
            registration: {
                incomplete: "needsEmailVerification"
            }
        }), (r, c)=>r === c), s = n.useSelector(e, (r)=>r.matches({
            authentication: {
                signedOut: "failed"
            }
        }), (r, c)=>r === c);
    return {
        accessToken: i,
        refreshToken: d,
        error: l,
        isError: s,
        isLoading: m,
        isSuccess: S,
        needsEmailVerification: u,
        signInSecurityKey: t,
        user: o
    };
};
Object.defineProperty(exports, "NHOST_REFRESH_TOKEN_KEY", {
    enumerable: !0,
    get: ()=>g.NHOST_REFRESH_TOKEN_KEY
});
exports.NhostClient = L;
exports.NhostProvider = O;
exports.NhostReactContext = P;
exports.NhostReactProvider = M;
exports.SignedIn = N;
exports.SignedOut = R;
exports.VanillaNhostClient = k;
exports.useAccessToken = y;
exports.useAddSecurityKey = K;
exports.useAuthInterpreter = I;
exports.useAuthenticated = D;
exports.useAuthenticationStatus = x;
exports.useChangeEmail = V;
exports.useChangePassword = F;
exports.useConfigMfa = _;
exports.useDecodedAccessToken = w;
exports.useElevateSecurityKeyEmail = B;
exports.useFileUpload = q;
exports.useFileUploadItem = A;
exports.useHasuraClaim = H;
exports.useHasuraClaims = T;
exports.useLinkIdToken = Se;
exports.useMultipleFilesUpload = j;
exports.useNhostClient = v;
exports.useProviderLink = Q;
exports.useResetPassword = J;
exports.useSendVerificationEmail = Y;
exports.useSignInAnonymous = $;
exports.useSignInEmailOTP = le;
exports.useSignInEmailPassword = G;
exports.useSignInEmailPasswordless = W;
exports.useSignInEmailSecurityKey = z;
exports.useSignInIdToken = de;
exports.useSignInPAT = X;
exports.useSignInSecurityKey = me;
exports.useSignInSmsPasswordless = Z;
exports.useSignOut = b;
exports.useSignUpEmailPassword = ee;
exports.useSignUpEmailSecurityKeyEmail = te;
exports.useUserAvatarUrl = se;
exports.useUserData = U;
exports.useUserDefaultRole = ne;
exports.useUserDisplayName = re;
exports.useUserEmail = oe;
exports.useUserId = ce;
exports.useUserIsAnonymous = ie;
exports.useUserLocale = ue;
exports.useUserRoles = ae; //# sourceMappingURL=index.cjs.js.map
}}),
"[project]/node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ __turbopack_context__.s({
    "__addDisposableResource": ()=>__addDisposableResource,
    "__assign": ()=>__assign,
    "__asyncDelegator": ()=>__asyncDelegator,
    "__asyncGenerator": ()=>__asyncGenerator,
    "__asyncValues": ()=>__asyncValues,
    "__await": ()=>__await,
    "__awaiter": ()=>__awaiter,
    "__classPrivateFieldGet": ()=>__classPrivateFieldGet,
    "__classPrivateFieldIn": ()=>__classPrivateFieldIn,
    "__classPrivateFieldSet": ()=>__classPrivateFieldSet,
    "__createBinding": ()=>__createBinding,
    "__decorate": ()=>__decorate,
    "__disposeResources": ()=>__disposeResources,
    "__esDecorate": ()=>__esDecorate,
    "__exportStar": ()=>__exportStar,
    "__extends": ()=>__extends,
    "__generator": ()=>__generator,
    "__importDefault": ()=>__importDefault,
    "__importStar": ()=>__importStar,
    "__makeTemplateObject": ()=>__makeTemplateObject,
    "__metadata": ()=>__metadata,
    "__param": ()=>__param,
    "__propKey": ()=>__propKey,
    "__read": ()=>__read,
    "__rest": ()=>__rest,
    "__rewriteRelativeImportExtension": ()=>__rewriteRelativeImportExtension,
    "__runInitializers": ()=>__runInitializers,
    "__setFunctionName": ()=>__setFunctionName,
    "__spread": ()=>__spread,
    "__spreadArray": ()=>__spreadArray,
    "__spreadArrays": ()=>__spreadArrays,
    "__values": ()=>__values,
    "default": ()=>__TURBOPACK__default__export__
});
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
;
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
}
;
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
;
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
;
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
            value: raw
        });
    } else {
        cooked.raw = raw;
    }
    return cooked;
}
;
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o) {
        var ar = [];
        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while(r = env.stack.pop()){
            try {
                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                if (r.dispose) {
                    var result = r.dispose.call(r.value);
                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                        fail(e);
                        return next();
                    });
                } else s |= 1;
            } catch (e) {
                fail(e);
            }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
            return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
    }
    return path;
}
const __TURBOPACK__default__export__ = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension
};
}),
"[project]/node_modules/.pnpm/ts-invariant@0.10.3/node_modules/ts-invariant/lib/invariant.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "InvariantError": ()=>InvariantError,
    "default": ()=>__TURBOPACK__default__export__,
    "invariant": ()=>invariant,
    "setVerbosity": ()=>setVerbosity
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tslib$40$2$2e$8$2e$1$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
;
var genericMessage = "Invariant Violation";
var _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function(obj, proto) {
    obj.__proto__ = proto;
    return obj;
} : _a;
var InvariantError = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tslib$40$2$2e$8$2e$1$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__extends"])(InvariantError, _super);
    function InvariantError(message) {
        if (message === void 0) {
            message = genericMessage;
        }
        var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
        _this.framesToPop = 1;
        _this.name = genericMessage;
        setPrototypeOf(_this, InvariantError.prototype);
        return _this;
    }
    return InvariantError;
}(Error);
;
function invariant(condition, message) {
    if (!condition) {
        throw new InvariantError(message);
    }
}
var verbosityLevels = [
    "debug",
    "log",
    "warn",
    "error",
    "silent"
];
var verbosityLevel = verbosityLevels.indexOf("log");
function wrapConsoleMethod(name) {
    return function() {
        if (verbosityLevels.indexOf(name) >= verbosityLevel) {
            // Default to console.log if this host environment happens not to provide
            // all the console.* methods we need.
            var method = console[name] || console.log;
            return method.apply(console, arguments);
        }
    };
}
(function(invariant) {
    invariant.debug = wrapConsoleMethod("debug");
    invariant.log = wrapConsoleMethod("log");
    invariant.warn = wrapConsoleMethod("warn");
    invariant.error = wrapConsoleMethod("error");
})(invariant || (invariant = {}));
function setVerbosity(level) {
    var old = verbosityLevels[verbosityLevel];
    verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
    return old;
}
const __TURBOPACK__default__export__ = invariant;
 //# sourceMappingURL=invariant.js.map
}),
"[project]/node_modules/.pnpm/rehackt@0.1.0_@types+react@19.1.9_react@19.1.0/node_modules/rehackt/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
// We don't want bundlers to error when they encounter usage of any of these exports.
// It's up to the package author to ensure that if they access React internals,
// they do so in a safe way that won't break if React changes how they use these internals.
// (e.g. only access them in development, and only in an optional way that won't
// break if internals are not there or do not have the expected structure)
// @ts-ignore
module.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = undefined;
// @ts-ignore
module.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = undefined;
// @ts-ignore
module.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = undefined;
// Here we actually pull in the React library and add everything
// it exports to our own `module.exports`.
// If React suddenly were to add one of the above "polyfilled" exports,
// the React version would overwrite our version, so this should be
// future-proof.
Object.assign(module.exports, __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.4.6_@babel+core@7.28.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
}}),
"[project]/node_modules/.pnpm/zen-observable-ts@1.2.5/node_modules/zen-observable-ts/module.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Observable": ()=>Observable
});
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
// === Symbol Support ===
var hasSymbols = function() {
    return typeof Symbol === 'function';
};
var hasSymbol = function(name) {
    return hasSymbols() && Boolean(Symbol[name]);
};
var getSymbol = function(name) {
    return hasSymbol(name) ? Symbol[name] : '@@' + name;
};
if (hasSymbols() && !hasSymbol('observable')) {
    Symbol.observable = Symbol('observable');
}
var SymbolIterator = getSymbol('iterator');
var SymbolObservable = getSymbol('observable');
var SymbolSpecies = getSymbol('species'); // === Abstract Operations ===
function getMethod(obj, key) {
    var value = obj[key];
    if (value == null) return undefined;
    if (typeof value !== 'function') throw new TypeError(value + ' is not a function');
    return value;
}
function getSpecies(obj) {
    var ctor = obj.constructor;
    if (ctor !== undefined) {
        ctor = ctor[SymbolSpecies];
        if (ctor === null) {
            ctor = undefined;
        }
    }
    return ctor !== undefined ? ctor : Observable;
}
function isObservable(x) {
    return x instanceof Observable; // SPEC: Brand check
}
function hostReportError(e) {
    if (hostReportError.log) {
        hostReportError.log(e);
    } else {
        setTimeout(function() {
            throw e;
        });
    }
}
function enqueue(fn) {
    Promise.resolve().then(function() {
        try {
            fn();
        } catch (e) {
            hostReportError(e);
        }
    });
}
function cleanupSubscription(subscription) {
    var cleanup = subscription._cleanup;
    if (cleanup === undefined) return;
    subscription._cleanup = undefined;
    if (!cleanup) {
        return;
    }
    try {
        if (typeof cleanup === 'function') {
            cleanup();
        } else {
            var unsubscribe = getMethod(cleanup, 'unsubscribe');
            if (unsubscribe) {
                unsubscribe.call(cleanup);
            }
        }
    } catch (e) {
        hostReportError(e);
    }
}
function closeSubscription(subscription) {
    subscription._observer = undefined;
    subscription._queue = undefined;
    subscription._state = 'closed';
}
function flushSubscription(subscription) {
    var queue = subscription._queue;
    if (!queue) {
        return;
    }
    subscription._queue = undefined;
    subscription._state = 'ready';
    for(var i = 0; i < queue.length; ++i){
        notifySubscription(subscription, queue[i].type, queue[i].value);
        if (subscription._state === 'closed') break;
    }
}
function notifySubscription(subscription, type, value) {
    subscription._state = 'running';
    var observer = subscription._observer;
    try {
        var m = getMethod(observer, type);
        switch(type){
            case 'next':
                if (m) m.call(observer, value);
                break;
            case 'error':
                closeSubscription(subscription);
                if (m) m.call(observer, value);
                else throw value;
                break;
            case 'complete':
                closeSubscription(subscription);
                if (m) m.call(observer);
                break;
        }
    } catch (e) {
        hostReportError(e);
    }
    if (subscription._state === 'closed') cleanupSubscription(subscription);
    else if (subscription._state === 'running') subscription._state = 'ready';
}
function onNotify(subscription, type, value) {
    if (subscription._state === 'closed') return;
    if (subscription._state === 'buffering') {
        subscription._queue.push({
            type: type,
            value: value
        });
        return;
    }
    if (subscription._state !== 'ready') {
        subscription._state = 'buffering';
        subscription._queue = [
            {
                type: type,
                value: value
            }
        ];
        enqueue(function() {
            return flushSubscription(subscription);
        });
        return;
    }
    notifySubscription(subscription, type, value);
}
var Subscription = /*#__PURE__*/ function() {
    function Subscription(observer, subscriber) {
        // ASSERT: observer is an object
        // ASSERT: subscriber is callable
        this._cleanup = undefined;
        this._observer = observer;
        this._queue = undefined;
        this._state = 'initializing';
        var subscriptionObserver = new SubscriptionObserver(this);
        try {
            this._cleanup = subscriber.call(undefined, subscriptionObserver);
        } catch (e) {
            subscriptionObserver.error(e);
        }
        if (this._state === 'initializing') this._state = 'ready';
    }
    var _proto = Subscription.prototype;
    _proto.unsubscribe = function unsubscribe() {
        if (this._state !== 'closed') {
            closeSubscription(this);
            cleanupSubscription(this);
        }
    };
    _createClass(Subscription, [
        {
            key: "closed",
            get: function() {
                return this._state === 'closed';
            }
        }
    ]);
    return Subscription;
}();
var SubscriptionObserver = /*#__PURE__*/ function() {
    function SubscriptionObserver(subscription) {
        this._subscription = subscription;
    }
    var _proto2 = SubscriptionObserver.prototype;
    _proto2.next = function next(value) {
        onNotify(this._subscription, 'next', value);
    };
    _proto2.error = function error(value) {
        onNotify(this._subscription, 'error', value);
    };
    _proto2.complete = function complete() {
        onNotify(this._subscription, 'complete');
    };
    _createClass(SubscriptionObserver, [
        {
            key: "closed",
            get: function() {
                return this._subscription._state === 'closed';
            }
        }
    ]);
    return SubscriptionObserver;
}();
var Observable = /*#__PURE__*/ function() {
    function Observable(subscriber) {
        if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');
        if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');
        this._subscriber = subscriber;
    }
    var _proto3 = Observable.prototype;
    _proto3.subscribe = function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
            observer = {
                next: observer,
                error: arguments[1],
                complete: arguments[2]
            };
        }
        return new Subscription(observer, this._subscriber);
    };
    _proto3.forEach = function forEach(fn) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            if (typeof fn !== 'function') {
                reject(new TypeError(fn + ' is not a function'));
                return;
            }
            function done() {
                subscription.unsubscribe();
                resolve();
            }
            var subscription = _this.subscribe({
                next: function(value) {
                    try {
                        fn(value, done);
                    } catch (e) {
                        reject(e);
                        subscription.unsubscribe();
                    }
                },
                error: reject,
                complete: resolve
            });
        });
    };
    _proto3.map = function map(fn) {
        var _this2 = this;
        if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
        var C = getSpecies(this);
        return new C(function(observer) {
            return _this2.subscribe({
                next: function(value) {
                    try {
                        value = fn(value);
                    } catch (e) {
                        return observer.error(e);
                    }
                    observer.next(value);
                },
                error: function(e) {
                    observer.error(e);
                },
                complete: function() {
                    observer.complete();
                }
            });
        });
    };
    _proto3.filter = function filter(fn) {
        var _this3 = this;
        if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
        var C = getSpecies(this);
        return new C(function(observer) {
            return _this3.subscribe({
                next: function(value) {
                    try {
                        if (!fn(value)) return;
                    } catch (e) {
                        return observer.error(e);
                    }
                    observer.next(value);
                },
                error: function(e) {
                    observer.error(e);
                },
                complete: function() {
                    observer.complete();
                }
            });
        });
    };
    _proto3.reduce = function reduce(fn) {
        var _this4 = this;
        if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
        var C = getSpecies(this);
        var hasSeed = arguments.length > 1;
        var hasValue = false;
        var seed = arguments[1];
        var acc = seed;
        return new C(function(observer) {
            return _this4.subscribe({
                next: function(value) {
                    var first = !hasValue;
                    hasValue = true;
                    if (!first || hasSeed) {
                        try {
                            acc = fn(acc, value);
                        } catch (e) {
                            return observer.error(e);
                        }
                    } else {
                        acc = value;
                    }
                },
                error: function(e) {
                    observer.error(e);
                },
                complete: function() {
                    if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));
                    observer.next(acc);
                    observer.complete();
                }
            });
        });
    };
    _proto3.concat = function concat() {
        var _this5 = this;
        for(var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++){
            sources[_key] = arguments[_key];
        }
        var C = getSpecies(this);
        return new C(function(observer) {
            var subscription;
            var index = 0;
            function startNext(next) {
                subscription = next.subscribe({
                    next: function(v) {
                        observer.next(v);
                    },
                    error: function(e) {
                        observer.error(e);
                    },
                    complete: function() {
                        if (index === sources.length) {
                            subscription = undefined;
                            observer.complete();
                        } else {
                            startNext(C.from(sources[index++]));
                        }
                    }
                });
            }
            startNext(_this5);
            return function() {
                if (subscription) {
                    subscription.unsubscribe();
                    subscription = undefined;
                }
            };
        });
    };
    _proto3.flatMap = function flatMap(fn) {
        var _this6 = this;
        if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
        var C = getSpecies(this);
        return new C(function(observer) {
            var subscriptions = [];
            var outer = _this6.subscribe({
                next: function(value) {
                    if (fn) {
                        try {
                            value = fn(value);
                        } catch (e) {
                            return observer.error(e);
                        }
                    }
                    var inner = C.from(value).subscribe({
                        next: function(value) {
                            observer.next(value);
                        },
                        error: function(e) {
                            observer.error(e);
                        },
                        complete: function() {
                            var i = subscriptions.indexOf(inner);
                            if (i >= 0) subscriptions.splice(i, 1);
                            completeIfDone();
                        }
                    });
                    subscriptions.push(inner);
                },
                error: function(e) {
                    observer.error(e);
                },
                complete: function() {
                    completeIfDone();
                }
            });
            function completeIfDone() {
                if (outer.closed && subscriptions.length === 0) observer.complete();
            }
            return function() {
                subscriptions.forEach(function(s) {
                    return s.unsubscribe();
                });
                outer.unsubscribe();
            };
        });
    };
    _proto3[SymbolObservable] = function() {
        return this;
    };
    Observable.from = function from(x) {
        var C = typeof this === 'function' ? this : Observable;
        if (x == null) throw new TypeError(x + ' is not an object');
        var method = getMethod(x, SymbolObservable);
        if (method) {
            var observable = method.call(x);
            if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');
            if (isObservable(observable) && observable.constructor === C) return observable;
            return new C(function(observer) {
                return observable.subscribe(observer);
            });
        }
        if (hasSymbol('iterator')) {
            method = getMethod(x, SymbolIterator);
            if (method) {
                return new C(function(observer) {
                    enqueue(function() {
                        if (observer.closed) return;
                        for(var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;){
                            var item = _step.value;
                            observer.next(item);
                            if (observer.closed) return;
                        }
                        observer.complete();
                    });
                });
            }
        }
        if (Array.isArray(x)) {
            return new C(function(observer) {
                enqueue(function() {
                    if (observer.closed) return;
                    for(var i = 0; i < x.length; ++i){
                        observer.next(x[i]);
                        if (observer.closed) return;
                    }
                    observer.complete();
                });
            });
        }
        throw new TypeError(x + ' is not observable');
    };
    Observable.of = function of() {
        for(var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
            items[_key2] = arguments[_key2];
        }
        var C = typeof this === 'function' ? this : Observable;
        return new C(function(observer) {
            enqueue(function() {
                if (observer.closed) return;
                for(var i = 0; i < items.length; ++i){
                    observer.next(items[i]);
                    if (observer.closed) return;
                }
                observer.complete();
            });
        });
    };
    _createClass(Observable, null, [
        {
            key: SymbolSpecies,
            get: function() {
                return this;
            }
        }
    ]);
    return Observable;
}();
if (hasSymbols()) {
    Object.defineProperty(Observable, Symbol('extensions'), {
        value: {
            symbol: SymbolObservable,
            hostReportError: hostReportError
        },
        configurable: true
    });
}
;
}),
"[project]/node_modules/.pnpm/@wry+caches@1.0.1/node_modules/@wry/caches/lib/weak.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "WeakCache": ()=>WeakCache
});
function noop() {}
const defaultDispose = noop;
const _WeakRef = typeof WeakRef !== "undefined" ? WeakRef : function(value) {
    return {
        deref: ()=>value
    };
};
const _WeakMap = typeof WeakMap !== "undefined" ? WeakMap : Map;
const _FinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : function() {
    return {
        register: noop,
        unregister: noop
    };
};
const finalizationBatchSize = 10024;
class WeakCache {
    constructor(max = Infinity, dispose = defaultDispose){
        this.max = max;
        this.dispose = dispose;
        this.map = new _WeakMap();
        this.newest = null;
        this.oldest = null;
        this.unfinalizedNodes = new Set();
        this.finalizationScheduled = false;
        this.size = 0;
        this.finalize = ()=>{
            const iterator = this.unfinalizedNodes.values();
            for(let i = 0; i < finalizationBatchSize; i++){
                const node = iterator.next().value;
                if (!node) break;
                this.unfinalizedNodes.delete(node);
                const key = node.key;
                delete node.key;
                node.keyRef = new _WeakRef(key);
                this.registry.register(key, node, node);
            }
            if (this.unfinalizedNodes.size > 0) {
                queueMicrotask(this.finalize);
            } else {
                this.finalizationScheduled = false;
            }
        };
        this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));
    }
    has(key) {
        return this.map.has(key);
    }
    get(key) {
        const node = this.getNode(key);
        return node && node.value;
    }
    getNode(key) {
        const node = this.map.get(key);
        if (node && node !== this.newest) {
            const { older, newer } = node;
            if (newer) {
                newer.older = older;
            }
            if (older) {
                older.newer = newer;
            }
            node.older = this.newest;
            node.older.newer = node;
            node.newer = null;
            this.newest = node;
            if (node === this.oldest) {
                this.oldest = newer;
            }
        }
        return node;
    }
    set(key, value) {
        let node = this.getNode(key);
        if (node) {
            return node.value = value;
        }
        node = {
            key,
            value,
            newer: null,
            older: this.newest
        };
        if (this.newest) {
            this.newest.newer = node;
        }
        this.newest = node;
        this.oldest = this.oldest || node;
        this.scheduleFinalization(node);
        this.map.set(key, node);
        this.size++;
        return node.value;
    }
    clean() {
        while(this.oldest && this.size > this.max){
            this.deleteNode(this.oldest);
        }
    }
    deleteNode(node) {
        if (node === this.newest) {
            this.newest = node.older;
        }
        if (node === this.oldest) {
            this.oldest = node.newer;
        }
        if (node.newer) {
            node.newer.older = node.older;
        }
        if (node.older) {
            node.older.newer = node.newer;
        }
        this.size--;
        const key = node.key || node.keyRef && node.keyRef.deref();
        this.dispose(node.value, key);
        if (!node.keyRef) {
            this.unfinalizedNodes.delete(node);
        } else {
            this.registry.unregister(node);
        }
        if (key) this.map.delete(key);
    }
    delete(key) {
        const node = this.map.get(key);
        if (node) {
            this.deleteNode(node);
            return true;
        }
        return false;
    }
    scheduleFinalization(node) {
        this.unfinalizedNodes.add(node);
        if (!this.finalizationScheduled) {
            this.finalizationScheduled = true;
            queueMicrotask(this.finalize);
        }
    }
} //# sourceMappingURL=weak.js.map
}),
"[project]/node_modules/.pnpm/@wry+caches@1.0.1/node_modules/@wry/caches/lib/strong.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "StrongCache": ()=>StrongCache
});
function defaultDispose() {}
class StrongCache {
    constructor(max = Infinity, dispose = defaultDispose){
        this.max = max;
        this.dispose = dispose;
        this.map = new Map();
        this.newest = null;
        this.oldest = null;
    }
    has(key) {
        return this.map.has(key);
    }
    get(key) {
        const node = this.getNode(key);
        return node && node.value;
    }
    get size() {
        return this.map.size;
    }
    getNode(key) {
        const node = this.map.get(key);
        if (node && node !== this.newest) {
            const { older, newer } = node;
            if (newer) {
                newer.older = older;
            }
            if (older) {
                older.newer = newer;
            }
            node.older = this.newest;
            node.older.newer = node;
            node.newer = null;
            this.newest = node;
            if (node === this.oldest) {
                this.oldest = newer;
            }
        }
        return node;
    }
    set(key, value) {
        let node = this.getNode(key);
        if (node) {
            return node.value = value;
        }
        node = {
            key,
            value,
            newer: null,
            older: this.newest
        };
        if (this.newest) {
            this.newest.newer = node;
        }
        this.newest = node;
        this.oldest = this.oldest || node;
        this.map.set(key, node);
        return node.value;
    }
    clean() {
        while(this.oldest && this.map.size > this.max){
            this.delete(this.oldest.key);
        }
    }
    delete(key) {
        const node = this.map.get(key);
        if (node) {
            if (node === this.newest) {
                this.newest = node.older;
            }
            if (node === this.oldest) {
                this.oldest = node.newer;
            }
            if (node.newer) {
                node.newer.older = node.older;
            }
            if (node.older) {
                node.older.newer = node.newer;
            }
            this.map.delete(key);
            this.dispose(node.value, key);
            return true;
        }
        return false;
    }
} //# sourceMappingURL=strong.js.map
}),
"[project]/node_modules/.pnpm/@wry+equality@0.5.7/node_modules/@wry/equality/lib/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__,
    "equal": ()=>equal
});
const { toString, hasOwnProperty } = Object.prototype;
const fnToStr = Function.prototype.toString;
const previousComparisons = new Map();
function equal(a, b) {
    try {
        return check(a, b);
    } finally{
        previousComparisons.clear();
    }
}
const __TURBOPACK__default__export__ = equal;
function check(a, b) {
    // If the two values are strictly equal, our job is easy.
    if (a === b) {
        return true;
    }
    // Object.prototype.toString returns a representation of the runtime type of
    // the given value that is considerably more precise than typeof.
    const aTag = toString.call(a);
    const bTag = toString.call(b);
    // If the runtime types of a and b are different, they could maybe be equal
    // under some interpretation of equality, but for simplicity and performance
    // we just return false instead.
    if (aTag !== bTag) {
        return false;
    }
    switch(aTag){
        case '[object Array]':
            // Arrays are a lot like other objects, but we can cheaply compare their
            // lengths as a short-cut before comparing their elements.
            if (a.length !== b.length) return false;
        // Fall through to object case...
        case '[object Object]':
            {
                if (previouslyCompared(a, b)) return true;
                const aKeys = definedKeys(a);
                const bKeys = definedKeys(b);
                // If `a` and `b` have a different number of enumerable keys, they
                // must be different.
                const keyCount = aKeys.length;
                if (keyCount !== bKeys.length) return false;
                // Now make sure they have the same keys.
                for(let k = 0; k < keyCount; ++k){
                    if (!hasOwnProperty.call(b, aKeys[k])) {
                        return false;
                    }
                }
                // Finally, check deep equality of all child properties.
                for(let k = 0; k < keyCount; ++k){
                    const key = aKeys[k];
                    if (!check(a[key], b[key])) {
                        return false;
                    }
                }
                return true;
            }
        case '[object Error]':
            return a.name === b.name && a.message === b.message;
        case '[object Number]':
            // Handle NaN, which is !== itself.
            if (a !== a) return b !== b;
        // Fall through to shared +a === +b case...
        case '[object Boolean]':
        case '[object Date]':
            return +a === +b;
        case '[object RegExp]':
        case '[object String]':
            return a == `${b}`;
        case '[object Map]':
        case '[object Set]':
            {
                if (a.size !== b.size) return false;
                if (previouslyCompared(a, b)) return true;
                const aIterator = a.entries();
                const isMap = aTag === '[object Map]';
                while(true){
                    const info = aIterator.next();
                    if (info.done) break;
                    // If a instanceof Set, aValue === aKey.
                    const [aKey, aValue] = info.value;
                    // So this works the same way for both Set and Map.
                    if (!b.has(aKey)) {
                        return false;
                    }
                    // However, we care about deep equality of values only when dealing
                    // with Map structures.
                    if (isMap && !check(aValue, b.get(aKey))) {
                        return false;
                    }
                }
                return true;
            }
        case '[object Uint16Array]':
        case '[object Uint8Array]':
        case '[object Uint32Array]':
        case '[object Int32Array]':
        case '[object Int8Array]':
        case '[object Int16Array]':
        case '[object ArrayBuffer]':
            // DataView doesn't need these conversions, but the equality check is
            // otherwise the same.
            a = new Uint8Array(a);
            b = new Uint8Array(b);
        // Fall through...
        case '[object DataView]':
            {
                let len = a.byteLength;
                if (len === b.byteLength) {
                    while(len-- && a[len] === b[len]){
                    // Keep looping as long as the bytes are equal.
                    }
                }
                return len === -1;
            }
        case '[object AsyncFunction]':
        case '[object GeneratorFunction]':
        case '[object AsyncGeneratorFunction]':
        case '[object Function]':
            {
                const aCode = fnToStr.call(a);
                if (aCode !== fnToStr.call(b)) {
                    return false;
                }
                // We consider non-native functions equal if they have the same code
                // (native functions require === because their code is censored).
                // Note that this behavior is not entirely sound, since !== function
                // objects with the same code can behave differently depending on
                // their closure scope. However, any function can behave differently
                // depending on the values of its input arguments (including this)
                // and its calling context (including its closure scope), even
                // though the function object is === to itself; and it is entirely
                // possible for functions that are not === to behave exactly the
                // same under all conceivable circumstances. Because none of these
                // factors are statically decidable in JavaScript, JS function
                // equality is not well-defined. This ambiguity allows us to
                // consider the best possible heuristic among various imperfect
                // options, and equating non-native functions that have the same
                // code has enormous practical benefits, such as when comparing
                // functions that are repeatedly passed as fresh function
                // expressions within objects that are otherwise deeply equal. Since
                // any function created from the same syntactic expression (in the
                // same code location) will always stringify to the same code
                // according to fnToStr.call, we can reasonably expect these
                // repeatedly passed function expressions to have the same code, and
                // thus behave "the same" (with all the caveats mentioned above),
                // even though the runtime function objects are !== to one another.
                return !endsWith(aCode, nativeCodeSuffix);
            }
    }
    // Otherwise the values are not equal.
    return false;
}
function definedKeys(obj) {
    // Remember that the second argument to Array.prototype.filter will be
    // used as `this` within the callback function.
    return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
    return this[key] !== void 0;
}
const nativeCodeSuffix = "{ [native code] }";
function endsWith(full, suffix) {
    const fromIndex = full.length - suffix.length;
    return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a, b) {
    // Though cyclic references can make an object graph appear infinite from the
    // perspective of a depth-first traversal, the graph still contains a finite
    // number of distinct object references. We use the previousComparisons cache
    // to avoid comparing the same pair of object references more than once, which
    // guarantees termination (even if we end up comparing every object in one
    // graph to every object in the other graph, which is extremely unlikely),
    // while still allowing weird isomorphic structures (like rings with different
    // lengths) a chance to pass the equality test.
    let bSet = previousComparisons.get(a);
    if (bSet) {
        // Return true here because we can be sure false will be returned somewhere
        // else if the objects are not equivalent.
        if (bSet.has(b)) return true;
    } else {
        previousComparisons.set(a, bSet = new Set);
    }
    bSet.add(b);
    return false;
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/@wry+trie@0.5.0/node_modules/@wry/trie/lib/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds
// object keys weakly, yet can also hold non-object keys, unlike the
// native `WeakMap`.
// If no makeData function is supplied, the looked-up data will be an empty,
// null-prototype Object.
__turbopack_context__.s({
    "Trie": ()=>Trie
});
const defaultMakeData = ()=>Object.create(null);
// Useful for processing arguments objects as well as arrays.
const { forEach, slice } = Array.prototype;
const { hasOwnProperty } = Object.prototype;
class Trie {
    constructor(weakness = true, makeData = defaultMakeData){
        this.weakness = weakness;
        this.makeData = makeData;
    }
    lookup() {
        return this.lookupArray(arguments);
    }
    lookupArray(array) {
        let node = this;
        forEach.call(array, (key)=>node = node.getChildTrie(key));
        return hasOwnProperty.call(node, "data") ? node.data : node.data = this.makeData(slice.call(array));
    }
    peek() {
        return this.peekArray(arguments);
    }
    peekArray(array) {
        let node = this;
        for(let i = 0, len = array.length; node && i < len; ++i){
            const map = node.mapFor(array[i], false);
            node = map && map.get(array[i]);
        }
        return node && node.data;
    }
    remove() {
        return this.removeArray(arguments);
    }
    removeArray(array) {
        let data;
        if (array.length) {
            const head = array[0];
            const map = this.mapFor(head, false);
            const child = map && map.get(head);
            if (child) {
                data = child.removeArray(slice.call(array, 1));
                if (!child.data && !child.weak && !(child.strong && child.strong.size)) {
                    map.delete(head);
                }
            }
        } else {
            data = this.data;
            delete this.data;
        }
        return data;
    }
    getChildTrie(key) {
        const map = this.mapFor(key, true);
        let child = map.get(key);
        if (!child) map.set(key, child = new Trie(this.weakness, this.makeData));
        return child;
    }
    mapFor(key, create) {
        return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = new WeakMap : void 0) : this.strong || (create ? this.strong = new Map : void 0);
    }
}
function isObjRef(value) {
    switch(typeof value){
        case "object":
            if (value === null) break;
        // Fall through to return true...
        case "function":
            return true;
    }
    return false;
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/slot.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// This currentContext variable will only be used if the makeSlotClass
// function is called, which happens only if this is the first copy of the
// @wry/context package to be imported.
__turbopack_context__.s({
    "Slot": ()=>Slot
});
let currentContext = null;
// This unique internal object is used to denote the absence of a value
// for a given Slot, and is never exposed to outside code.
const MISSING_VALUE = {};
let idCounter = 1;
// Although we can't do anything about the cost of duplicated code from
// accidentally bundling multiple copies of the @wry/context package, we can
// avoid creating the Slot class more than once using makeSlotClass.
const makeSlotClass = ()=>class Slot {
        constructor(){
            // If you have a Slot object, you can find out its slot.id, but you cannot
            // guess the slot.id of a Slot you don't have access to, thanks to the
            // randomized suffix.
            this.id = [
                "slot",
                idCounter++,
                Date.now(),
                Math.random().toString(36).slice(2)
            ].join(":");
        }
        hasValue() {
            for(let context = currentContext; context; context = context.parent){
                // We use the Slot object iself as a key to its value, which means the
                // value cannot be obtained without a reference to the Slot object.
                if (this.id in context.slots) {
                    const value = context.slots[this.id];
                    if (value === MISSING_VALUE) break;
                    if (context !== currentContext) {
                        // Cache the value in currentContext.slots so the next lookup will
                        // be faster. This caching is safe because the tree of contexts and
                        // the values of the slots are logically immutable.
                        currentContext.slots[this.id] = value;
                    }
                    return true;
                }
            }
            if (currentContext) {
                // If a value was not found for this Slot, it's never going to be found
                // no matter how many times we look it up, so we might as well cache
                // the absence of the value, too.
                currentContext.slots[this.id] = MISSING_VALUE;
            }
            return false;
        }
        getValue() {
            if (this.hasValue()) {
                return currentContext.slots[this.id];
            }
        }
        withValue(value, callback, // Given the prevalence of arrow functions, specifying arguments is likely
        // to be much more common than specifying `this`, hence this ordering:
        args, thisArg) {
            const slots = {
                __proto__: null,
                [this.id]: value
            };
            const parent = currentContext;
            currentContext = {
                parent,
                slots
            };
            try {
                // Function.prototype.apply allows the arguments array argument to be
                // omitted or undefined, so args! is fine here.
                return callback.apply(thisArg, args);
            } finally{
                currentContext = parent;
            }
        }
        // Capture the current context and wrap a callback function so that it
        // reestablishes the captured context when called.
        static bind(callback) {
            const context = currentContext;
            return function() {
                const saved = currentContext;
                try {
                    currentContext = context;
                    return callback.apply(this, arguments);
                } finally{
                    currentContext = saved;
                }
            };
        }
        // Immediately run a callback function without any captured context.
        static noContext(callback, // Given the prevalence of arrow functions, specifying arguments is likely
        // to be much more common than specifying `this`, hence this ordering:
        args, thisArg) {
            if (currentContext) {
                const saved = currentContext;
                try {
                    currentContext = null;
                    // Function.prototype.apply allows the arguments array argument to be
                    // omitted or undefined, so args! is fine here.
                    return callback.apply(thisArg, args);
                } finally{
                    currentContext = saved;
                }
            } else {
                return callback.apply(thisArg, args);
            }
        }
    };
function maybe(fn) {
    try {
        return fn();
    } catch (ignored) {}
}
// We store a single global implementation of the Slot class as a permanent
// non-enumerable property of the globalThis object. This obfuscation does
// nothing to prevent access to the Slot class, but at least it ensures the
// implementation (i.e. currentContext) cannot be tampered with, and all copies
// of the @wry/context package (hopefully just one) will share the same Slot
// implementation. Since the first copy of the @wry/context package to be
// imported wins, this technique imposes a steep cost for any future breaking
// changes to the Slot class.
const globalKey = "@wry/context:Slot";
const host = // Prefer globalThis when available.
// https://github.com/benjamn/wryware/issues/347
maybe(()=>globalThis) || // Fall back to global, which works in Node.js and may be converted by some
// bundlers to the appropriate identifier (window, self, ...) depending on the
// bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
maybe(()=>("TURBOPACK ident replacement", globalThis)) || // Otherwise, use a dummy host that's local to this module. We used to fall
// back to using the Array constructor as a namespace, but that was flagged in
// https://github.com/benjamn/wryware/issues/347, and can be avoided.
Object.create(null);
// Whichever globalHost we're using, make TypeScript happy about the additional
// globalKey property.
const globalHost = host;
const Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array
// constructor, so we check there as well, to prevent Slot class duplication.
Array[globalKey] || function(Slot) {
    try {
        Object.defineProperty(globalHost, globalKey, {
            value: Slot,
            enumerable: false,
            writable: false,
            // When it was possible for globalHost to be the Array constructor (a
            // legacy Slot dedup strategy), it was important for the property to be
            // configurable:true so it could be deleted. That does not seem to be as
            // important when globalHost is the global object, but I don't want to
            // cause similar problems again, and configurable:true seems safest.
            // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
            configurable: true
        });
    } finally{
        return Slot;
    }
}(makeSlotClass()); //# sourceMappingURL=slot.js.map
}),
"[project]/node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "asyncFromGen": ()=>asyncFromGen,
    "bind": ()=>bind,
    "noContext": ()=>noContext,
    "setTimeout": ()=>setTimeoutWithContext,
    "wrapYieldingFiberMethods": ()=>wrapYieldingFiberMethods
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$context$40$0$2e$7$2e$4$2f$node_modules$2f40$wry$2f$context$2f$lib$2f$slot$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/slot.js [app-ssr] (ecmascript)");
;
;
const { bind, noContext } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$context$40$0$2e$7$2e$4$2f$node_modules$2f40$wry$2f$context$2f$lib$2f$slot$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Slot"];
;
function setTimeoutWithContext(callback, delay) {
    return setTimeout(bind(callback), delay);
}
function asyncFromGen(genFn) {
    return function() {
        const gen = genFn.apply(this, arguments);
        const boundNext = bind(gen.next);
        const boundThrow = bind(gen.throw);
        return new Promise((resolve, reject)=>{
            function invoke(method, argument) {
                try {
                    var result = method.call(gen, argument);
                } catch (error) {
                    return reject(error);
                }
                const next = result.done ? resolve : invokeNext;
                if (isPromiseLike(result.value)) {
                    result.value.then(next, result.done ? reject : invokeThrow);
                } else {
                    next(result.value);
                }
            }
            const invokeNext = (value)=>invoke(boundNext, value);
            const invokeThrow = (error)=>invoke(boundThrow, error);
            invokeNext();
        });
    };
}
function isPromiseLike(value) {
    return value && typeof value.then === "function";
}
// If you use the fibers npm package to implement coroutines in Node.js,
// you should call this function at least once to ensure context management
// remains coherent across any yields.
const wrappedFibers = [];
function wrapYieldingFiberMethods(Fiber) {
    // There can be only one implementation of Fiber per process, so this array
    // should never grow longer than one element.
    if (wrappedFibers.indexOf(Fiber) < 0) {
        const wrap = (obj, method)=>{
            const fn = obj[method];
            obj[method] = function() {
                return noContext(fn, arguments, this);
            };
        };
        // These methods can yield, according to
        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100
        wrap(Fiber, "yield");
        wrap(Fiber.prototype, "run");
        wrap(Fiber.prototype, "throwInto");
        wrappedFibers.push(Fiber);
    }
    return Fiber;
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$context$40$0$2e$7$2e$4$2f$node_modules$2f40$wry$2f$context$2f$lib$2f$slot$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/slot.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$context$40$0$2e$7$2e$4$2f$node_modules$2f40$wry$2f$context$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/index.js [app-ssr] (ecmascript) <locals>");
}),
"[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/context.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "nonReactive": ()=>nonReactive,
    "parentEntrySlot": ()=>parentEntrySlot
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$context$40$0$2e$7$2e$4$2f$node_modules$2f40$wry$2f$context$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$context$40$0$2e$7$2e$4$2f$node_modules$2f40$wry$2f$context$2f$lib$2f$slot$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/slot.js [app-ssr] (ecmascript)");
;
const parentEntrySlot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$context$40$0$2e$7$2e$4$2f$node_modules$2f40$wry$2f$context$2f$lib$2f$slot$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Slot"]();
function nonReactive(fn) {
    return parentEntrySlot.withValue(void 0, fn);
}
;
;
 //# sourceMappingURL=context.js.map
}),
"[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/context.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$context$40$0$2e$7$2e$4$2f$node_modules$2f40$wry$2f$context$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/context.js [app-ssr] (ecmascript) <locals>");
}),
"[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/helpers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "arrayFromSet": ()=>arrayFromSet,
    "hasOwnProperty": ()=>hasOwnProperty,
    "maybeUnsubscribe": ()=>maybeUnsubscribe
});
const { hasOwnProperty } = Object.prototype;
const arrayFromSet = Array.from || function(set) {
    const array = [];
    set.forEach((item)=>array.push(item));
    return array;
};
function maybeUnsubscribe(entryOrDep) {
    const { unsubscribe } = entryOrDep;
    if (typeof unsubscribe === "function") {
        entryOrDep.unsubscribe = void 0;
        unsubscribe();
    }
} //# sourceMappingURL=helpers.js.map
}),
"[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/entry.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Entry": ()=>Entry
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/context.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/context.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/helpers.js [app-ssr] (ecmascript)");
;
;
const emptySetPool = [];
const POOL_TARGET_SIZE = 100;
// Since this package might be used browsers, we should avoid using the
// Node built-in assert module.
function assert(condition, optionalMessage) {
    if (!condition) {
        throw new Error(optionalMessage || "assertion failure");
    }
}
function valueIs(a, b) {
    const len = a.length;
    return(// Unknown values are not equal to each other.
    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    len === b.length && // The underlying value or exception must be the same.
    a[len - 1] === b[len - 1]);
}
function valueGet(value) {
    switch(value.length){
        case 0:
            throw new Error("unknown value");
        case 1:
            return value[0];
        case 2:
            throw value[1];
    }
}
function valueCopy(value) {
    return value.slice(0);
}
class Entry {
    constructor(fn){
        this.fn = fn;
        this.parents = new Set();
        this.childValues = new Map();
        // When this Entry has children that are dirty, this property becomes
        // a Set containing other Entry objects, borrowed from emptySetPool.
        // When the set becomes empty, it gets recycled back to emptySetPool.
        this.dirtyChildren = null;
        this.dirty = true;
        this.recomputing = false;
        this.value = [];
        this.deps = null;
        ++Entry.count;
    }
    peek() {
        if (this.value.length === 1 && !mightBeDirty(this)) {
            rememberParent(this);
            return this.value[0];
        }
    }
    // This is the most important method of the Entry API, because it
    // determines whether the cached this.value can be returned immediately,
    // or must be recomputed. The overall performance of the caching system
    // depends on the truth of the following observations: (1) this.dirty is
    // usually false, (2) this.dirtyChildren is usually null/empty, and thus
    // (3) valueGet(this.value) is usually returned without recomputation.
    recompute(args) {
        assert(!this.recomputing, "already recomputing");
        rememberParent(this);
        return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
    }
    setDirty() {
        if (this.dirty) return;
        this.dirty = true;
        reportDirty(this);
        // We can go ahead and unsubscribe here, since any further dirty
        // notifications we receive will be redundant, and unsubscribing may
        // free up some resources, e.g. file watchers.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["maybeUnsubscribe"])(this);
    }
    dispose() {
        this.setDirty();
        // Sever any dependency relationships with our own children, so those
        // children don't retain this parent Entry in their child.parents sets,
        // thereby preventing it from being fully garbage collected.
        forgetChildren(this);
        // Because this entry has been kicked out of the cache (in index.js),
        // we've lost the ability to find out if/when this entry becomes dirty,
        // whether that happens through a subscription, because of a direct call
        // to entry.setDirty(), or because one of its children becomes dirty.
        // Because of this loss of future information, we have to assume the
        // worst (that this entry might have become dirty very soon), so we must
        // immediately mark this entry's parents as dirty. Normally we could
        // just call entry.setDirty() rather than calling parent.setDirty() for
        // each parent, but that would leave this entry in parent.childValues
        // and parent.dirtyChildren, which would prevent the child from being
        // truly forgotten.
        eachParent(this, (parent, child)=>{
            parent.setDirty();
            forgetChild(parent, this);
        });
    }
    forget() {
        // The code that creates Entry objects in index.ts will replace this method
        // with one that actually removes the Entry from the cache, which will also
        // trigger the entry.dispose method.
        this.dispose();
    }
    dependOn(dep) {
        dep.add(this);
        if (!this.deps) {
            this.deps = emptySetPool.pop() || new Set();
        }
        this.deps.add(dep);
    }
    forgetDeps() {
        if (this.deps) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrayFromSet"])(this.deps).forEach((dep)=>dep.delete(this));
            this.deps.clear();
            emptySetPool.push(this.deps);
            this.deps = null;
        }
    }
}
Entry.count = 0;
function rememberParent(child) {
    const parent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parentEntrySlot"].getValue();
    if (parent) {
        child.parents.add(parent);
        if (!parent.childValues.has(child)) {
            parent.childValues.set(child, []);
        }
        if (mightBeDirty(child)) {
            reportDirtyChild(parent, child);
        } else {
            reportCleanChild(parent, child);
        }
        return parent;
    }
}
function reallyRecompute(entry, args) {
    forgetChildren(entry);
    // Set entry as the parent entry while calling recomputeNewValue(entry).
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parentEntrySlot"].withValue(entry, recomputeNewValue, [
        entry,
        args
    ]);
    if (maybeSubscribe(entry, args)) {
        // If we successfully recomputed entry.value and did not fail to
        // (re)subscribe, then this Entry is no longer explicitly dirty.
        setClean(entry);
    }
    return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
    entry.recomputing = true;
    const { normalizeResult } = entry;
    let oldValueCopy;
    if (normalizeResult && entry.value.length === 1) {
        oldValueCopy = valueCopy(entry.value);
    }
    // Make entry.value an empty array, representing an unknown value.
    entry.value.length = 0;
    try {
        // If entry.fn succeeds, entry.value will become a normal Value.
        entry.value[0] = entry.fn.apply(null, args);
        // If we have a viable oldValueCopy to compare with the (successfully
        // recomputed) new entry.value, and they are not already === identical, give
        // normalizeResult a chance to pick/choose/reuse parts of oldValueCopy[0]
        // and/or entry.value[0] to determine the final cached entry.value.
        if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {
            try {
                entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);
            } catch (_a) {
            // If normalizeResult throws, just use the newer value, rather than
            // saving the exception as entry.value[1].
            }
        }
    } catch (e) {
        // If entry.fn throws, entry.value will hold that exception.
        entry.value[1] = e;
    }
    // Either way, this line is always reached.
    entry.recomputing = false;
}
function mightBeDirty(entry) {
    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
    entry.dirty = false;
    if (mightBeDirty(entry)) {
        // This Entry may still have dirty children, in which case we can't
        // let our parents know we're clean just yet.
        return;
    }
    reportClean(entry);
}
function reportDirty(child) {
    eachParent(child, reportDirtyChild);
}
function reportClean(child) {
    eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
    const parentCount = child.parents.size;
    if (parentCount) {
        const parents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrayFromSet"])(child.parents);
        for(let i = 0; i < parentCount; ++i){
            callback(parents[i], child);
        }
    }
}
// Let a parent Entry know that one of its children may be dirty.
function reportDirtyChild(parent, child) {
    // Must have called rememberParent(child) before calling
    // reportDirtyChild(parent, child).
    assert(parent.childValues.has(child));
    assert(mightBeDirty(child));
    const parentWasClean = !mightBeDirty(parent);
    if (!parent.dirtyChildren) {
        parent.dirtyChildren = emptySetPool.pop() || new Set;
    } else if (parent.dirtyChildren.has(child)) {
        // If we already know this child is dirty, then we must have already
        // informed our own parents that we are dirty, so we can terminate
        // the recursion early.
        return;
    }
    parent.dirtyChildren.add(child);
    // If parent was clean before, it just became (possibly) dirty (according to
    // mightBeDirty), since we just added child to parent.dirtyChildren.
    if (parentWasClean) {
        reportDirty(parent);
    }
}
// Let a parent Entry know that one of its children is no longer dirty.
function reportCleanChild(parent, child) {
    // Must have called rememberChild(child) before calling
    // reportCleanChild(parent, child).
    assert(parent.childValues.has(child));
    assert(!mightBeDirty(child));
    const childValue = parent.childValues.get(child);
    if (childValue.length === 0) {
        parent.childValues.set(child, valueCopy(child.value));
    } else if (!valueIs(childValue, child.value)) {
        parent.setDirty();
    }
    removeDirtyChild(parent, child);
    if (mightBeDirty(parent)) {
        return;
    }
    reportClean(parent);
}
function removeDirtyChild(parent, child) {
    const dc = parent.dirtyChildren;
    if (dc) {
        dc.delete(child);
        if (dc.size === 0) {
            if (emptySetPool.length < POOL_TARGET_SIZE) {
                emptySetPool.push(dc);
            }
            parent.dirtyChildren = null;
        }
    }
}
// Removes all children from this entry and returns an array of the
// removed children.
function forgetChildren(parent) {
    if (parent.childValues.size > 0) {
        parent.childValues.forEach((_value, child)=>{
            forgetChild(parent, child);
        });
    }
    // Remove this parent Entry from any sets to which it was added by the
    // addToSet method.
    parent.forgetDeps();
    // After we forget all our children, this.dirtyChildren must be empty
    // and therefore must have been reset to null.
    assert(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
    child.parents.delete(parent);
    parent.childValues.delete(child);
    removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
    if (typeof entry.subscribe === "function") {
        try {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["maybeUnsubscribe"])(entry); // Prevent double subscriptions.
            entry.unsubscribe = entry.subscribe.apply(null, args);
        } catch (e) {
            // If this Entry has a subscribe function and it threw an exception
            // (or an unsubscribe function it previously returned now throws),
            // return false to indicate that we were not able to subscribe (or
            // unsubscribe), and this Entry should remain dirty.
            entry.setDirty();
            return false;
        }
    }
    // Returning true indicates either that there was no entry.subscribe
    // function or that it succeeded.
    return true;
} //# sourceMappingURL=entry.js.map
}),
"[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/dep.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "dep": ()=>dep
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/context.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/context.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/helpers.js [app-ssr] (ecmascript)");
;
;
const EntryMethods = {
    setDirty: true,
    dispose: true,
    forget: true
};
function dep(options) {
    const depsByKey = new Map();
    const subscribe = options && options.subscribe;
    function depend(key) {
        const parent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parentEntrySlot"].getValue();
        if (parent) {
            let dep = depsByKey.get(key);
            if (!dep) {
                depsByKey.set(key, dep = new Set);
            }
            parent.dependOn(dep);
            if (typeof subscribe === "function") {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["maybeUnsubscribe"])(dep);
                dep.unsubscribe = subscribe(key);
            }
        }
    }
    depend.dirty = function dirty(key, entryMethodName) {
        const dep = depsByKey.get(key);
        if (dep) {
            const m = entryMethodName && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasOwnProperty"].call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,
            // because modifying a Set while iterating over it can cause elements in
            // the Set to be removed from the Set before they've been iterated over.
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrayFromSet"])(dep).forEach((entry)=>entry[m]());
            depsByKey.delete(key);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["maybeUnsubscribe"])(dep);
        }
    };
    return depend;
} //# sourceMappingURL=dep.js.map
}),
"[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "defaultMakeCacheKey": ()=>defaultMakeCacheKey,
    "wrap": ()=>wrap
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$trie$40$0$2e$5$2e$0$2f$node_modules$2f40$wry$2f$trie$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@wry+trie@0.5.0/node_modules/@wry/trie/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$caches$40$1$2e$0$2e$1$2f$node_modules$2f40$wry$2f$caches$2f$lib$2f$strong$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@wry+caches@1.0.1/node_modules/@wry/caches/lib/strong.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$entry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/entry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/context.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/context.js [app-ssr] (ecmascript) <locals>");
// A lighter-weight dependency, similar to OptimisticWrapperFunction, except
// with only one argument, no makeCacheKey, no wrapped function to recompute,
// and no result value. Useful for representing dependency leaves in the graph
// of computation. Subscriptions are supported.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$dep$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/dep.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
// The defaultMakeCacheKey function is remarkably powerful, because it gives
// a unique object for any shallow-identical list of arguments. If you need
// to implement a custom makeCacheKey function, you may find it helpful to
// delegate the final work to defaultMakeCacheKey, which is why we export it
// here. However, you may want to avoid defaultMakeCacheKey if your runtime
// does not support WeakMap, or you have the ability to return a string key.
// In those cases, just write your own custom makeCacheKey functions.
let defaultKeyTrie;
function defaultMakeCacheKey(...args) {
    const trie = defaultKeyTrie || (defaultKeyTrie = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$trie$40$0$2e$5$2e$0$2f$node_modules$2f40$wry$2f$trie$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Trie"](typeof WeakMap === "function"));
    return trie.lookupArray(args);
}
;
;
const caches = new Set();
function wrap(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$caches$40$1$2e$0$2e$1$2f$node_modules$2f40$wry$2f$caches$2f$lib$2f$strong$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StrongCache"] } = Object.create(null)) {
    const cache = typeof cacheOption === "function" ? new cacheOption(max, (entry)=>entry.dispose()) : cacheOption;
    const optimistic = function() {
        const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
        if (key === void 0) {
            return originalFunction.apply(null, arguments);
        }
        let entry = cache.get(key);
        if (!entry) {
            cache.set(key, entry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$entry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Entry"](originalFunction));
            entry.normalizeResult = normalizeResult;
            entry.subscribe = subscribe;
            // Give the Entry the ability to trigger cache.delete(key), even though
            // the Entry itself does not know about key or cache.
            entry.forget = ()=>cache.delete(key);
        }
        const value = entry.recompute(Array.prototype.slice.call(arguments));
        // Move this entry to the front of the least-recently used queue,
        // since we just finished computing its value.
        cache.set(key, entry);
        caches.add(cache);
        // Clean up any excess entries in the cache, but only if there is no
        // active parent entry, meaning we're not in the middle of a larger
        // computation that might be flummoxed by the cleaning.
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parentEntrySlot"].hasValue()) {
            caches.forEach((cache)=>cache.clean());
            caches.clear();
        }
        return value;
    };
    Object.defineProperty(optimistic, "size", {
        get: ()=>cache.size,
        configurable: false,
        enumerable: false
    });
    Object.freeze(optimistic.options = {
        max,
        keyArgs,
        makeCacheKey,
        normalizeResult,
        subscribe,
        cache
    });
    function dirtyKey(key) {
        const entry = key && cache.get(key);
        if (entry) {
            entry.setDirty();
        }
    }
    optimistic.dirtyKey = dirtyKey;
    optimistic.dirty = function dirty() {
        dirtyKey(makeCacheKey.apply(null, arguments));
    };
    function peekKey(key) {
        const entry = key && cache.get(key);
        if (entry) {
            return entry.peek();
        }
    }
    optimistic.peekKey = peekKey;
    optimistic.peek = function peek() {
        return peekKey(makeCacheKey.apply(null, arguments));
    };
    function forgetKey(key) {
        return key ? cache.delete(key) : false;
    }
    optimistic.forgetKey = forgetKey;
    optimistic.forget = function forget() {
        return forgetKey(makeCacheKey.apply(null, arguments));
    };
    optimistic.makeCacheKey = makeCacheKey;
    optimistic.getKey = keyArgs ? function getKey() {
        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
    } : makeCacheKey;
    return Object.freeze(optimistic);
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$wry$2b$trie$40$0$2e$5$2e$0$2f$node_modules$2f40$wry$2f$trie$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@wry+trie@0.5.0/node_modules/@wry/trie/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$entry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/entry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/context.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$dep$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/dep.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$optimism$40$0$2e$18$2e$1$2f$node_modules$2f$optimism$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/optimism@0.18.1/node_modules/optimism/lib/index.js [app-ssr] (ecmascript) <locals>");
}),

};

//# sourceMappingURL=node_modules__pnpm_45e296b5._.js.map